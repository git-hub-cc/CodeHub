[
  {
    "name": "spring-boot-starter-web",
    "summary": "Spring Boot Starter Web 用于快速构建基于 Servlet 栈的 Web 应用程序，支持 RESTful API 和传统 MVC 视图开发，提供内嵌服务器和自动化配置。",
    "notes": "# spring-boot-starter-web\n\n## 示例\n\n### 添加依赖\n在 Maven 项目的 `pom.xml` 中添加 `spring-boot-starter-web` 依赖，版本由 `spring-boot-starter-parent` 统一管理：\n\n```xml\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;\n&lt;/dependency&gt;\n```\n\n### 创建 REST 控制器\n创建一个简单的 REST 控制器处理 HTTP GET 请求：\n\n```java\n@RestController\n@RequestMapping(&quot;/api/users&quot;)\npublic class UserController {\n    @GetMapping(&quot;/{id}&quot;)\n    public User getUserById(@PathVariable Long id) {\n        return new User(id, &quot;John Doe&quot;);\n    }\n}\n```\n\n## 解决的问题\n\n`spring-boot-starter-web` 是 Spring Boot 的核心 Starter，简化基于 Servlet 栈的 Web 应用开发，解决以下问题：\n\n- **复杂依赖管理**：自动引入 Spring MVC、Jackson（JSON 序列化）、Hibernate Validator（数据校验）、Tomcat（内嵌服务器）等依赖，开发者无需手动管理版本兼容性。\n- **繁琐配置**：通过自动化配置（如 DispatcherServlet、HttpMessageConverters），减少 XML 或 Java 配置工作量。\n- **服务器部署复杂性**：内嵌 Tomcat 服务器，支持直接运行 JAR 文件，免去传统 WAR 文件部署麻烦。\n- **开发效率**：提供开箱即用的功能（如 REST API 开发、异常处理、静态资源管理），让开发者专注于业务逻辑。\n\n## 核心功能与使用方法\n\n引入 `spring-boot-starter-web` 后，可快速构建 Web 应用，以下是核心功能及使用方式：\n\n### 1. RESTful API 开发\n使用 `@RestController` 创建 REST 控制器，结合 `@RequestMapping`、`@GetMapping`、`@PostMapping` 等注解处理 HTTP 请求：\n\n```java\n@RestController\n@RequestMapping(&quot;/api/products&quot;)\npublic class ProductController {\n    @GetMapping(&quot;/{id}&quot;)\n    public Product getProduct(@PathVariable Long id) {\n        return new Product(id, &quot;Sample Product&quot;, 99.99);\n    }\n    @PostMapping\n    public Product createProduct(@RequestBody Product product) {\n        return product; // 模拟保存并返回\n    }\n}\n```\n\n### 2. JSON 序列化与反序列化\n默认使用 Jackson 库，自动将 POJO 序列化为 JSON 响应，或将请求体的 JSON 反序列化为 Java 对象。支持通过 `@RequestBody` 获取 JSON 数据，通过 `@ResponseBody` 返回 JSON。\n\n### 3. 请求参数处理\n使用 `@RequestParam` 获取查询参数，`@PathVariable` 获取路径参数，`@RequestBody` 获取请求体数据：\n\n```java\n@GetMapping(&quot;/search&quot;)\npublic List&lt;Product&gt; searchProducts(@RequestParam String keyword) {\n    // 模拟搜索逻辑\n    return Collections.singletonList(new Product(1L, keyword, 50.0));\n}\n```\n\n### 4. 全局异常处理\n使用 `@RestControllerAdvice` 和 `@ExceptionHandler` 捕获并处理异常，返回统一格式的错误响应：\n\n```java\n@RestControllerAdvice\npublic class GlobalExceptionHandler {\n    @ExceptionHandler(IllegalArgumentException.class)\n    public ResponseEntity&lt;String&gt; handleIllegalArgument(IllegalArgumentException ex) {\n        return ResponseEntity.badRequest().body(&quot;Invalid input: &quot; + ex.getMessage());\n    }\n}\n```\n\n### 5. 静态资源管理\n默认支持从 `classpath:/static/`, `classpath:/public/`, `classpath:/resources/`, `classpath:/META-INF/resources/` 加载静态资源（如 HTML、CSS、JS）。可通过 `spring.mvc.static-path-pattern` 自定义静态资源路径。\n\n## 版本与依赖管理\n\n- **版本管理**：依赖版本由 `spring-boot-starter-parent` 或 Spring Boot 依赖管理插件统一管理，无需手动指定 `&lt;version&gt;`。\n- **查询版本**：查看最新版本或历史版本，可访问 [Maven 中央仓库](https://mvnrepository.com/search?q=spring-boot-starter-web).\n\n## 常用配置文件\n\n在 `application.yml` 中配置 Web 相关行为：\n\n```yaml\nserver:\n  port: 8080\n  servlet:\n    context-path: /myapp\nspring:\n  mvc:\n    static-path-pattern: /static/**\n    throw-exception-if-no-handler-found: true\n  jackson:\n    date-format: yyyy-MM-dd HH:mm:ss\n    time-zone: GMT+8\n    property-naming-strategy: SNAKE_CASE\n  servlet:\n    multipart:\n      enabled: true\n      max-file-size: 50MB\n      max-request-size: 100MB\nlogging:\n  level:\n    org.springframework.web: DEBUG\n```\n\n### 配置说明\n\n- `server.port`：设置服务器监听端口。\n- `server.servlet.context-path`：设置应用上下文路径。\n- `spring.mvc.static-path-pattern`：自定义静态资源访问路径。\n- `spring.jackson.*`：配置 JSON 序列化格式，如日期格式或命名策略。\n- `spring.servlet.multipart.*`：配置文件上传限制。\n\n## 注意事项\n\n- **前置条件**：\n  - 项目需为 Spring Boot 项目，推荐继承 `spring-boot-starter-parent` 或使用 `spring-boot-dependencies` BOM。\n  - Java 版本需与 Spring Boot 版本兼容（如 Spring Boot 3.x 要求 Java 17+）。\n- **特殊版本情况**：\n  - **Spring Boot 2.x vs. 3.x**：Spring Boot 3.x 使用 Jakarta EE（`jakarta.*` 包）替代 Java EE（`javax.*` 包），需选择兼容版本的依赖库。\n  - **内嵌服务器切换**：默认使用 Tomcat，可通过排除 `spring-boot-starter-tomcat` 并引入 `spring-boot-starter-jetty` 或 `spring-boot-starter-undertow` 切换服务器：\n\n    ```xml\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;\n        &lt;exclusions&gt;\n            &lt;exclusion&gt;\n                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n                &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt;\n            &lt;/exclusion&gt;\n        &lt;/exclusions&gt;\n    &lt;/dependency&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n        &lt;artifactId&gt;spring-boot-starter-jetty&lt;/artifactId&gt;\n    &lt;/dependency&gt;\n    ```\n\n- **Servlet 栈 vs. Reactive 栈**：基于同步阻塞式 Servlet API，不支持响应式编程。若需异步非阻塞开发，使用 `spring-boot-starter-webflux`，两者不可同时引入。\n\n## 常用注解\n\n### 控制器相关\n- `@RestController`：标记类为 REST 控制器，方法返回值自动序列化为 JSON。\n- `@Controller`：标记类为 MVC 控制器，通常与视图模板结合。\n- `@RequestMapping`：定义请求路径和方法，可用于类或方法级别。\n- `@GetMapping`, `@PostMapping`, `@PutMapping`, `@DeleteMapping`：快捷定义 HTTP 方法映射。\n\n### 请求参数处理\n- `@PathVariable`：获取 URL 路径中的变量。\n- `@RequestParam`：获取查询参数。\n- `@RequestBody`：将请求体反序列化为 Java 对象。\n- `@RequestHeader`：获取请求头信息。\n\n### 响应控制\n- `@ResponseBody`：将方法返回值序列化为响应体（`@RestController` 已隐含）。\n- `@ResponseStatus`：自定义 HTTP 响应状态码。\n\n### 异常处理\n- `@RestControllerAdvice`：定义全局异常处理类。\n- `@ExceptionHandler`：指定处理特定异常的方法。\n\n### 跨域支持\n- `@CrossOrigin`：允许跨域请求，可用于类或方法级别。\n\n## 常见问题排查\n\n### 1. 端口占用\n**问题**：启动时提示 `Port 8080 was already in use`。\n**原因**：端口被其他进程占用。\n**解决**：\n- 检查并关闭占用 8080 端口的进程（使用 `netstat -aon` 或 `lsof -i :8080`）。\n- 修改 `application.yml` 中的 `server.port` 为其他端口，如 8081。\n\n### 2. 请求返回 404 Not Found\n**原因**：Spring MVC 未找到匹配的 Controller 方法。\n**排查**：\n- 确保 `@SpringBootApplication` 所在包覆盖 Controller 包。\n- 检查 `@RestController` 或 `@Controller` 注解是否正确添加。\n- 验证请求 URL 和 HTTP 方法是否与 `@RequestMapping` 一致。\n- 若配置了 `server.servlet.context-path`，确保 URL 包含上下文路径。\n\n### 3. JSON 数据绑定失败\n**问题**：接收 JSON 数据时参数为 null 或报 400 Bad Request。\n**原因**：JSON 结构与 Java 对象不匹配，或 `Content-Type` 错误。\n**排查**：\n- 确保方法参数添加 `@RequestBody` 注解。\n- 检查请求头 `Content-Type` 是否为 `application/json`。\n- 使用工具（如 Postman）验证 JSON 字段名、类型与 Java 类一致。\n\n### 4. 跨域错误 (CORS)\n**问题**：浏览器报跨域错误。\n**原因**：浏览器限制了跨源请求。\n**解决**：\n- 在 Controller 上添加 `@CrossOrigin` 注解。\n- 配置全局 CORS：\n\n    ```java\n    @Configuration\n    public class WebConfig implements WebMvcConfigurer {\n        @Override\n        public void addCorsMappings(CorsRegistry registry) {\n            registry.addMapping(&quot;/**&quot;).allowedOrigins(&quot;*&quot;).allowedMethods(&quot;GET&quot;, &quot;POST&quot;, &quot;PUT&quot;, &quot;DELETE&quot;);\n        }\n    }\n    ```\n\n### 5. 静态资源无法访问\n**原因**：资源路径配置错误或文件位置不正确。\n**排查**：\n- 确保静态文件位于 `classpath:/static/` 等默认路径。\n- 检查 `spring.mvc.static-path-pattern` 是否正确配置。\n- 验证请求 URL 是否匹配静态资源路径。\n\n### 6. 依赖冲突\n**问题**：依赖冲突导致启动失败。\n**原因**：手动引入的依赖与 Spring Boot 版本不兼容。\n**解决**：\n- 使用 `spring-boot-starter-parent` 或 `spring-boot-dependencies` 管理版本。\n- 运行 `mvn dependency:tree` 检查依赖冲突并排除不兼容版本。"
  },
  {
    "name": "spring-boot-starter-webflux",
    "summary": "用于构建基于 Reactor 的响应式 Web 应用，支持非阻塞、异步的 RESTful API 开发，适用于高并发、低延迟场景。",
    "notes": "# spring-boot-starter-webflux\n\n## 示例\n\n### 添加依赖\n在 Maven 项目的 `pom.xml` 中添加 `spring-boot-starter-webflux` 依赖，版本由 `spring-boot-starter-parent` 统一管理：\n\n```xml\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-webflux&lt;/artifactId&gt;\n&lt;/dependency&gt;\n```\n\n### 创建响应式控制器\n使用 `@RestController` 结合 Reactor 的 `Mono` 和 `Flux` 类型处理异步 HTTP 请求：\n\n```java\n@RestController\n@RequestMapping(&quot;/api/users&quot;)\npublic class UserController {\n    @GetMapping(&quot;/{id}&quot;)\n    public Mono&lt;User&gt; getUserById(@PathVariable Long id) {\n        return Mono.just(new User(id, &quot;Jane Doe&quot;));\n    }\n\n    @GetMapping\n    public Flux&lt;User&gt; getAllUsers() {\n        return Flux.just(new User(1L, &quot;Jane Doe&quot;), new User(2L, &quot;John Smith&quot;));\n    }\n}\n```\n\n### 流式响应（SSE）\n支持流式响应，如 Server-Sent Events (SSE)：\n\n```java\n@GetMapping(path = &quot;/stream&quot;, produces = MediaType.TEXT_EVENT_STREAM_VALUE)\npublic Flux&lt;String&gt; streamEvents() {\n    return Flux.interval(Duration.ofSeconds(1))\n               .map(i -&gt; &quot;Event &quot; + i);\n}\n```\n\n### 使用 WebClient\n`WebClient` 是响应式的 HTTP 客户端，适合调用外部 API：\n\n```java\n@Bean\npublic WebClient webClient() {\n    return WebClient.create(&quot;https://api.example.com&quot;);\n}\n\n@Autowired\nprivate WebClient webClient;\n\n@GetMapping(&quot;/external-data&quot;)\npublic Mono&lt;String&gt; fetchExternalData() {\n    return webClient.get()\n                    .uri(&quot;/data&quot;)\n                    .retrieve()\n                    .bodyToMono(String.class);\n}\n```\n\n## 解决的问题\n\n`spring-boot-starter-webflux` 是为响应式编程设计的 Starter，解决传统阻塞式 Web 应用在高并发场景下的性能瓶颈：\n\n- **非阻塞和高并发**：通过响应式编程模型，处理大量并发请求，降低资源占用，提升吞吐量。\n- **简化响应式开发**：自动引入 Reactor、Spring WebFlux 和 Netty，减少繁琐配置。\n- **统一技术栈**：与 Spring 生态（如 Spring Data R2DBC）无缝集成，适合端到端响应式系统。\n- **现代化架构支持**：适用于微服务、事件驱动系统和实时数据处理场景（如 WebSocket 或 SSE）。\n\n## 核心功能与使用方法\n\n### 1. 响应式控制器\n使用 `@RestController` 和 `Mono`/`Flux` 处理异步请求。\n\n### 2. 响应式数据流\n`Mono` 表示 0 或 1 个结果，`Flux` 表示 0 到多个结果，支持流式响应。\n\n### 3. WebClient 调用\n通过 `WebClient` 进行异步 HTTP 调用。\n\n### 4. 全局异常处理\n使用 `@RestControllerAdvice` 和 `@ExceptionHandler` 处理异步异常：\n\n```java\n@RestControllerAdvice\npublic class GlobalExceptionHandler {\n    @ExceptionHandler(IllegalArgumentException.class)\n    public Mono&lt;ResponseEntity&lt;String&gt;&gt; handleIllegalArgument(IllegalArgumentException ex) {\n        return Mono.just(ResponseEntity.badRequest().body(ex.getMessage()));\n    }\n}\n```\n\n## 版本与依赖管理\n\n版本由 `spring-boot-starter-parent` 统一管理，查看最新版本：[Maven 中央仓库](https://mvnrepository.com/search?q=spring-boot-starter-webflux).\n\n## 常用配置文件\n\n在 `application.yml` 中配置 WebFlux 相关行为：\n\n```yaml\nserver:\n  port: 8080\n  servlet:\n    context-path: /myapp\n  netty:\n    connection-timeout: 10s\nspring:\n  webflux:\n    static-path-pattern: /static/**\n  jackson:\n    date-format: yyyy-MM-dd HH:mm:ss\n    time-zone: GMT+8\n    property-naming-strategy: SNAKE_CASE\n  codec:\n    max-in-memory-size: 10MB\n```\n\n## 常用注解\n\n- `@RestController`：标记类为 REST 控制器，自动序列化返回值到 JSON。\n- `@RequestMapping`, `@GetMapping`, `@PostMapping`：定义 HTTP 请求路径和方法。\n- `@PathVariable`：从 URL 路径中提取变量。\n- `@RequestBody`：将请求体绑定到 Java 对象，通常与 `Mono` 或 `Flux` 结合。\n- `@CrossOrigin`：启用跨域支持。\n- `@RestControllerAdvice`：定义全局异常处理类。\n- `@ExceptionHandler`：处理特定异常，返回响应式结果。\n\n## 注意事项\n\n- **前置条件**：\n  - 项目需为 Spring Boot 项目，继承 `spring-boot-starter-parent` 或使用 `spring-boot-dependencies` BOM。\n  - 不需额外 Reactor 依赖，`spring-boot-starter-webflux` 已包含。\n- **Servlet 栈 vs. Reactive 栈**：基于响应式编程，与 `spring-boot-starter-web` 互斥，不应同时引入。\n- **更换内嵌服务器**：默认使用 Netty，可通过排除 `spring-boot-starter-reactor-netty` 并引入 `spring-boot-starter-undertow` 切换：\n\n    ```xml\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n        &lt;artifactId&gt;spring-boot-starter-webflux&lt;/artifactId&gt;\n        &lt;exclusions&gt;\n            &lt;exclusion&gt;\n                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n                &lt;artifactId&gt;spring-boot-starter-reactor-netty&lt;/artifactId&gt;\n            &lt;/exclusion&gt;\n        &lt;/exclusions&gt;\n    &lt;/dependency&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n        &lt;artifactId&gt;spring-boot-starter-undertow&lt;/artifactId&gt;\n    &lt;/dependency&gt;\n    ```\n\n- **特殊版本情况**：确保 Spring Boot 版本与 WebFlux 依赖兼容，查看 [Maven 中央仓库](https://mvnrepository.com/search?q=spring-boot-starter-webflux).\n\n## 常见问题排查\n\n### 1. 端口占用\n**问题**：启动报 `Port 8080 was already in use`。\n**原因**：8080 端口被占用。\n**解决**：设置 `server.port=8081` 或其他未占用端口。\n\n### 2. API 返回 404 Not Found\n**原因**：Spring WebFlux 未找到请求处理器。\n**排查**：\n- 确保 `@RestController` 和 `@RequestMapping` 正确配置。\n- 检查主类包扫描范围包含 Controller 包。\n- 确认请求 URL 和 HTTP 方法与注解定义一致。\n- 若设置了 `server.servlet.context-path`，确保 URL 包含上下文路径。\n\n### 3. JSON 数据绑定失败\n**问题**：返回 `400 Bad Request`。\n**原因**：JSON 格式错误或与 Java 对象不匹配。\n**排查**：\n- 确保方法参数使用 `@RequestBody` 和 `Mono`/`Flux`。\n- 检查请求头 `Content-Type` 是否为 `application/json`。\n- 验证 JSON 字段与 Java 类字段匹配。\n\n### 4. 跨域错误 (CORS)\n**问题**：浏览器报跨域错误。\n**原因**：浏览器阻止跨域请求。\n**解决**：\n- 在 Controller 上添加 `@CrossOrigin`。\n- 配置全局 CORS：\n\n    ```java\n    @Bean\n    public WebFluxConfigurer corsConfigurer() {\n        return new WebFluxConfigurer() {\n            @Override\n            public void addCorsMappings(CorsRegistry registry) {\n                registry.addMapping(&quot;/**&quot;).allowedOrigins(&quot;*&quot;).allowedMethods(&quot;*&quot;);\n            }\n        };\n    }\n    ```\n\n### 5. 响应式流未触发\n**问题**：数据丢失或流未触发。\n**原因**：未正确订阅 `Mono` 或 `Flux`。\n**解决**：确保控制器方法返回 `Mono` 或 `Flux`，WebFlux 会自动订阅。避免 `.block()` 调用。"
  },
  {
    "name": "spring-boot-starter-thymeleaf",
    "summary": "用于构建基于 Thymeleaf 模板引擎的 Web 应用，适合动态生成 HTML 页面，支持服务端渲染的 MVC 架构。是 Spring Boot 中用于快速开发传统 Web 页面的首选 Starter。",
    "notes": "# spring-boot-starter-thymeleaf\n\n## 示例\n\n### 添加依赖\n在 Maven 项目的 `pom.xml` 中添加 `spring-boot-starter-thymeleaf` 依赖，版本由 `spring-boot-starter-parent` 统一管理：\n\n```xml\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;\n&lt;/dependency&gt;\n```\n\n### 创建 Thymeleaf 模板\n模板文件位于 `src/main/resources/templates/hello.html`：\n\n```html\n&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;title&gt;Hello Thymeleaf&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;h1 th:text=&quot;${message}&quot;&gt;Default Message&lt;/h1&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n```\n\n### 创建 Controller\n返回 Thymeleaf 模板并传递数据：\n\n```java\n@Controller\npublic class HelloController {\n    @GetMapping(&quot;/hello&quot;)\n    public String hello(Model model) {\n        model.addAttribute(&quot;message&quot;, &quot;Welcome to Thymeleaf!&quot;);\n        return &quot;hello&quot;;\n    }\n}\n```\n\n## 解决的问题\n\n`spring-boot-starter-thymeleaf` 简化基于服务端渲染的 Web 应用开发，适合动态生成 HTML 页面：\n\n- **简化模板引擎配置**：自动配置 Thymeleaf 模板引擎，免手动配置 `TemplateResolver`、`ViewResolver`。\n- **快速开发动态页面**：通过 Thymeleaf 语法，支持条件判断、循环、国际化等。\n- **与 Spring MVC 集成**：与 `spring-boot-starter-web` 无缝集成，支持 `@Controller` 和模型绑定。\n- **支持现代化前端开发**：支持自然模板，允许前端开发者直接预览静态 HTML。\n- **国际化支持**：内置 i18n 支持，方便多语言页面开发。\n\n## 核心功能与使用方法\n\n### 1. 创建 Thymeleaf 模板\n模板默认位于 `src/main/resources/templates/`，后缀为 `.html`，需使用 `xmlns:th=&quot;http://www.thymeleaf.org&quot;` 启用 Thymeleaf 语法：\n\n```html\n&lt;p th:text=&quot;${user.name}&quot;&gt;Default Name&lt;/p&gt;\n```\n\n### 2. Controller 与模型绑定\n使用 `@Controller` 和 `@GetMapping`/`@PostMapping` 返回模板名称，通过 `Model` 传递数据：\n\n```java\n@Controller\npublic class UserController {\n    @GetMapping(&quot;/user&quot;)\n    public String showUser(Model model) {\n        model.addAttribute(&quot;user&quot;, new User(1L, &quot;John Doe&quot;));\n        return &quot;user&quot;;\n    }\n}\n```\n\n### 3. Thymeleaf 常用语法\n- **变量输出**：`th:text` 或 `th:utext` 显示模型数据（`th:utext` 不转义 HTML）。\n- **循环**：`th:each` 迭代集合：\n\n    ```html\n    &lt;li th:each=&quot;user : ${users}&quot; th:text=&quot;${user.name}&quot;&gt;Default Name&lt;/li&gt;\n    ```\n\n- **条件判断**：`th:if` 和 `th:unless` 用于条件渲染。\n- **表单绑定**：`th:object` 和 `th:field` 用于表单数据绑定，支持校验。\n- **国际化**：`#{key}` 从 `src/main/resources/messages.properties` 获取国际化文本。\n\n### 4. 静态资源管理\n静态资源默认位于 `src/main/resources/static/`，使用 `th:href` 或 `th:src` 引用：\n\n```html\n&lt;link th:href=&quot;@{/css/style.css}&quot; rel=&quot;stylesheet&quot;&gt;\n```\n\n### 5. 布局与复用\n使用 `th:fragment` 和 `th:replace` 创建可复用页面片段：\n\n```html\n&lt;!-- layout.html --&gt;\n&lt;div th:fragment=&quot;header&quot;&gt;\n    &lt;h1&gt;Common Header&lt;/h1&gt;\n&lt;/div&gt;\n\n&lt;!-- 使用 --&gt;\n&lt;div th:replace=&quot;~{layout :: header}&quot;&gt;&lt;/div&gt;\n```\n\n## 版本与依赖管理\n\n版本由 `spring-boot-starter-parent` 管理，查看最新版本：[Maven 中央仓库](https://mvnrepository.com/search?q=spring-boot-starter-thymeleaf).\n\n## 常用配置文件\n\n在 `application.yml` 中配置 Thymeleaf 行为：\n\n```yaml\nspring:\n  thymeleaf:\n    cache: false\n    prefix: classpath:/templates/\n    suffix: .html\n    mode: HTML\n    encoding: UTF-8\n    servlet:\n      content-type: text/html\n  web:\n    resources:\n      static-locations: classpath:/static/,classpath:/public/\n  messages:\n    basename: messages\n    encoding: UTF-8\n```\n\n## 注意事项\n\n- **前置条件**：需为 Spring Boot 项目，继承 `spring-boot-starter-parent` 或使用 `spring-boot-dependencies` BOM，需包含 `spring-boot-starter-web`。\n- **特殊版本情况**：若需支持非严格 HTML（如 LEGACYHTML5），需添加 `nekohtml` 依赖：\n\n    ```xml\n    &lt;dependency&gt;\n        &lt;groupId&gt;net.sourceforge.nekohtml&lt;/groupId&gt;\n        &lt;artifactId&gt;nekohtml&lt;/artifactId&gt;\n    &lt;/dependency&gt;\n    ```\n\n- **与 WebFlux 的兼容性**：基于 Servlet 栈，与 `spring-boot-starter-webflux` 不兼容。\n- **模板缓存**：开发时建议设置 `spring.thymeleaf.cache=false` 实时预览更改。\n\n## 常用注解\n\n- `@Controller`：标记类为 Spring MVC 控制器，返回模板。\n- `@GetMapping/@PostMapping`：定义 HTTP GET 或 POST 请求映射。\n- `@ModelAttribute`：绑定方法返回值或参数到模型：\n\n    ```java\n    @ModelAttribute(&quot;siteTitle&quot;)\n    public String siteTitle() {\n        return &quot;My Website&quot;;\n    }\n    ```\n\n- `@Valid`：结合 `spring-boot-starter-validation` 用于表单校验。\n- `@CrossOrigin`：处理跨域请求。\n\n## 常见问题排查\n\n### 1. 页面返回 404 Not Found\n**原因**：模板文件未找到或 Controller 配置错误。\n**排查**：\n- 确保模板位于 `src/main/resources/templates/`，文件名与 Controller 返回值一致（不含 `.html`）。\n- 检查是否误用 `@RestController`（返回 JSON）。\n- 确认主启动类包扫描覆盖 Controller 包。\n- 检查 `spring.thymeleaf.prefix` 是否正确。\n\n### 2. Thymeleaf 语法未生效\n**问题**：`th:text` 显示原始内容。\n**原因**：缺少 Thymeleaf 命名空间或模板未被处理。\n**排查**：\n- 确保 HTML 包含 `xmlns:th=&quot;http://www.thymeleaf.org&quot;`。\n- 确认 `spring-boot-starter-thymeleaf` 依赖已添加。\n- 检查模板文件是否在 `spring.thymeleaf.prefix` 路径下。\n\n### 3. 静态资源无法加载\n**原因**：路径配置错误或未使用 `th:href`/`th:src`。\n**排查**：\n- 确保资源位于 `src/main/resources/static/` 或 `spring.web.resources.static-locations` 路径。\n- 使用 `th:href=&quot;@{/path/to/resource}&quot;` 引用资源。\n- 检查浏览器开发者工具，确认资源请求状态。\n\n### 4. 国际化文本未生效\n**问题**：显示 `#{key}` 而非实际值。\n**原因**：国际化资源文件配置错误。\n**排查**：\n- 确保 `messages.properties` 位于 `src/main/resources/`，文件名与 `spring.messages.basename` 一致。\n- 检查资源文件中是否定义了对应 `key` 和值。\n- 确认 `spring.messages.encoding` 设置为 `UTF-8`。\n\n### 5. 表单校验错误未显示\n**原因**：表单未正确绑定或未处理校验结果。\n**排查**：\n- 确保表单使用 `th:object` 和 `th:field` 绑定模型。\n- 在 Controller 中使用 `@Valid` 和 `BindingResult`：\n\n    ```java\n    @PostMapping(&quot;/submit&quot;)\n    public String submitForm(@Valid @ModelAttribute UserForm form, BindingResult result, Model model) {\n        if (result.hasErrors()) {\n            return &quot;form&quot;;\n        }\n        return &quot;success&quot;;\n    }\n    ```\n\n- 在模板中使用 `th:errors` 显示错误：\n\n    ```html\n    &lt;div th:if=&quot;${#fields.hasErrors(&#x27;name&#x27;)}&quot; th:errors=&quot;*{name}&quot;&gt;Name Error&lt;/div&gt;\n    ```"
  },
  {
    "name": "spring-boot-starter-websocket",
    "summary": "用于构建基于 WebSocket 的实时、双向通信 Web 应用，支持 STOMP 协议，提供与客户端（如浏览器或 Java 客户端）的高效消息交互。",
    "notes": "# spring-boot-starter-websocket\n\n## 示例\n\n### 添加依赖\n在 Maven 项目的 `pom.xml` 中添加 `spring-boot-starter-websocket` 依赖，版本由 `spring-boot-starter-parent` 统一管理：\n\n```xml\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-websocket&lt;/artifactId&gt;\n&lt;/dependency&gt;\n```\n\n### 配置 WebSocket 和 STOMP\n启用 `/chat` 端点并支持 SockJS 回退：\n\n```java\npackage com.example.config;\n\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.messaging.simp.config.MessageBrokerRegistry;\nimport org.springframework.web.socket.config.annotation.EnableWebSocketMessageBroker;\nimport org.springframework.web.socket.config.annotation.StompEndpointRegistry;\nimport org.springframework.web.socket.config.annotation.WebSocketMessageBrokerConfigurer;\n\n@Configuration\n@EnableWebSocketMessageBroker\npublic class WebSocketConfig implements WebSocketMessageBrokerConfigurer {\n\n    @Override\n    public void configureMessageBroker(MessageBrokerRegistry config) {\n        config.enableSimpleBroker(&quot;/topic&quot;, &quot;/queue&quot;);\n        config.setApplicationDestinationPrefixes(&quot;/app&quot;);\n    }\n\n    @Override\n    public void registerStompEndpoints(StompEndpointRegistry registry) {\n        registry.addEndpoint(&quot;/chat&quot;).withSockJS();\n    }\n}\n```\n\n### 创建 STOMP 消息控制器\n处理 `/app/hello` 消息并广播到 `/topic/greetings`：\n\n```java\npackage com.example.controller;\n\nimport org.springframework.messaging.handler.annotation.MessageMapping;\nimport org.springframework.messaging.handler.annotation.SendTo;\nimport org.springframework.stereotype.Controller;\n\nclass HelloMessage {\n    private String name;\n    public String getName() { return name; }\n    public void setName(String name) { this.name = name; }\n}\n\n@Controller\npublic class GreetingController {\n\n    @MessageMapping(&quot;/hello&quot;)\n    @SendTo(&quot;/topic/greetings&quot;)\n    public String greet(HelloMessage message) throws Exception {\n        Thread.sleep(1000); // 模拟延迟\n        return &quot;Hello, &quot; + message.getName() + &quot;!&quot;;\n    }\n}\n```\n\n### 前端 JavaScript 客户端\n使用 SockJS 和 STOMP 协议连接 WebSocket 端点：\n\n```html\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n    &lt;title&gt;WebSocket Chat&lt;/title&gt;\n    &lt;script src=&quot;https://cdn.jsdelivr.net/npm/sockjs-client@1/dist/sockjs.min.js&quot;&gt;&lt;/script&gt;\n    &lt;script src=&quot;https://cdn.jsdelivr.net/npm/@stomp/stompjs@6/bundles/stomp.umd.min.js&quot;&gt;&lt;/script&gt;\n    &lt;script&gt;\n        var stompClient = null;\n\n        function connect() {\n            var socket = new SockJS(&#x27;/chat&#x27;);\n            stompClient = Stomp.over(socket);\n            stompClient.connect({}, function(frame) {\n                console.log(&#x27;Connected: &#x27; + frame);\n                stompClient.subscribe(&#x27;/topic/greetings&#x27;, function(message) {\n                    alert(message.body);\n                });\n            });\n        }\n\n        function sendMessage() {\n            var name = document.getElementById(&#x27;name&#x27;).value;\n            stompClient.send(&#x27;/app/hello&#x27;, {}, JSON.stringify({&#x27;name&#x27;: name}));\n        }\n    &lt;/script&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;input id=&quot;name&quot; type=&quot;text&quot; placeholder=&quot;Your name&quot; /&gt;\n    &lt;button onclick=&quot;connect()&quot;&gt;Connect&lt;/button&gt;\n    &lt;button onclick=&quot;sendMessage()&quot;&gt;Send&lt;/button&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n```\n\n## 解决的问题\n\n`spring-boot-starter-websocket` 简化基于 WebSocket 的实时、双向通信应用开发，解决以下问题：\n\n- **实时双向通信**：提供持久连接，允许服务器主动推送消息，适合聊天、实时通知等场景。\n- **简化配置**：自动引入 Spring WebSocket、Spring Messaging 和 SockJS，免手动配置复杂协议。\n- **跨协议支持**：支持 STOMP 协议，简化消息路由和处理。\n- **回退机制**：通过 SockJS 提供浏览器兼容性，支持不完全支持 WebSocket 的环境。\n- **生产环境准备**：支持 Spring Security 集成和外部消息代理（如 RabbitMQ、ActiveMQ）。\n\n## 核心功能与使用方法\n\n### 1. 启用 WebSocket 和 STOMP\n通过 `@EnableWebSocketMessageBroker` 启用支持，配置消息代理和端点。\n\n### 2. 消息处理\n使用 `@MessageMapping` 处理客户端发送的 STOMP 消息，通过 `@SendTo` 或 `SimpMessagingTemplate` 广播或发送消息。\n\n### 3. 客户端支持\n支持 JavaScript（SockJS + STOMP）、Java 或其他语言客户端，通过 WebSocket 协议交互。\n\n### 4. 用户特定消息\n通过 `/user/{username}/queue/*` 格式支持向特定用户发送消息。\n\n### 5. SockJS 回退\n当 WebSocket 不可用时，自动回退到 HTTP 长轮询或流式传输。\n\n**使用步骤**：\n1. 添加 `spring-boot-starter-websocket` 依赖。\n2. 配置 `WebSocketMessageBrokerConfigurer` 类，定义消息代理和 STOMP 端点。\n3. 使用 `@MessageMapping` 处理消息，结合 `@SendTo` 或 `SimpMessagingTemplate` 响应。\n4. 开发客户端，连接 WebSocket 端点，订阅消息目标并发送消息。\n\n## 版本与依赖管理\n\n版本由 `spring-boot-starter-parent` 管理，查看最新版本：[Maven 中央仓库](https://mvnrepository.com/search?q=spring-boot-starter-websocket).\n\n### 推荐依赖\n- **JSON 处理**：\n\n    ```xml\n    &lt;dependency&gt;\n        &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;\n        &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;\n    &lt;/dependency&gt;\n    ```\n\n- **安全功能**：\n\n    ```xml\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n        &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;\n    &lt;/dependency&gt;\n    ```\n\n## 常用配置文件\n\n在 `application.yml` 中配置 WebSocket 相关行为：\n\n```yaml\nspring:\n  jackson:\n    date-format: yyyy-MM-dd HH:mm:ss\n    time-zone: GMT+8\n    property-naming-strategy: SNAKE_CASE\nserver:\n  port: 8080\n  servlet:\n    context-path: /myapp\nspring:\n  rabbitmq:\n    host: localhost\n    port: 5672\n    username: guest\n    password: guest\n  websocket:\n    message-broker:\n      enabled: true\n      stomp:\n        relay-host: localhost\n        relay-port: 61613\n        client-login: guest\n        client-passcode: guest\n```\n\n## 注意事项\n\n- **前置条件**：\n  - 项目需为 Spring Boot 项目，继承 `spring-boot-starter-parent` 或使用 `spring-boot-dependencies` BOM。\n  - STOMP 和 JSON 消息需确保 Jackson 依赖存在。\n  - 用户认证需引入 `spring-boot-starter-security`。\n- **特殊版本情况**：\n  - **Spring Boot 1.x vs. 2.x**：2.x 使用 `WebSocketMessageBrokerConfigurer` 替代 1.x 的 `AbstractWebSocketMessageBrokerConfigurer`。\n  - **SockJS 版本**：确保客户端 SockJS 和 STOMP 库版本与服务器端兼容。\n  - **外部消息代理**：高并发场景推荐使用 RabbitMQ 或 ActiveMQ。\n- **CORS 配置**：SockJS 默认只允许同源请求，需配置 `setAllowedOrigins` 或 `@CrossOrigin` 支持跨域。\n- **生产环境**：\n  - 默认内存消息代理不适合高并发，推荐使用 RabbitMQ 或 ActiveMQ。\n  - 确保 WebSocket 服务器支持协议，若使用 Nginx，需配置 WebSocket 升级请求。\n\n## 常用注解\n\n- `@EnableWebSocketMessageBroker`：启用 WebSocket 和 STOMP 消息代理。\n- `@MessageMapping`：映射 STOMP 消息目标（如 `/app/hello`）。\n- `@SendTo`：指定广播消息目标（如 `/topic/greetings`）。\n- `@SendToUser`：发送到特定用户队列。\n- `@CrossOrigin`：允许跨域请求。\n- `@Payload`：标记 STOMP 消息有效负载。\n\n## 常见问题排查\n\n### 1. 客户端无法连接\n**问题**：报 404 或连接超时。\n**原因**：端点配置错误或服务器未处理 WebSocket 升级请求。\n**排查**：\n- 确保 `WebSocketConfig` 中注册了正确端点（如 `/chat`）。\n- 检查 `server.servlet.context-path`，确保客户端 URL 包含上下文路径。\n- 若使用 Nginx，检查是否配置了 WebSocket 升级头。\n**解决**：\n- 验证端点路径，客户端连接 `ws://host:port/context-path/endpoint`。\n- 为 Nginx 添加配置：\n\n    ```nginx\n    proxy_set_header Upgrade $http_upgrade;\n    proxy_set_header Connection &quot;upgrade&quot;;\n    ```\n\n### 2. 客户端接收不到消息\n**原因**：订阅路径错误或服务器未广播消息。\n**排查**：\n- 确保客户端订阅路径（如 `/topic/greetings`）与 `@SendTo` 一致。\n- 检查控制器方法是否正确返回消息。\n- 使用浏览器开发者工具检查 WebSocket 帧。\n**解决**：\n- 确保订阅路径正确，必要时打印服务器日志。\n- 若使用 `@SendToUser`，确保订阅 `/user/{username}/queue/*`。\n\n### 3. 跨域请求被拒绝\n**问题**：CORS 错误。\n**原因**：SockJS 默认只允许同源请求。\n**解决**：\n- 配置允许的源：\n\n    ```java\n    registry.addEndpoint(&quot;/chat&quot;).setAllowedOrigins(&quot;*&quot;);\n    ```\n\n- 或在控制器上添加 `@CrossOrigin`。\n\n### 4. JSON 消息解析失败\n**问题**：参数为 null 或报 400 错误。\n**原因**：JSON 结构与 POJO 不匹配，或缺少 `Content-Type`。\n**排查**：\n- 确保客户端 JSON 字段与服务器 POJO 一致。\n- 检查请求是否设置 `Content-Type: application/json`。\n**解决**：\n- 在客户端设置 `Content-Type: application/json`。\n- 使用调试工具验证 JSON 格式。\n\n### 5. 高并发下消息丢失\n**原因**：默认内存消息代理不适合生产环境。\n**解决**：\n- 切换到 RabbitMQ：\n\n    ```xml\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n        &lt;artifactId&gt;spring-boot-starter-rabbit&lt;/artifactId&gt;\n    &lt;/dependency&gt;\n    ```\n\n- 配置外部代理：\n\n    ```java\n    config.enableStompBrokerRelay(&quot;/topic&quot;, &quot;/queue&quot;).setRelayHost(&quot;localhost&quot;).setRelayPort(61613);\n    ```\n\n### 6. Spring Security 认证失败\n**原因**：WebSocket 端点需要认证，客户端未提供有效凭据。\n**解决**：\n- 配置 Spring Security 允许未认证用户访问端点。\n- 确保客户端提供正确认证信息（如 JWT 或 Cookie）。\n\n## 参考资料\n\n- [Spring 官方文档：WebSocket Support](https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#websocket)\n- [Baeldung 教程：Intro to WebSockets with Spring](https://www.baeldung.com/websockets-spring)\n- [Maven 中央仓库](https://mvnrepository.com/search?q=spring-boot-starter-websocket)"
  },
  {
    "name": "spring-boot-starter-hateoas",
    "summary": "用于构建符合 HATEOAS（Hypermedia as the Engine of Application State）原则的 RESTful Web 应用，简化超媒体链接的创建和管理，提升 API 的可发现性和导航性。",
    "notes": "# spring-boot-starter-hateoas\n\n## 示例\n\n### 添加依赖\n在 Maven 项目的 `pom.xml` 中添加 `spring-boot-starter-hateoas` 依赖，版本由 `spring-boot-starter-parent` 统一管理：\n\n```xml\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-hateoas&lt;/artifactId&gt;\n&lt;/dependency&gt;\n```\n\n### 创建 REST 控制器\n添加 HATEOAS 链接到资源返回：\n\n```java\nimport org.springframework.hateoas.EntityModel;\nimport org.springframework.hateoas.Link;\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.PathVariable;\nimport org.springframework.web.bind.annotation.RestController;\n\nimport static org.springframework.hateoas.server.mvc.WebMvcLinkBuilder.*;\n\n@RestController\npublic class UserController {\n\n    @GetMapping(&quot;/users/{id}&quot;)\n    public EntityModel&lt;User&gt; getUserById(@PathVariable Long id) {\n        User user = new User(id, &quot;John Doe&quot;);\n        EntityModel&lt;User&gt; resource = EntityModel.of(user);\n        resource.add(linkTo(methodOn(UserController.class).getUserById(id)).withSelfRel());\n        resource.add(linkTo(methodOn(UserController.class).getAllUsers()).withRel(&quot;all-users&quot;));\n        return resource;\n    }\n\n    @GetMapping(&quot;/users&quot;)\n    public CollectionModel&lt;User&gt; getAllUsers() {\n        List&lt;User&gt; users = Arrays.asList(new User(1L, &quot;John Doe&quot;), new User(2L, &quot;Jane Doe&quot;));\n        return CollectionModel.of(users,\n                linkTo(methodOn(UserController.class).getAllUsers()).withSelfRel());\n    }\n}\n\nclass User {\n    private Long id;\n    private String name;\n\n    public User(Long id, String name) {\n        this.id = id;\n        this.name = name;\n    }\n\n    // Getters and Setters\n}\n```\n\n## 解决的问题\n\n`spring-boot-starter-hateoas` 帮助构建符合 HATEOAS 原则的 RESTful API，提升 API 可发现性和导航性，解决以下问题：\n\n- **API 可发现性**：通过超媒体链接引导客户端导航，减少硬编码 URL。\n- **简化链接管理**：提供工具（如 `WebMvcLinkBuilder`）简化链接创建。\n- **增强客户端体验**：客户端可通过链接动态发现可用操作。\n- **与 Spring 集成**：无缝集成 Spring MVC 或 WebFlux。\n\n## 核心功能与使用方法\n\n### 1. 创建资源模型\n使用 `EntityModel` 和 `CollectionModel` 封装资源并添加链接：\n\n- `EntityModel`：单个资源，添加 `self` 和相关链接。\n- `CollectionModel`：资源集合，添加集合级链接。\n\n### 2. 动态链接生成\n使用 `WebMvcLinkBuilder` 的 `linkTo` 和 `methodOn` 动态生成链接：\n\n```java\nlinkTo(methodOn(UserController.class).getUserById(id)).withSelfRel()\n```\n\n### 3. 支持 HAL 格式\n默认返回 HAL（Hypertext Application Language）格式的 JSON，包含 `_links` 字段。\n\n### 4. 集成 Spring MVC/WebFlux\n与 `spring-boot-starter-web` 或 `spring-boot-starter-webflux` 配合，提供 RESTful API。\n\n**使用步骤**：\n1. 添加 `spring-boot-starter-hateoas` 依赖。\n2. 在控制器中使用 `EntityModel` 或 `CollectionModel` 封装资源。\n3. 使用 `WebMvcLinkBuilder` 添加超媒体链接。\n4. 返回资源，客户端通过链接导航 API。\n\n## 版本与依赖管理\n\n版本由 `spring-boot-starter-parent` 管理，查看最新版本：[Maven 中央仓库](https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-hateoas).\n\n## 常用配置文件\n\n在 `application.yml` 中配置 HATEOAS 相关行为（通常无需额外配置）：\n\n```yaml\nspring:\n  jackson:\n    serialization:\n      WRITE_DATES_AS_TIMESTAMPS: false\n    property-naming-strategy: SNAKE_CASE\n```\n\n## 注意事项\n\n- **前置条件**：需为 Spring Boot 项目，继承 `spring-boot-starter-parent` 或使用 `spring-boot-dependencies` BOM。\n- **依赖 Web**：需配合 `spring-boot-starter-web` 或 `spring-boot-starter-webflux`。\n- **HAL 格式**：客户端需支持 HAL JSON 格式解析 `_links`。\n- **Spring Boot 3.x**：使用 Jakarta EE，需确保依赖兼容。\n\n## 常用注解\n\n- `@RestController`：定义 REST 控制器。\n- `@GetMapping`, `@PostMapping`：定义 HTTP 请求映射。\n- `@EnableHypermediaSupport`：启用 HATEOAS 支持（Spring Boot 自动配置通常无需此注解）。\n\n## 常见问题排查\n\n### 1. 链接未生成\n**问题**：响应中缺少 `_links` 字段。\n**原因**：未正确使用 `EntityModel` 或 `CollectionModel`。\n**排查**：\n- 确保控制器返回 `EntityModel` 或 `CollectionModel`。\n- 检查是否正确使用 `linkTo` 和 `methodOn`。\n**解决**：\n- 使用 `EntityModel.of()` 封装资源并添加链接。\n\n### 2. JSON 格式不正确\n**问题**：客户端无法解析 HAL 格式。\n**原因**：客户端不支持 HAL 或 JSON 配置错误。\n**排查**：\n- 确保响应头 `Content-Type: application/hal+json`。\n- 检查 `spring.jackson` 配置是否正确。\n**解决**：\n- 配置 `spring.jackson.property-naming-strategy` 确保字段名一致。\n- 指导客户端使用 HAL 解析库（如 Spring HATEOAS 客户端）。\n\n### 3. 跨域问题\n**问题**：浏览器报 CORS 错误。\n**原因**：跨域请求被阻止。\n**解决**：\n- 添加 `@CrossOrigin` 到控制器。\n- 配置全局 CORS：\n\n    ```java\n    @Configuration\n    public class WebConfig implements WebMvcConfigurer {\n        @Override\n        public void addCorsMappings(CorsRegistry registry) {\n            registry.addMapping(&quot;/**&quot;).allowedOrigins(&quot;*&quot;).allowedMethods(&quot;*&quot;);\n        }\n    }\n    ```\n\n### 4. 依赖冲突\n**问题**：启动失败。\n**原因**：HATEOAS 依赖与 Spring Boot 版本不兼容。\n**解决**：\n- 使用 `spring-boot-starter-parent` 管理版本。\n- 运行 `mvn dependency:tree` 检查并排除冲突依赖。"
  },
  {
    "name": "spring-boot-starter-mustache",
    "summary": "集成 Mustache 模板引擎，用于服务端渲染简单逻辑的 HTML 页面，适合轻量级、无逻辑模板的场景。",
    "notes": "# spring-boot-starter-mustache\n\n## 示例\n\n### 添加依赖\n在 Maven 项目的 `pom.xml` 中添加 `spring-boot-starter-mustache` 依赖：\n\n```xml\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-mustache&lt;/artifactId&gt;\n&lt;/dependency&gt;\n```\n\n### 创建 Mustache 模板\n模板文件位于 `src/main/resources/templates/hello.mustache`：\n\n```html\n&lt;h1&gt;{{message}}&lt;/h1&gt;\n```\n\n### 创建 Controller\n返回 Mustache 模板并传递数据：\n\n```java\n@Controller\npublic class HelloController {\n    @GetMapping(&quot;/hello&quot;)\n    public String hello(Model model) {\n        model.addAttribute(&quot;message&quot;, &quot;Welcome to Mustache!&quot;);\n        return &quot;hello&quot;;\n    }\n}\n```\n\n## 解决的问题\n\n`spring-boot-starter-mustache` 提供轻量级模板引擎，解决以下问题：\n\n- **简单模板渲染**：适合逻辑简单的页面渲染。\n- **自动化配置**：自动配置 Mustache 模板解析器。\n- **跨平台支持**：Mustache 支持多种语言，适合前后端共享模板。\n\n## 核心功能与使用方法\n\n### 1. 创建模板\n模板文件位于 `src/main/resources/templates/`，后缀为 `.mustache`。\n\n### 2. 模型绑定\n通过 `Model` 传递数据到模板。\n\n### 3. 逻辑无关\n支持基本变量替换和循环，无复杂逻辑。\n\n## 版本与依赖管理\n\n版本由 `spring-boot-starter-parent` 管理，查看最新版本：[Maven 中央仓库](https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-mustache).\n\n## 常用配置文件\n\n在 `application.yml` 中配置 Mustache 行为：\n\n```yaml\nspring:\n  mustache:\n    suffix: .mustache\n    prefix: classpath:/templates/\n    cache: false\n```\n\n## 注意事项\n\n- **逻辑限制**：Mustache 不支持复杂逻辑，适合简单场景。\n- **依赖 Web**：需配合 `spring-boot-starter-web`。\n\n## 常用注解\n\n- `@Controller`：返回 Mustache 模板。\n- `@GetMapping`：定义请求路径。\n\n## 常见问题排查\n\n### 1. 模板未渲染\n**问题**：页面未显示模板内容。\n**原因**：文件路径错误。\n**排查**：\n- 检查 `spring.mustache.prefix` 和模板文件名。\n- 确保模板位于 `src/main/resources/templates/`。\n**解决**：\n- 修正 `spring.mustache.prefix` 或模板路径。\n\n### 2. 变量未替换\n**问题**：模板变量显示为原始值。\n**原因**：模型数据未传递。\n**排查**：\n- 确保 Controller 使用 `Model` 添加数据。\n- 检查模板中变量名是否与模型属性一致。\n**解决**：\n- 在 Controller 中使用 `model.addAttribute` 添加数据。"
  },
  {
    "name": "spring-boot-starter-actuator",
    "summary": "提供生产环境监控和管理功能，暴露健康检查、指标、日志等端点，便于实时监控 Spring Boot 应用状态。",
    "notes": "# spring-boot-starter-actuator\n\n## 示例\n\n### 添加依赖\n在 Maven 项目的 `pom.xml` 中添加 `spring-boot-starter-actuator` 依赖，版本由 `spring-boot-starter-parent` 统一管理：\n\n```xml\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;\n&lt;/dependency&gt;\n```\n\n### 访问端点\n通过 HTTP 访问默认端点，如健康检查：\n\n```bash\ncurl http://localhost:8080/actuator/health\n```\n\n**响应示例**：\n\n```json\n{\n  &quot;status&quot;: &quot;UP&quot;\n}\n```\n\n### 自定义端点\n创建一个自定义健康检查端点：\n\n```java\n@Component\npublic class CustomHealthIndicator implements HealthIndicator {\n    @Override\n    public Health health() {\n        boolean isHealthy = checkSomeService();\n        if (isHealthy) {\n            return Health.up().withDetail(&quot;service&quot;, &quot;available&quot;).build();\n        }\n        return Health.down().withDetail(&quot;service&quot;, &quot;unavailable&quot;).build();\n    }\n\n    private boolean checkSomeService() {\n        // 模拟服务检查逻辑\n        return true;\n    }\n}\n```\n\n## 解决的问题\n\n`spring-boot-starter-actuator` 提供生产就绪功能，解决以下问题：\n\n- **应用监控**：提供健康检查、指标和环境信息，便于监控应用状态。\n- **简化运维**：通过 HTTP 或 JMX 暴露端点，集成监控工具（如 Prometheus、Grafana）。\n- **自动化配置**：默认启用常用端点，减少手动配置。\n- **安全性**：与 Spring Security 集成，保护敏感端点。\n- **可扩展性**：支持自定义端点和指标。\n\n## 核心功能与使用方法\n\n### 1. 默认端点\n常用端点包括：\n\n- `/actuator/health`：显示应用健康状态。\n- `/actuator/info`：显示应用信息（如版本、描述）。\n- `/actuator/metrics`：查看 JVM、CPU、内存等指标。\n- `/actuator/env`：查看环境变量和配置属性。\n- `/actuator/loggers`：动态查看和修改日志级别。\n\n### 2. 启用/禁用端点\n通过配置启用或禁用特定端点：\n\n```yaml\nmanagement:\n  endpoints:\n    web:\n      exposure:\n        include: &quot;health,info,metrics&quot;\n        exclude: &quot;env,beans&quot;\n```\n\n### 3. 自定义端点\n通过实现 `HealthIndicator` 或 `@Endpoint` 创建自定义端点：\n\n```java\n@Endpoint(id = &quot;custom&quot;)\n@Component\npublic class CustomEndpoint {\n    @ReadOperation\n    public String custom() {\n        return &quot;Custom Endpoint Response&quot;;\n    }\n}\n```\n\n### 4. 与监控工具集成\n使用 Micrometer 导出指标到 Prometheus：\n\n```xml\n&lt;dependency&gt;\n    &lt;groupId&gt;io.micrometer&lt;/groupId&gt;\n    &lt;artifactId&gt;micrometer-registry-prometheus&lt;/artifactId&gt;\n&lt;/dependency&gt;\n```\n\n配置 Prometheus 端点：\n\n```yaml\nmanagement:\n  metrics:\n    export:\n      prometheus:\n        enabled: true\n```\n\n### 5. 安全性\n限制端点访问需引入 `spring-boot-starter-security`：\n\n```java\n@Configuration\npublic class SecurityConfig {\n    @Bean\n    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {\n        http.authorizeHttpRequests()\n            .requestMatchers(&quot;/actuator/**&quot;).hasRole(&quot;ADMIN&quot;)\n            .and().httpBasic();\n        return http.build();\n    }\n}\n```\n\n## 版本与依赖管理\n\n版本由 `spring-boot-starter-parent` 管理，查看最新版本：[Maven 中央仓库](https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-actuator).\n\n## 常用配置文件\n\n在 `application.yml` 中配置 Actuator 行为：\n\n```yaml\nmanagement:\n  endpoints:\n    web:\n      base-path: /actuator\n      exposure:\n        include: &quot;*&quot;\n  endpoint:\n    health:\n      show-details: always\n    info:\n      enabled: true\n  server:\n    port: 8081\nspring:\n  security:\n    user:\n      name: admin\n      password: admin\n```\n\n### 配置说明\n\n- `management.endpoints.web.base-path`：自定义端点路径。\n- `management.endpoints.web.exposure.include`：启用端点列表。\n- `management.endpoint.health.show-details`：显示健康检查详细信息。\n- `management.server.port`：设置管理端口（独立于主应用端口）。\n\n## 注意事项\n\n- **前置条件**：需为 Spring Boot 项目，继承 `spring-boot-starter-parent` 或使用 `spring-boot-dependencies` BOM。\n- **安全性**：敏感端点（如 `/actuator/env`）应限制访问。\n- **Spring Boot 3.x**：使用 Jakarta EE，需确保依赖兼容。\n- **性能影响**：启用过多端点可能影响性能，建议按需启用。\n\n## 常用注解\n\n- `@Endpoint`：定义自定义端点。\n- `@ReadOperation`, `@WriteOperation`, `@DeleteOperation`：定义端点操作。\n- `@HealthIndicator`：实现健康检查逻辑。\n\n## 常见问题排查\n\n### 1. 端点无法访问\n**问题**：访问 `/actuator/*` 返回 404。\n**原因**：端点未启用或路径错误。\n**排查**：\n- 确保 `spring-boot-starter-actuator` 依赖已添加。\n- 检查 `management.endpoints.web.exposure.include` 是否包含目标端点。\n- 验证 `management.endpoints.web.base-path` 是否正确。\n**解决**：\n- 设置 `management.endpoints.web.exposure.include: &quot;*&quot;` 启用所有端点。\n\n### 2. 健康检查显示 DOWN\n**问题**：`/actuator/health` 返回 `DOWN`。\n**原因**：依赖服务（如数据库）不可用。\n**排查**：\n- 检查 `HealthIndicator` 日志，定位失败组件。\n- 确保相关服务正常运行。\n**解决**：\n- 修复依赖服务或禁用相关健康检查。\n\n### 3. 权限问题\n**问题**：访问端点返回 403 Forbidden。\n**原因**：未配置认证或权限不足。\n**解决**：\n- 添加 `spring-boot-starter-security` 并配置权限：\n\n    ```java\n    http.authorizeHttpRequests().requestMatchers(&quot;/actuator/**&quot;).authenticated();\n    ```\n\n### 4. 指标未导出\n**问题**：Prometheus 无法获取指标。\n**原因**：Micrometer 配置错误。\n**排查**：\n- 确保 `micrometer-registry-prometheus` 依赖已添加。\n- 检查 `management.metrics.export.prometheus.enabled` 是否为 `true`。\n**解决**：\n- 验证 Prometheus 配置文件，正确指向 `/actuator/prometheus`。\n\n## 参考资料\n\n- [Spring 官方文档：Actuator](https://docs.spring.io/spring-boot/docs/current/reference/html/actuator.html)\n- [Baeldung 教程：Spring Boot Actuator](https://www.baeldung.com/spring-boot-actuators)"
  },
  {
    "name": "spring-boot-starter-oauth2-client",
    "summary": "简化 OAuth2/OpenID Connect 客户端集成，支持通过 Spring Security 实现单点登录（SSO）和访问受保护资源。",
    "notes": "# spring-boot-starter-oauth2-client\n\n## 示例\n\n### 添加依赖\n在 Maven 项目的 `pom.xml` 中添加 `spring-boot-starter-oauth2-client` 依赖：\n\n```xml\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-oauth2-client&lt;/artifactId&gt;\n&lt;/dependency&gt;\n```\n\n### 配置 OAuth2 客户端\n在 `application.yml` 中配置 OAuth2 客户端（如 Google）：\n\n```yaml\nspring:\n  security:\n    oauth2:\n      client:\n        registration:\n          google:\n            client-id: your-client-id\n            client-secret: your-client-secret\n            scope: openid,profile,email\n        provider:\n          google:\n            authorization-uri: https://accounts.google.com/o/oauth2/auth\n            token-uri: https://oauth2.googleapis.com/token\n            user-info-uri: https://www.googleapis.com/oauth2/v3/userinfo\n            user-name-attribute: name\n```\n\n### 创建受保护控制器\n访问需要登录的资源：\n\n```java\n@RestController\npublic class UserController {\n    @GetMapping(&quot;/user&quot;)\n    public String user(Principal principal) {\n        return &quot;Hello, &quot; + principal.getName();\n    }\n}\n```\n\n### 使用 OAuth2AuthorizedClient\n调用受保护的外部 API：\n\n```java\n@RestController\npublic class ExternalApiController {\n    @Autowired\n    private OAuth2AuthorizedClientService clientService;\n\n    @GetMapping(&quot;/external&quot;)\n    public String callExternalApi(@AuthenticationPrincipal OAuth2User user, OAuth2AuthenticationToken token) {\n        OAuth2AuthorizedClient client = clientService.loadAuthorizedClient(\n                token.getAuthorizedClientRegistrationId(), user.getName());\n        // 使用 client.getAccessToken() 调用外部 API\n        return &quot;Access token: &quot; + client.getAccessToken().getTokenValue();\n    }\n}\n```\n\n## 解决的问题\n\n`spring-boot-starter-oauth2-client` 简化 OAuth2 客户端集成，解决以下问题：\n\n- **单点登录（SSO）**：支持通过 Google、Okta 等提供商实现 SSO。\n- **访问受保护资源**：通过访问令牌调用外部 API。\n- **自动化配置**：自动配置 OAuth2 客户端和 Spring Security。\n- **用户认证**：获取用户身份信息（如用户名、邮箱）。\n\n## 核心功能与使用方法\n\n### 1. 配置 OAuth2 客户端\n通过 `application.yml` 配置客户端 ID、密钥和提供商信息。\n\n### 2. 单点登录\n用户访问受保护资源时，自动跳转到授权服务器登录。\n\n### 3. 访问令牌管理\n通过 `OAuth2AuthorizedClientService` 获取和管理访问令牌。\n\n### 4. 用户信息\n通过 `@AuthenticationPrincipal OAuth2User` 获取用户信息。\n\n**使用步骤**：\n1. 添加 `spring-boot-starter-oauth2-client` 依赖。\n2. 配置 OAuth2 客户端和提供商信息。\n3. 创建受保护的控制器或调用外部 API。\n\n## 版本与依赖管理\n\n版本由 `spring-boot-starter-parent` 管理，查看最新版本：[Maven 中央仓库](https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-oauth2-client).\n\n## 常用配置文件\n\n在 `application.yml` 中配置 OAuth2 客户端：\n\n```yaml\nspring:\n  security:\n    oauth2:\n      client:\n        registration:\n          custom:\n            client-id: your-client-id\n            client-secret: your-client-secret\n            authorization-grant-type: authorization_code\n            redirect-uri: &quot;{baseUrl}/login/oauth2/code/{registrationId}&quot;\n            scope: read,write\n        provider:\n          custom:\n            authorization-uri: https://provider.com/oauth2/authorize\n            token-uri: https://provider.com/oauth2/token\n            user-info-uri: https://provider.com/userinfo\n            user-name-attribute: sub\n```\n\n## 注意事项\n\n- **前置条件**：需包含 `spring-boot-starter-security`。\n- **提供商支持**：支持常见提供商（如 Google、Okta），或自定义提供商。\n- **Spring Boot 3.x**：使用 Jakarta EE，需确保依赖兼容。\n\n## 常用注解\n\n- `@AuthenticationPrincipal`：获取认证用户详细信息。\n- `@EnableWebSecurity`：启用 Spring Security 配置。\n\n## 常见问题排查\n\n### 1. 登录跳转失败\n**问题**：重定向到授权服务器失败。\n**原因**：客户端配置错误。\n**排查**：\n- 检查 `client-id` 和 `client-secret` 是否正确。\n- 确保 `redirect-uri` 与授权服务器配置一致。\n**解决**：\n- 修正 `application.yml` 中的配置。\n\n### 2. 访问令牌无效\n**问题**：调用外部 API 返回 401。\n**原因**：令牌过期或作用域错误。\n**排查**：\n- 检查 `scope` 是否包含所需权限。\n- 验证令牌有效期。\n**解决**：\n- 配置刷新令牌支持：\n\n    ```yaml\n    spring.security.oauth2.client.registration.custom.scope: openid,profile,refresh_token\n    ```\n\n### 3. 用户信息为空\n**问题**：`OAuth2User` 属性缺失。\n**原因**：`user-name-attribute` 配置错误。\n**排查**：\n- 检查 `user-info-uri` 和 `user-name-attribute` 是否匹配提供商返回的字段。\n**解决**：\n- 修正提供商配置，确保字段名一致。\n\n## 参考资料\n\n- [Spring 官方文档：OAuth2 Client](https://docs.spring.io/spring-security/site/docs/current/reference/html5/#oauth2client)\n- [Baeldung 教程：Spring Security OAuth2](https://www.baeldung.com/spring-security-oauth)"
  },
  {
    "name": "spring-boot-starter-oauth2-resource-server",
    "summary": "用于构建 OAuth2 资源服务器，保护 REST API，通过验证 JWT 或不透明令牌确保请求安全。",
    "notes": "# spring-boot-starter-oauth2-resource-server\n\n## 示例\n\n### 添加依赖\n在 Maven 项目的 `pom.xml` 中添加 `spring-boot-starter-oauth2-resource-server` 依赖：\n\n```xml\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-oauth2-resource-server&lt;/artifactId&gt;\n&lt;/dependency&gt;\n```\n\n### 配置资源服务器\n在 `application.yml` 中配置 JWT 发行者：\n\n```yaml\nspring:\n  security:\n    oauth2:\n      resourceserver:\n        jwt:\n          issuer-uri: https://auth-server.com\n          jwk-set-uri: https://auth-server.com/.well-known/jwks.json\n```\n\n### 创建受保护 API\n定义需要 JWT 认证的 REST 端点：\n\n```java\n@RestController\npublic class ResourceController {\n    @GetMapping(&quot;/api/resource&quot;)\n    public String getResource(@AuthenticationPrincipal Jwt jwt) {\n        return &quot;Protected resource, user: &quot; + jwt.getSubject();\n    }\n}\n```\n\n### 配置 Spring Security\n启用资源服务器并保护端点：\n\n```java\n@Configuration\n@EnableWebSecurity\npublic class SecurityConfig {\n    @Bean\n    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {\n        http.authorizeHttpRequests()\n            .requestMatchers(&quot;/api/**&quot;).authenticated()\n            .and()\n            .oauth2ResourceServer()\n            .jwt();\n        return http.build();\n    }\n}\n```\n\n## 解决的问题\n\n`spring-boot-starter-oauth2-resource-server` 简化资源服务器开发，解决以下问题：\n\n- **API 安全**：通过 JWT 或不透明令牌验证请求。\n- **自动化配置**：自动配置 JWT 解码和验证。\n- **与 Spring Security 集成**：支持基于角色的访问控制。\n\n## 核心功能与使用方法\n\n### 1. JWT 验证\n自动验证 JWT 签名、发行者和有效期。\n\n### 2. 角色/权限控制\n通过 `@PreAuthorize` 或 Security 配置限制访问：\n\n```java\n@GetMapping(&quot;/admin&quot;)\n@PreAuthorize(&quot;hasRole(&#x27;ADMIN&#x27;)&quot;)\npublic String adminResource() {\n    return &quot;Admin resource&quot;;\n}\n```\n\n### 3. 获取 JWT 信息\n通过 `@AuthenticationPrincipal Jwt` 获取令牌信息。\n\n**使用步骤**：\n1. 添加 `spring-boot-starter-oauth2-resource-server` 依赖。\n2. 配置 `issuer-uri` 或 `jwk-set-uri`。\n3. 定义受保护的 REST 端点。\n4. 配置 Spring Security 启用资源服务器。\n\n## 版本与依赖管理\n\n版本由 `spring-boot-starter-parent` 管理，查看最新版本：[Maven 中央仓库](https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-oauth2-resource-server).\n\n## 常用配置文件\n\n在 `application.yml` 中配置资源服务器：\n\n```yaml\nspring:\n  security:\n    oauth2:\n      resourceserver:\n        jwt:\n          issuer-uri: https://auth-server.com\n          jwk-set-uri: https://auth-server.com/.well-known/jwks.json\n```\n\n## 注意事项\n\n- **前置条件**：需包含 `spring-boot-starter-security`。\n- **JWT 验证**：需正确配置 `issuer-uri` 或 `jwk-set-uri`。\n- **Spring Boot 3.x**：使用 Jakarta EE，需确保依赖兼容。\n\n## 常用注解\n\n- `@EnableWebSecurity`：启用 Spring Security。\n- `@PreAuthorize`, `@PostAuthorize`：基于角色或权限控制访问。\n- `@AuthenticationPrincipal`：获取 JWT 信息。\n\n## 常见问题排查\n\n### 1. JWT 验证失败\n**问题**：返回 401 Unauthorized。\n**原因**：JWT 签名无效或发行者不匹配。\n**排查**：\n- 确保 `issuer-uri` 与 JWT 的 `iss` 字段一致。\n- 检查 `jwk-set-uri` 是否可访问。\n**解决**：\n- 修正 `application.yml` 中的配置。\n\n### 2. 角色权限无效\n**问题**：`@PreAuthorize` 不生效。\n**原因**：未启用方法安全。\n**解决**：\n- 添加 `@EnableMethodSecurity`：\n\n    ```java\n    @Configuration\n    @EnableWebSecurity\n    @EnableMethodSecurity\n    public class SecurityConfig {\n        // 配置\n    }\n    ```\n\n### 3. 性能问题\n**问题**：验证 JWT 耗时长。\n**原因**：频繁访问 `jwk-set-uri`。\n**解决**：\n- 配置缓存 JWK 集合：\n\n    ```yaml\n    spring.security.oauth2.resourceserver.jwt.jwk-set-uri-cache-ttl: 3600\n    ```\n\n## 参考资料\n\n- [Spring 官方文档：OAuth2 Resource Server](https://docs.spring.io/spring-security/site/docs/current/reference/html5/#oauth2resourceserver)\n- [Baeldung 教程：Spring Security OAuth2 Resource Server](https://www.baeldung.com/spring-security-oauth-resource-server)"
  },
  {
    "name": "spring-boot-starter-data-jpa",
    "summary": "简化 JPA（Java Persistence API）和 Hibernate 的数据库操作，提供自动化的 ORM 配置，适合关系型数据库开发。",
    "notes": "# spring-boot-starter-data-jpa\n\n## 示例\n\n### 添加依赖\n在 Maven 项目的 `pom.xml` 中添加 `spring-boot-starter-data-jpa` 依赖，需配合数据库驱动（如 H2）：\n\n```xml\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;com.h2database&lt;/groupId&gt;\n    &lt;artifactId&gt;h2&lt;/artifactId&gt;\n    &lt;scope&gt;runtime&lt;/scope&gt;\n&lt;/dependency&gt;\n```\n\n### 配置数据源\n在 `application.yml` 中配置数据库连接：\n\n```yaml\nspring:\n  datasource:\n    url: jdbc:h2:mem:testdb\n    driver-class-name: org.h2.Driver\n    username: sa\n    password: \n  jpa:\n    hibernate:\n      ddl-auto: update\n    show-sql: true\n    properties:\n      hibernate:\n        format_sql: true\n```\n\n### 创建实体类\n定义 JPA 实体：\n\n```java\n@Entity\npublic class User {\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    private Long id;\n    private String name;\n\n    // Getters and Setters\n    public Long getId() { return id; }\n    public void setId(Long id) { this.id = id; }\n    public String getName() { return name; }\n    public void setName(String name) { this.name = name; }\n}\n```\n\n### 创建 Repository\n定义数据访问接口：\n\n```java\n@Repository\npublic interface UserRepository extends JpaRepository&lt;User, Long&gt; {\n    List&lt;User&gt; findByName(String name);\n}\n```\n\n### 使用 Repository\n在服务层使用 Repository 操作数据库：\n\n```java\n@Service\npublic class UserService {\n    @Autowired\n    private UserRepository userRepository;\n\n    public User saveUser(String name) {\n        User user = new User();\n        user.setName(name);\n        return userRepository.save(user);\n    }\n\n    public List&lt;User&gt; findUsersByName(String name) {\n        return userRepository.findByName(name);\n    }\n}\n```\n\n## 解决的问题\n\n`spring-boot-starter-data-jpa` 简化关系型数据库操作，解决以下问题：\n\n- **ORM 配置复杂**：自动配置 JPA 和 Hibernate，减少手动配置。\n- **CRUD 简化**：通过 `JpaRepository` 提供开箱即用的 CRUD 操作。\n- **查询灵活性**：支持方法名推导查询和 `@Query` 自定义查询。\n- **事务管理**：内置事务支持，简化数据库操作一致性。\n\n## 核心功能与使用方法\n\n### 1. 实体映射\n使用 `@Entity`, `@Id`, `@GeneratedValue` 等注解定义数据库表映射。\n\n### 2. Repository 接口\n继承 `JpaRepository` 或 `CrudRepository`，自动实现常见数据库操作。\n\n### 3. 查询方法\n通过方法名推导（如 `findByName`）或 `@Query` 编写自定义 SQL/JPQL：\n\n```java\n@Repository\npublic interface UserRepository extends JpaRepository&lt;User, Long&gt; {\n    @Query(&quot;SELECT u FROM User u WHERE u.name LIKE %:keyword%&quot;)\n    List&lt;User&gt; searchByName(@Param(&quot;keyword&quot;) String keyword);\n}\n```\n\n### 4. 事务管理\n使用 `@Transactional` 确保数据库操作一致性：\n\n```java\n@Service\n@Transactional\npublic class UserService {\n    @Autowired\n    private UserRepository userRepository;\n\n    public void updateUserName(Long id, String newName) {\n        User user = userRepository.findById(id).orElseThrow();\n        user.setName(newName);\n    }\n}\n```\n\n### 5. 数据库初始化\n通过 `spring.jpa.hibernate.ddl-auto` 自动创建/更新表结构。\n\n## 版本与依赖管理\n\n版本由 `spring-boot-starter-parent` 管理，查看最新版本：[Maven 中央仓库](https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-data-jpa).\n\n## 常用配置文件\n\n在 `application.yml` 中配置 JPA 和数据源：\n\n```yaml\nspring:\n  datasource:\n    url: jdbc:mysql://localhost:3306/mydb\n    username: root\n    password: password\n    driver-class-name: com.mysql.cj.jdbc.Driver\n  jpa:\n    hibernate:\n      ddl-auto: update\n    show-sql: true\n    properties:\n      hibernate:\n        dialect: org.hibernate.dialect.MySQLDialect\n        format_sql: true\n```\n\n## 注意事项\n\n- **前置条件**：需添加数据库驱动依赖（如 MySQL、PostgreSQL）。\n- **Spring Boot 3.x**：使用 Jakarta EE（`jakarta.persistence` 包）。\n- **性能优化**：避免复杂查询导致性能问题，使用 `@Query` 或索引优化。\n- **事务管理**：大型操作需使用 `@Transactional` 避免数据不一致。\n\n## 常用注解\n\n- `@Entity`：标记类为 JPA 实体。\n- `@Id`, `@GeneratedValue`：定义主键和生成策略。\n- `@Repository`：标记数据访问接口。\n- `@Transactional`：启用事务管理。\n- `@Query`：定义自定义 JPQL/SQL 查询。\n\n## 常见问题排查\n\n### 1. 数据库连接失败\n**问题**：启动报 `Cannot connect to database`。\n**原因**：数据源配置错误或数据库不可用。\n**排查**：\n- 检查 `spring.datasource.url`、`username`、`password` 是否正确。\n- 确保数据库服务运行。\n**解决**：\n- 修正 `application.yml` 配置或启动数据库服务。\n\n### 2. 表未自动创建\n**问题**：数据库表未生成。\n**原因**：`spring.jpa.hibernate.ddl-auto` 配置错误。\n**排查**：\n- 确保 `ddl-auto` 设置为 `create`, `update` 或 `create-drop`。\n- 检查实体类是否正确使用 `@Entity` 和 `@Id`。\n**解决**：\n- 设置 `spring.jpa.hibernate.ddl-auto: update`。\n\n### 3. 查询方法无效\n**问题**：自定义查询返回空结果。\n**原因**：方法名或 `@Query` 语法错误。\n**排查**：\n- 验证方法名是否符合 Spring Data 命名规则。\n- 检查 `@Query` 的 JPQL 语法和参数绑定。\n**解决**：\n- 修正方法名或 JPQL 查询。\n\n### 4. 事务未生效\n**问题**：数据未正确保存。\n**原因**：缺少 `@Transactional` 或事务配置错误。\n**解决**：\n- 添加 `@Transactional` 到服务方法或类。\n\n## 参考资料\n\n- [Spring 官方文档：Spring Data JPA](https://docs.spring.io/spring-data/jpa/docs/current/reference/html/)\n- [Baeldung 教程：Spring Data JPA](https://www.baeldung.com/the-persistence-layer-with-spring-data-jpa)"
  },
  {
    "name": "spring-boot-starter-data-mongodb",
    "summary": "简化 MongoDB 的操作，提供 Spring Data MongoDB 的自动化配置，适合非关系型数据库开发。",
    "notes": "# spring-boot-starter-data-mongodb\n\n## 示例\n\n### 添加依赖\n在 Maven 项目的 `pom.xml` 中添加 `spring-boot-starter-data-mongodb` 依赖：\n\n```xml\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-data-mongodb&lt;/artifactId&gt;\n&lt;/dependency&gt;\n```\n\n### 配置 MongoDB\n在 `application.yml` 中配置 MongoDB 连接：\n\n```yaml\nspring:\n  data:\n    mongodb:\n      uri: mongodb://localhost:27017/mydb\n      database: mydb\n```\n\n### 创建实体类\n定义 MongoDB 文档：\n\n```java\n@Document(collection = &quot;users&quot;)\npublic class User {\n    @Id\n    private String id;\n    private String name;\n\n    // Getters and Setters\n    public String getId() { return id; }\n    public void setId(String id) { this.id = id; }\n    public String getName() { return name; }\n    public void setName(String name) { this.name = name; }\n}\n```\n\n### 创建 Repository\n定义 MongoDB 数据访问接口：\n\n```java\n@Repository\npublic interface UserRepository extends MongoRepository&lt;User, String&gt; {\n    List&lt;User&gt; findByName(String name);\n}\n```\n\n### 使用 Repository\n在服务层操作 MongoDB：\n\n```java\n@Service\npublic class UserService {\n    @Autowired\n    private UserRepository userRepository;\n\n    public User saveUser(String name) {\n        User user = new User();\n        user.setName(name);\n        return userRepository.save(user);\n    }\n\n    public List&lt;User&gt; findUsersByName(String name) {\n        return userRepository.findByName(name);\n    }\n}\n```\n\n## 解决的问题\n\n`spring-boot-starter-data-mongodb` 简化 MongoDB 操作，解决以下问题：\n\n- **简化配置**：自动配置 MongoDB 客户端和 Spring Data MongoDB。\n- **CRUD 便捷**：通过 `MongoRepository` 提供 CRUD 操作。\n- **灵活查询**：支持方法名推导和 `@Query` 自定义查询。\n- **文档映射**：通过注解映射 Java 对象到 MongoDB 文档。\n\n## 核心功能与使用方法\n\n### 1. 文档映射\n使用 `@Document` 和 `@Id` 注解映射 MongoDB 集合。\n\n### 2. Repository 接口\n继承 `MongoRepository`，自动实现 CRUD 和分页查询。\n\n### 3. 查询方法\n通过方法名推导或 `@Query` 编写 MongoDB 查询：\n\n```java\n@Repository\npublic interface UserRepository extends MongoRepository&lt;User, String&gt; {\n    @Query(&quot;{&#x27;name&#x27;: ?0}&quot;)\n    List&lt;User&gt; findUsersByNameCustom(String name);\n}\n```\n\n### 4. 事务支持\nMongoDB 4.0+ 支持事务，使用 `@Transactional`：\n\n```java\n@Service\n@Transactional\npublic class UserService {\n    @Autowired\n    private UserRepository userRepository;\n\n    public void updateUserName(String id, String newName) {\n        User user = userRepository.findById(id).orElseThrow();\n        user.setName(newName);\n        userRepository.save(user);\n    }\n}\n```\n\n## 版本与依赖管理\n\n版本由 `spring-boot-starter-parent` 管理，查看最新版本：[Maven 中央仓库](https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-data-mongodb).\n\n## 常用配置文件\n\n在 `application.yml` 中配置 MongoDB：\n\n```yaml\nspring:\n  data:\n    mongodb:\n      uri: mongodb://localhost:27017/mydb\n      database: mydb\n      auto-index-creation: true\n```\n\n## 注意事项\n\n- **前置条件**：需安装 MongoDB 或使用云服务（如 MongoDB Atlas）。\n- **事务支持**：MongoDB 4.0+ 支持事务，需使用副本集。\n- **性能优化**：为频繁查询字段创建索引。\n\n## 常用注解\n\n- `@Document`：标记 MongoDB 文档。\n- `@Id`：定义文档主键。\n- `@Repository`：标记数据访问接口。\n- `@Query`：自定义 MongoDB 查询。\n- `@Transactional`：启用事务。\n\n## 常见问题排查\n\n### 1. 连接失败\n**问题**：报 `Cannot connect to MongoDB`。\n**原因**：配置错误或 MongoDB 服务未运行。\n**排查**：\n- 检查 `spring.data.mongodb.uri` 是否正确。\n- 确保 MongoDB 服务运行。\n**解决**：\n- 修正 URI 或启动 MongoDB。\n\n### 2. 查询返回空\n**问题**：查询无结果。\n**原因**：方法名或 `@Query` 语法错误。\n**排查**：\n- 验证方法名是否符合 Spring Data 规则。\n- 检查 `@Query` 的 JSON 查询语法。\n**解决**：\n- 修正方法名或查询语法。\n\n### 3. 事务失败\n**问题**：事务未生效。\n**原因**：MongoDB 未启用副本集。\n**解决**：\n- 配置 MongoDB 副本集。\n- 确保使用 `@Transactional`。\n\n## 参考资料\n\n- [Spring 官方文档：Spring Data MongoDB](https://docs.spring.io/spring-data/mongodb/docs/current/reference/html/)\n- [Baeldung 教程：Spring Data MongoDB](https://www.baeldung.com/spring-data-mongodb-tutorial)"
  },
  {
    "name": "spring-boot-starter-data-redis",
    "summary": "简化 Redis 操作，提供 Spring Data Redis 和 Lettuce/Jedis 客户端的自动化配置，适合缓存、会话管理和消息队列场景。",
    "notes": "# spring-boot-starter-data-redis\n\n## 示例\n\n### 添加依赖\n在 Maven 项目的 `pom.xml` 中添加 `spring-boot-starter-data-redis` 依赖：\n\n```xml\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;\n&lt;/dependency&gt;\n```\n\n### 配置 Redis\n在 `application.yml` 中配置 Redis 连接：\n\n```yaml\nspring:\n  redis:\n    host: localhost\n    port: 6379\n    password: mypassword\n    database: 0\n```\n\n### 使用 RedisTemplate\n操作 Redis 数据：\n\n```java\n@Service\npublic class CacheService {\n    @Autowired\n    private RedisTemplate&lt;String, Object&gt; redisTemplate;\n\n    public void cacheUser(String key, User user) {\n        redisTemplate.opsForValue().set(key, user);\n    }\n\n    public User getUser(String key) {\n        return (User) redisTemplate.opsForValue().get(key);\n    }\n}\n\nclass User implements Serializable {\n    private String id;\n    private String name;\n\n    // Getters and Setters\n    public String getId() { return id; }\n    public void setId(String id) { this.id = id; }\n    public String getName() { return name; }\n    public void setName(String name) { this.name = name; }\n}\n```\n\n### 使用 Redis Repository\n定义 Redis 数据访问接口：\n\n```java\n@Repository\npublic interface UserRepository extends CrudRepository&lt;User, String&gt; {\n}\n```\n\n## 解决的问题\n\n`spring-boot-starter-data-redis` 简化 Redis 操作，解决以下问题：\n\n- **简化配置**：自动配置 Redis 客户端（Lettuce 默认）。\n- **高效缓存**：支持键值存储、列表、集合等操作。\n- **会话管理**：支持 Spring Session 的 Redis 后端。\n- **消息发布/订阅**：支持 Redis Pub/Sub 模式。\n\n## 核心功能与使用方法\n\n### 1. RedisTemplate\n提供操作 Redis 的通用 API，支持键值、列表、哈希等操作：\n\n```java\nredisTemplate.opsForHash().put(&quot;user:1&quot;, &quot;name&quot;, &quot;John Doe&quot;);\n```\n\n### 2. Repository 支持\n通过 `CrudRepository` 提供对象映射和 CRUD 操作。\n\n### 3. 发布/订阅\n实现消息发布和订阅：\n\n```java\n@Service\npublic class MessagePublisher {\n    @Autowired\n    private RedisTemplate&lt;String, Object&gt; redisTemplate;\n\n    public void publish(String channel, String message) {\n        redisTemplate.convertAndSend(channel, message);\n    }\n}\n\n@Component\npublic class MessageSubscriber implements MessageListener {\n    @Override\n    public void onMessage(Message message, byte[] pattern) {\n        System.out.println(&quot;Received: &quot; + new String(message.getBody()));\n    }\n}\n```\n\n### 4. 会话管理\n启用 Redis 存储会话：\n\n```xml\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.session&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-session-data-redis&lt;/artifactId&gt;\n&lt;/dependency&gt;\n```\n\n```yaml\nspring:\n  session:\n    store-type: redis\n```\n\n## 版本与依赖管理\n\n版本由 `spring-boot-starter-parent` 管理，查看最新版本：[Maven 中央仓库](https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-data-redis).\n\n## 常用配置文件\n\n在 `application.yml` 中配置 Redis：\n\n```yaml\nspring:\n  redis:\n    host: localhost\n    port: 6379\n    password: mypassword\n    database: 0\n    lettuce:\n      pool:\n        max-active: 8\n        max-idle: 8\n        min-idle: 0\n```\n\n## 注意事项\n\n- **前置条件**：需安装 Redis 或使用云服务（如 AWS ElastiCache）。\n- **序列化**：存储对象需实现 `Serializable` 接口。\n- **客户端选择**：默认使用 Lettuce，需切换 Jedis 可排除 Lettuce 依赖：\n\n    ```xml\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n        &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;\n        &lt;exclusions&gt;\n            &lt;exclusion&gt;\n                &lt;groupId&gt;io.lettuce&lt;/groupId&gt;\n                &lt;artifactId&gt;lettuce-core&lt;/artifactId&gt;\n            &lt;/exclusion&gt;\n        &lt;/exclusions&gt;\n    &lt;/dependency&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;redis.clients&lt;/groupId&gt;\n        &lt;artifactId&gt;jedis&lt;/artifactId&gt;\n    &lt;/dependency&gt;\n    ```\n\n## 常用注解\n\n- `@Repository`：标记 Redis 数据访问接口。\n- `@EnableRedisRepositories`：启用 Redis Repository（通常自动配置）。\n\n## 常见问题排查\n\n### 1. 连接失败\n**问题**：报 `Cannot connect to Redis`。\n**原因**：配置错误或 Redis 服务未运行。\n**排查**：\n- 检查 `spring.redis.host` 和 `port` 是否正确。\n- 确保 Redis 服务运行。\n**解决**：\n- 修正配置或启动 Redis。\n\n### 2. 数据未存储\n**问题**：数据未保存到 Redis。\n**原因**：序列化问题或键冲突。\n**排查**：\n- 确保存储对象实现 `Serializable`。\n- 检查键是否被覆盖。\n**Solve**：\n- 实现 `Serializable` 或使用唯一键。\n\n### 3. 性能问题\n**问题**：Redis 操作缓慢。\n**原因**：连接池配置不当。\n**Solve**：\n- 调整 `spring.redis.lettuce.pool` 参数，增加 `max-active` 和 `max-idle`。\n\n## 参考资料\n\n- [Spring 官方文档：Spring Data Redis](https://docs.spring.io/spring-data/redis/docs/current/reference/html/)\n- [Baeldung 教程：Spring Data Redis](https://www.baeldung.com/spring-data-redis-tutorial)"
  },
  {
    "name": "spring-boot-starter-test",
    "summary": "提供 Spring Boot 应用的测试支持，集成 JUnit、Mockito、Spring Test 等工具，简化单元测试和集成测试开发。",
    "notes": "# spring-boot-starter-test\n\n## 示例\n\n### 添加依赖\n在 Maven 项目的 `pom.xml` 中添加 `spring-boot-starter-test` 依赖，作用域为 `test`：\n\n```xml\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;\n    &lt;scope&gt;test&lt;/scope&gt;\n&lt;/dependency&gt;\n```\n\n### 单元测试\n测试服务层逻辑：\n\n```java\n@SpringBootTest\nclass UserServiceTest {\n\n    @Autowired\n    private UserService userService;\n\n    @Test\n    void testSaveUser() {\n        User user = userService.saveUser(&quot;John Doe&quot;);\n        assertNotNull(user.getId());\n        assertEquals(&quot;John Doe&quot;, user.getName());\n    }\n}\n```\n\n### Mock 测试\n使用 Mockito 模拟依赖：\n\n```java\n@SpringBootTest\nclass UserServiceTest {\n\n    @MockBean\n    private UserRepository userRepository;\n\n    @Autowired\n    private UserService userService;\n\n    @Test\n    void testFindUserByName() {\n        String name = &quot;John Doe&quot;;\n        User user = new User(1L, name);\n        when(userRepository.findByName(name)).thenReturn(Collections.singletonList(user));\n\n        List&lt;User&gt; users = userService.findUsersByName(name);\n        assertFalse(users.isEmpty());\n        assertEquals(name, users.get(0).getName());\n    }\n}\n```\n\n### Web 层测试\n测试 REST 控制器：\n\n```java\n@WebMvcTest(UserController.class)\nclass UserControllerTest {\n\n    @Autowired\n    private MockMvc mockMvc;\n\n    @MockBean\n    private UserService userService;\n\n    @Test\n    void testGetUserById() throws Exception {\n        Long id = 1L;\n        User user = new User(id, &quot;John Doe&quot;);\n        when(userService.findById(id)).thenReturn(user);\n\n        mockMvc.perform(get(&quot;/api/users/{id}&quot;, id))\n               .andExpect(status().isOk())\n               .andExpect(jsonPath(&quot;$.name&quot;, is(&quot;John Doe&quot;)));\n    }\n}\n```\n\n## 解决的问题\n\n`spring-boot-starter-test` 简化 Spring Boot 应用的测试开发，解决以下问题：\n\n- **测试环境复杂**：自动配置 Spring 上下文，简化测试环境搭建。\n- **依赖管理**：集成 JUnit 5、Mockito、AssertJ、Spring Test 等测试框架。\n- **单元与集成测试**：支持服务层、Web 层和数据库层的测试。\n- **模拟依赖**：通过 `@MockBean` 模拟 Spring Bean，隔离测试。\n- **测试覆盖率**：支持 JaCoCo 等工具生成覆盖率报告。\n\n## 核心功能与使用方法\n\n### 1. 单元测试\n使用 `@SpringBootTest` 加载完整 Spring 上下文进行测试。\n\n### 2. Mock 测试\n使用 `@MockBean` 模拟依赖，结合 Mockito 的 `when` 和 `verify` 控制行为。\n\n### 3. Web 层测试\n使用 `@WebMvcTest` 测试控制器，结合 `MockMvc` 模拟 HTTP 请求：\n\n```java\nmockMvc.perform(post(&quot;/api/users&quot;).contentType(MediaType.APPLICATION_JSON)\n                                .content(&quot;{\\&quot;name\\&quot;: \\&quot;John Doe\\&quot;}&quot;))\n       .andExpect(status().isCreated());\n```\n\n### 4. 数据层测试\n使用 `@DataJpaTest` 测试 JPA Repository：\n\n```java\n@DataJpaTest\nclass UserRepositoryTest {\n\n    @Autowired\n    private UserRepository userRepository;\n\n    @Test\n    void testFindByName() {\n        User user = new User();\n        user.setName(&quot;John Doe&quot;);\n        userRepository.save(user);\n\n        List&lt;User&gt; users = userRepository.findByName(&quot;John Doe&quot;);\n        assertFalse(users.isEmpty());\n    }\n}\n```\n\n### 5. 测试覆盖率\n配置 JaCoCo 生成覆盖率报告：\n\n```xml\n&lt;plugin&gt;\n    &lt;groupId&gt;org.jacoco&lt;/groupId&gt;\n    &lt;artifactId&gt;jacoco-maven-plugin&lt;/artifactId&gt;\n    &lt;version&gt;0.8.8&lt;/version&gt;\n    &lt;executions&gt;\n        &lt;execution&gt;\n            &lt;goals&gt;\n                &lt;goal&gt;prepare-agent&lt;/goal&gt;\n            &lt;/goals&gt;\n        &lt;/execution&gt;\n        &lt;execution&gt;\n            &lt;id&gt;report&lt;/id&gt;\n            &lt;phase&gt;test&lt;/phase&gt;\n            &lt;goals&gt;\n                &lt;goal&gt;report&lt;/goal&gt;\n            &lt;/goals&gt;\n        &lt;/execution&gt;\n    &lt;/executions&gt;\n&lt;/plugin&gt;\n```\n\n## 版本与依赖管理\n\n版本由 `spring-boot-starter-parent` 管理，查看最新版本：[Maven 中央仓库](https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-test).\n\n## 常用配置文件\n\n在 `application-test.yml` 中配置测试环境：\n\n```yaml\nspring:\n  datasource:\n    url: jdbc:h2:mem:testdb\n    driver-class-name: org.h2.Driver\n    username: sa\n    password:\n  jpa:\n    hibernate:\n      ddl-auto: create-drop\n```\n\n## 注意事项\n\n- **前置条件**：需为 Spring Boot 项目，依赖置于 `test` 作用域。\n- **Spring Boot 3.x**：使用 Jakarta EE，需确保测试依赖兼容。\n- **测试隔离**：使用 `@MockBean` 或 `@DataJpaTest` 隔离测试范围以提高性能。\n- **资源清理**：测试完成后清理 H2 数据库等临时资源。\n\n## 常用注解\n\n- `@SpringBootTest`：加载完整 Spring 上下文。\n- `@WebMvcTest`：测试 Web 层，加载控制器相关 Bean。\n- `@DataJpaTest`：测试 JPA Repository。\n- `@MockBean`：模拟 Spring Bean。\n- `@Test`：标记测试方法。\n\n## 常见问题排查\n\n### 1. 测试上下文加载失败\n**问题**：报 `Failed to load ApplicationContext`。\n**原因**：配置错误或依赖缺失。\n**排查**：\n- 确保 `spring-boot-starter-test` 依赖已添加。\n- 检查 `application-test.yml` 是否正确。\n**解决**：\n- 修正配置或添加缺失依赖。\n\n### 2. Mock 不生效\n**问题**：模拟行为未触发。\n**原因**：`@MockBean` 配置错误或未调用 `when`。\n**排查**：\n- 确保 `@MockBean` 正确注入。\n- 检查 Mockito 的 `when` 配置。\n**解决**：\n- 修正 `when` 语句或使用 `verify` 检查调用。\n\n### 3. 测试数据库未初始化\n**问题**：数据库表未创建。\n**原因**：`spring.jpa.hibernate.ddl-auto` 配置错误。\n**解决**：\n- 设置 `spring.jpa.hibernate.ddl-auto: create-drop`。\n\n### 4. HTTP 请求测试失败\n**问题**：`MockMvc` 返回意外状态码。\n**原因**：请求路径或参数错误。\n**排查**：\n- 检查 `MockMvc` 的请求 URL 和方法。\n- 确保控制器注解和路径正确。\n**Solve**：\n- 修正请求路径或参数。\n\n## 参考资料\n\n- [Spring 官方文档：Testing](https://docs.spring.io/spring-boot/docs/current/reference/html/spring-boot-features.html#boot-features-testing)\n- [Baeldung 教程：Spring Boot Testing](https://www.baeldung.com/spring-boot-testing)"
  },
  {
    "name": "spring-boot-starter-validation",
    "summary": "提供 Hibernate Validator 的集成，用于数据校验，支持 Bean Validation 规范（如 JSR-380），简化输入验证。",
    "notes": "# spring-boot-starter-validation\n\n## 示例\n\n### 添加依赖\n在 Maven 项目的 `pom.xml` 中添加 `spring-boot-starter-validation` 依赖：\n\n```xml\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-validation&lt;/artifactId&gt;\n&lt;/dependency&gt;\n```\n\n### 定义实体校验\n为 POJO 添加校验注解：\n\n```java\npublic class UserForm {\n    @NotBlank(message = &quot;Name cannot be blank&quot;)\n    @Size(min = 2, max = 50, message = &quot;Name must be between 2 and 50 characters&quot;)\n    private String name;\n\n    @Email(message = &quot;Invalid email format&quot;)\n    private String email;\n\n    // Getters and Setters\n    public String getName() { return name; }\n    public void setName(String name) { this.name = name; }\n    public String getEmail() { return email; }\n    public void setEmail(String email) { this.email = email; }\n}\n```\n\n### 控制器校验\n在控制器中启用校验：\n\n```java\n@RestController\npublic class UserController {\n\n    @PostMapping(&quot;/users&quot;)\n    public ResponseEntity&lt;String&gt; createUser(@Valid @RequestBody UserForm user, BindingResult result) {\n        if (result.hasErrors()) {\n            return ResponseEntity.badRequest().body(result.getAllErrors().toString());\n        }\n        return ResponseEntity.ok(&quot;User created: &quot; + user.getName());\n    }\n}\n```\n\n### 全局异常处理\n处理校验错误：\n\n```java\n@RestControllerAdvice\npublic class GlobalExceptionHandler {\n\n    @ExceptionHandler(MethodArgumentNotValidException.class)\n    public ResponseEntity&lt;Map&lt;String, String&gt;&gt; handleValidationExceptions(MethodArgumentNotValidException ex) {\n        Map&lt;String, String&gt; errors = new HashMap&lt;&gt;();\n        ex.getBindingResult().getFieldErrors().forEach(error -&gt;\n            errors.put(error.getField(), error.getDefaultMessage()));\n        return ResponseEntity.badRequest().body(errors);\n    }\n}\n```\n\n## 解决的问题\n\n`spring-boot-starter-validation` 简化数据校验，解决以下问题：\n\n- **输入验证**：通过注解声明式校验数据，减少手动检查代码。\n- **一致性**：支持 JSR-380 规范，确保校验规则统一。\n- **错误处理**：提供便捷的错误信息收集和返回机制。\n- **与 Spring 集成**：无缝支持 Spring MVC 和 REST API 校验。\n\n## 核心功能与使用方法\n\n### 1. 校验注解\n使用 Hibernate Validator 注解（如 `@NotBlank`, `@Email`, `@Size`）定义校验规则。\n\n### 2. 控制器校验\n通过 `@Valid` 触发校验，结合 `BindingResult` 处理错误。\n\n### 3. 自定义校验\n创建自定义校验注解：\n\n```java\n@Target({ElementType.FIELD})\n@Retention(RetentionPolicy.RUNTIME)\n@Constraint(validatedBy = CustomValidator.class)\npublic @interface CustomConstraint {\n    String message() default &quot;Invalid value&quot;;\n    Class&lt;?&gt;[] groups() default {};\n    Class&lt;? extends Payload&gt;[] payload() default {};\n}\n\npublic class CustomValidator implements ConstraintValidator&lt;CustomConstraint, String&gt; {\n    @Override\n    public boolean isValid(String value, ConstraintValidatorContext context) {\n        return value != null &amp;&amp; value.startsWith(&quot;valid&quot;);\n    }\n}\n```\n\n### 4. 校验分组\n支持分组校验：\n\n```java\npublic interface CreateGroup {}\npublic interface UpdateGroup {}\n\npublic class UserForm {\n    @NotBlank(groups = {CreateGroup.class})\n    private String name;\n\n    @NotNull(groups = {UpdateGroup.class})\n    private Long id;\n}\n\n@PostMapping(&quot;/users&quot;)\npublic ResponseEntity&lt;String&gt; createUser(@Validated(CreateGroup.class) @RequestBody UserForm user) {\n    return ResponseEntity.ok(&quot;User created&quot;);\n}\n```\n\n## 版本与依赖管理\n\n版本由 `spring-boot-starter-parent` 管理，查看最新版本：[Maven 中央仓库](https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-validation).\n\n## 常用配置文件\n\n在 `application.yml` 中配置校验行为（通常无需额外配置）：\n\n```yaml\nspring:\n  messages:\n    basename: messages\n    encoding: UTF-8\n```\n\n## 注意事项\n\n- **前置条件**：需配合 `spring-boot-starter-web` 使用。\n- **Spring Boot 3.x**：使用 Jakarta EE，需确保依赖兼容。\n- **国际化**：错误消息支持国际化，需配置 `messages.properties`。\n\n## 常用注解\n\n- `@Valid`：触发校验。\n- `@NotBlank`, `@NotNull`, `@Size`, `@Email`：常见校验注解。\n- `@Validated`：支持分组校验。\n- `@Constraint`：定义自定义校验注解。\n\n## 常见问题排查\n\n### 1. 校验不生效\n**问题**：`@Valid` 未触发校验。\n**原因**：依赖缺失或参数未标记 `@Valid`。\n**排查**：\n- 确保 `spring-boot-starter-validation` 依赖已添加。\n- 检查控制器方法是否使用 `@Valid` 或 `@Validated`。\n**Solve**：\n- 添加依赖或修正注解。\n\n### 2. 错误消息未显示\n**问题**：校验错误未返回。\n**原因**：未处理 `BindingResult` 或异常。\n**Solve**：\n- 检查 `BindingResult` 或添加 `@RestControllerAdvice` 处理 `MethodArgumentNotValidException`。\n\n### 3. 国际化消息无效\n**问题**：错误消息未本地化。\n**原因**：`messages.properties` 配置错误。\n**Solve**：\n- 确保 `spring.messages.basename` 正确并包含校验消息。\n\n## 参考资料\n\n- [Spring 官方文档：Validation](https://docs.spring.io/spring-boot/docs/current/reference/html/spring-boot-features.html#boot-features-validation)\n- [Baeldung 教程：Spring Validation](https://www.baeldung.com/spring-validation)"
  },
  {
    "name": "spring-boot-starter-cache",
    "summary": "提供缓存支持，集成 Spring Cache 抽象，简化缓存操作，支持多种缓存实现（如 EhCache、Redis）。",
    "notes": "# 示例\n\n## 添加依赖\n将 `spring-boot-starter-cache` 依赖项添加到你的 Maven 项目的 `pom.xml` 中：\n\n```xml\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-cache&lt;/artifactId&gt;\n&lt;/dependency&gt;\n```\n\n## 缓存方法结果\n使用 `@Cacheable` 注解来缓存方法结果：\n\n```java\n@Service\npublic class UserService {\n    @Cacheable(\"users\")\n    public User getUser(Long id) {\n        return new User(id, \"John Doe\");\n    }\n}\n\n@Configuration\n@EnableCaching\npublic class CacheConfig {\n}\n```\n\n# 解决什么问题\n\n`spring-boot-starter-cache` 提供缓存支持以解决以下问题：\n\n- **性能优化**：缓存频繁访问的数据，以减少数据库查询。\n- **简化缓存管理**：通过注解实现声明式缓存。\n- **多种缓存支持**：与 EhCache 和 Redis 等实现兼容。\n\n# 核心功能与如何使用\n\n- **缓存注解**：使用 `@Cacheable`、`@CachePut` 和 `@CacheEvict` 来管理缓存。\n- **缓存管理器**：自动配置一个默认的缓存管理器（例如 `ConcurrentMapCache`）。\n- **自定义缓存**：通过 `CacheManager` 自定义缓存策略。\n\n# 版本与依赖管理\n\n版本由 `spring-boot-starter-parent` 管理。查看最新版本：\n\n- [Maven 仓库](https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-cache)\n\n# 常用配置\n\n```yaml\nspring:\n  cache:\n    type: redis\n    cache-names: users,products\n```\n\n# 重要说明\n\n- **启用缓存**：添加 `@EnableCaching` 以激活缓存功能。\n- **缓存实现依赖**：根据需要引入 Redis 或 EhCache 的依赖。\n\n# 常用注解\n\n- **`@EnableCaching`**：启用缓存支持。\n- **`@Cacheable`**：缓存方法结果。\n- **`@CacheEvict`**：清除缓存条目。\n\n# 常见问题排查\n\n- **问题：缓存不工作**\n  - **原因**：缺少 `@EnableCaching` 或未配置缓存管理器。\n  - **解决方案**：检查 `@EnableCaching` 和 `spring.cache.type` 配置。\n- **问题：缓存数据不一致**\n  - **原因**：缓存未及时更新。\n  - **解决方案**：使用 `@CacheEvict` 或设置 TTL（生存时间）。"
  },
  {
    "name": "spring-cloud-starter-config",
    "summary": "提供客户端访问 Spring Cloud Config Server 的支持，用于集中式配置管理，适合微服务动态配置场景。",
    "notes": "# 示例\n\n## 添加依赖\n将 `spring-cloud-starter-config` 依赖项添加到你的 Maven 项目的 `pom.xml` 中：\n\n```xml\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-cloud-starter-config&lt;/artifactId&gt;\n&lt;/dependency&gt;\n```\n\n## 连接到配置中心\n配置 `bootstrap.yml` 以连接到配置中心：\n\n```yaml\nspring:\n  cloud:\n    config:\n      uri: http://localhost:8888\n      name: myapp\n      profile: dev\n```\n\n# 解决什么问题\n\n`spring-cloud-starter-config` 提供集中式配置管理以解决：\n\n- **统一配置**：集中管理微服务配置，支持动态刷新。\n- **环境隔离**：通过 profiles 支持不同环境的配置。\n- **简化维护**：从配置中心拉取配置，无需修改代码。\n\n# 核心功能与如何使用\n\n- **连接配置中心**：在 `bootstrap.yml` 中配置服务器地址。\n- **动态刷新**：使用 `@RefreshScope` 动态更新配置。\n- **优先级**：合并本地和远程配置。\n\n# 版本与依赖管理\n\n版本由 `spring-cloud-dependencies` 管理。查看最新版本：\n\n- [Maven 仓库](https://mvnrepository.com/artifact/org.springframework.cloud/spring-cloud-starter-config)\n\n# 常用配置\n\n```yaml\nspring:\n  cloud:\n    config:\n      uri: http://config-server:8888\n      fail-fast: true\n      retry:\n        max-attempts: 6\n```\n\n# 重要说明\n\n- **Bootstrap 优先级**：将配置放在 `bootstrap.yml` 中。\n- **依赖配置中心**：需要一个正在运行的配置中心服务。\n\n# 常用注解\n\n- **`@RefreshScope`**：启用动态配置刷新。\n- **`@Value`**：注入配置属性。\n\n# 常见问题排查\n\n- **问题：配置未加载**\n  - **原因**：配置中心不可用。\n  - **解决方案**：检查 `spring.cloud.config.uri` 和服务器状态。\n- **问题：刷新不生效**\n  - **原因**：缺少 `@RefreshScope` 注解。\n  - **解决方案**：在相关的 Bean 上添加 `@RefreshScope` 注解。"
  },
  {
    "name": "spring-cloud-starter-netflix-eureka-client",
    "summary": "提供 Eureka 客户端支持，用于服务注册与发现，适合微服务架构中的服务治理。",
    "notes": "# 示例\n\n## 添加依赖\n将 `spring-cloud-starter-netflix-eureka-client` 依赖项添加到你的 Maven 项目的 `pom.xml` 中：\n\n```xml\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;\n&lt;/dependency&gt;\n```\n\n## 配置 Eureka 客户端\n在 `application.yml` 中配置 Eureka 客户端以连接到 Eureka 服务器：\n\n```yaml\nspring:\n  application:\n    name: myapp\neureka:\n  client:\n    service-url:\n      defaultZone: http://localhost:8761/eureka\n```\n\n# 解决什么问题\n\n`spring-cloud-starter-netflix-eureka-client` 提供服务注册与发现以解决：\n\n- **服务发现**：动态发现微服务实例。\n- **负载均衡**：与 Ribbon 集成，实现客户端负载均衡。\n- **高可用性**：支持 Eureka 服务器集群部署。\n\n# 核心功能与如何使用\n\n- **服务注册**：自动将服务注册到 Eureka 服务器。\n- **服务发现**：通过 `DiscoveryClient` 获取服务实例。\n- **负载均衡**：通过 `RestTemplate` 或 `WebClient` 实现客户端负载均衡。\n\n# 版本与依赖管理\n\n版本由 `spring-cloud-dependencies` 管理。查看最新版本：\n\n- [Maven 仓库](https://mvnrepository.com/artifact/org.springframework.cloud/spring-cloud-starter-netflix-eureka-client)\n\n# 常用配置\n\n```yaml\neureka:\n  client:\n    service-url:\n      defaultZone: http://eureka-server:8761/eureka\n    fetch-registry: true\n    register-with-eureka: true\n```\n\n# 重要说明\n\n- **依赖 Eureka 服务器**：需要一个正在运行的 Eureka 服务器。\n- **心跳机制**：确保服务定期向 Eureka 发送心跳。\n\n# 常用注解\n\n- **`@EnableDiscoveryClient`**：启用服务发现客户端。\n- **`@LoadBalanced`**：启用客户端负载均衡。\n\n# 常见问题排查\n\n- **问题：服务未注册**\n  - **原因**：Eureka 服务器地址不正确。\n  - **解决方案**：检查 `eureka.client.service-url.defaultZone` 配置。\n- **问题：服务不可用**\n  - **原因**：心跳失败。\n  - **解决方案**：检查网络和 Eureka 客户端配置。"
  },
  {
    "name": "spring-cloud-starter-openfeign",
    "summary": "提供声明式 HTTP 客户端，基于 OpenFeign 简化微服务间调用，支持负载均衡和容错。",
    "notes": "# 示例\n\n## 添加依赖\n将 `spring-cloud-starter-openfeign` 依赖项添加到你的 Maven 项目的 `pom.xml` 中：\n\n```xml\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;\n&lt;/dependency&gt;\n```\n\n## 定义 Feign 客户端\n定义一个 Feign 客户端接口：\n\n```java\n@FeignClient(name = \"user-service\", url = \"http://localhost:8081\")\npublic interface UserClient {\n    @GetMapping(\"/api/users/{id}\")\n    User getUser(@PathVariable(\"id\") Long id);\n}\n\n@Configuration\n@EnableFeignClients\npublic class FeignConfig {\n}\n```\n\n# 解决什么问题\n\n`spring-cloud-starter-openfeign` 通过解决以下问题来简化微服务之间的 HTTP 调用：\n\n- **声明式调用**：通过接口和注解定义 HTTP 请求。\n- **负载均衡**：与 Ribbon 或 LoadBalancerClient 集成。\n- **容错性**：支持 Hystrix 或 Resilience4j 断路器。\n\n# 核心功能与如何使用\n\n- **定义 Feign 客户端**：使用 `@FeignClient` 声明客户端接口。\n- **自动注入**：使用 `@Autowired` 注入 Feign 客户端。\n- **容错处理**：使用 `fallback` 或 `fallbackFactory` 处理失败。\n\n# 版本与依赖管理\n\n版本由 `spring-cloud-dependencies` 管理。查看最新版本：\n\n- [Maven 仓库](https://mvnrepository.com/artifact/org.springframework.cloud/spring-cloud-starter-openfeign)\n\n# 常用配置\n\n```yaml\nfeign:\n  client:\n    config:\n      default:\n        connectTimeout: 5000\n        readTimeout: 5000\n```\n\n# 重要说明\n\n- **启用 Feign**：添加 `@EnableFeignClients` 以激活 Feign 支持。\n- **服务发现**：需要 Eureka 或其他注册中心进行服务发现。\n\n# 常用注解\n\n- **`@FeignClient`**：定义一个 Feign 客户端。\n- **`@EnableFeignClients`**：启用 Feign 支持。\n\n# 常见问题排查\n\n- **问题：调用失败**\n  - **原因**：服务不可用或超时。\n  - **解决方案**：检查服务地址和 `feign.client.config` 设置。\n- **问题：负载均衡不工作**\n  - **原因**：未启用服务发现。\n  - **解决方案**：确保 Eureka 或 LoadBalancer 配置正确。"
  },
  {
    "name": "spring-cloud-starter-gateway",
    "summary": "提供 API 网关功能，基于 Spring Cloud Gateway，支持路由、过滤、限流等，适合微服务统一入口。",
    "notes": "# 示例\n\n## 添加依赖\n将 `spring-cloud-starter-gateway` 依赖项添加到你的 Maven 项目的 `pom.xml` 中：\n\n```xml\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-cloud-starter-gateway&lt;/artifactId&gt;\n&lt;/dependency&gt;\n```\n\n## 配置路由\n在 `application.yml` 中配置路由规则：\n\n```yaml\nspring:\n  cloud:\n    gateway:\n      routes:\n      - id: user_route\n        uri: lb://user-service\n        predicates:\n        - Path=/api/users/**\n```\n\n# 解决什么问题\n\n`spring-cloud-starter-gateway` 提供 API 网关以解决：\n\n- **统一入口**：为微服务提供单一访问点。\n- **动态路由**：支持基于路径、主机或其他条件的路由。\n- **过滤**：支持请求过滤、速率限制和身份验证。\n\n# 核心功能与如何使用\n\n- **路由配置**：使用 YAML 或 Java DSL 定义路由。\n- **过滤器**：支持全局和特定路由的过滤器，用于身份验证、日志记录等。\n- **服务发现**：使用 `lb://` 协议与 Eureka 集成。\n\n# 版本与依赖管理\n\n版本由 `spring-cloud-dependencies` 管理。查看最新版本：\n\n- [Maven 仓库](https://mvnrepository.com/artifact/org.springframework.cloud/spring-cloud-starter-gateway)\n\n# 常用配置\n\n```yaml\nspring:\n  cloud:\n    gateway:\n      routes:\n      - id: product_route\n        uri: lb://product-service\n        predicates:\n        - Path=/api/products/**\n        filters:\n        - AddRequestHeader=X-Request-Id, 123\n```\n\n# 重要说明\n\n- **响应式架构**：基于 WebFlux，而非 Servlet 技术栈。\n- **服务发现**：需要 Eureka 或其他发现服务。\n\n# 常用注解\n\n- **`@EnableDiscoveryClient`**：启用服务发现。\n- **`@Bean`**：定义自定义过滤器或路由。\n\n# 常见问题排查\n\n- **问题：路由失败**\n  - **原因**：服务不可用或路径不正确。\n  - **解决方案**：检查 `uri` 和服务注册状态。\n- **问题：过滤器未应用**\n  - **原因**：过滤器配置不正确。\n  - **解决方案**：检查 `spring.cloud.gateway.filters` 配置。"
  },
  {
    "name": "spring-cloud-starter-loadbalancer",
    "summary": "提供客户端负载均衡支持，替代 Ribbon，基于 Spring Cloud LoadBalancer，适合微服务间调用。",
    "notes": "# 示例\n\n## 添加依赖\n将 `spring-cloud-starter-loadbalancer` 依赖项添加到你的 Maven 项目的 `pom.xml` 中：\n\n```xml\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-cloud-starter-loadbalancer&lt;/artifactId&gt;\n&lt;/dependency&gt;\n```\n\n## 配置支持负载均衡的 RestTemplate\n配置一个支持负载均衡的 `RestTemplate`：\n\n```java\n@Configuration\npublic class LoadBalancerConfig {\n    @Bean\n    @LoadBalanced\n    public RestTemplate restTemplate() {\n        return new RestTemplate();\n    }\n}\n```\n\n# 解决什么问题\n\n`spring-cloud-starter-loadbalancer` 提供客户端负载均衡以解决：\n\n- **负载均衡**：在多个服务实例之间分配请求。\n- **服务发现集成**：与 Eureka 或其他注册中心协同工作。\n- **替代 Ribbon**：提供更轻量、更现代的负载均衡解决方案。\n\n# 核心功能与如何使用\n\n- **负载均衡**：为 `RestTemplate` 或 `WebClient` 添加 `@LoadBalanced` 注解以启用。\n- **服务发现**：自动从注册中心检索服务实例。\n- **自定义策略**：支持轮询、随机或其他负载均衡策略。\n\n# 版本与依赖管理\n\n版本由 `spring-cloud-dependencies` 管理。查看最新版本：\n\n- [Maven 仓库](https://mvnrepository.com/artifact/org.springframework.cloud/spring-cloud-starter-loadbalancer)\n\n# 常用配置\n\n```yaml\nspring:\n  cloud:\n    loadbalancer:\n      retry:\n        enabled: true\n```\n\n# 重要说明\n\n- **服务发现**：需要 Eureka 或其他发现服务。\n- **支持 WebClient**：推荐在响应式应用中使用。\n\n# 常用注解\n\n- **`@LoadBalanced`**：启用负载均衡。\n- **`@EnableDiscoveryClient`**：启用服务发现。\n\n# 常见问题排查\n\n- **问题：负载均衡失败**\n  - **原因**：服务实例不可用。\n  - **解决方案**：检查 Eureka 注册状态。\n- **问题：请求超时**\n  - **原因**：超时配置不当。\n  - **解决方案**：调整 `spring.cloud.loadbalancer.retry` 设置。"
  },
  {
    "name": "spring-cloud-starter-circuitbreaker-resilience4j",
    "summary": "提供 Resilience4j 断路器支持，用于微服务容错，防止服务级联失败。",
    "notes": "# 示例\n\n## 添加依赖\n将 `spring-cloud-starter-circuitbreaker-resilience4j` 依赖项添加到你的 Maven 项目的 `pom.xml` 中：\n\n```xml\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-cloud-starter-circuitbreaker-resilience4j&lt;/artifactId&gt;\n&lt;/dependency&gt;\n```\n\n## 使用断路器保护方法\n使用 Resilience4j 来保护方法：\n\n```java\n@Service\npublic class UserService {\n    @CircuitBreaker(name = \"userService\", fallbackMethod = \"fallback\")\n    public String getUser(Long id) {\n        // 模拟外部服务调用\n        throw new RuntimeException(\"Service unavailable\");\n    }\n\n    public String fallback(Long id, Throwable t) {\n        return \"Fallback response\";\n    }\n}\n```\n\n# 解决什么问题\n\n`spring-cloud-starter-circuitbreaker-resilience4j` 提供容错能力以解决：\n\n- **服务容错**：防止因服务问题导致的级联失败。\n- **断路器模式**：在失败期间切换到降级逻辑。\n- **性能监控**：跟踪失败率和响应时间。\n\n# 核心功能与如何使用\n\n- **断路器**：使用 `@CircuitBreaker` 保护方法调用。\n- **降级逻辑**：使用 `fallbackMethod` 定义降级行为。\n- **配置管理**：通过 YAML 配置断路器参数。\n\n# 版本与依赖管理\n\n版本由 `spring-cloud-dependencies` 管理。查看最新版本：\n\n- [Maven 仓库](https://mvnrepository.com/artifact/org.springframework.cloud/spring-cloud-starter-circuitbreaker-resilience4j)\n\n# 常用配置\n\n```yaml\nresilience4j:\n  circuitbreaker:\n    instances:\n      userService:\n        slidingWindowSize: 10\n        failureRateThreshold: 50\n        waitDurationInOpenState: 10000\n```\n\n# 重要说明\n\n- **AOP 依赖**：需要 `spring-boot-starter-aop` 依赖。\n- **配置粒度**：每个断路器需要独立配置。\n\n# 常用注解\n\n- **`@CircuitBreaker`**：启用断路器功能。\n- **`@Retry`**：支持重试机制。\n\n# 常见问题排查\n\n- **问题：断路器未触发**\n  - **原因**：失败率低于阈值。\n  - **解决方案**：调整 `failureRateThreshold` 配置。\n- **问题：降级方法未执行**\n  - **原因**：降级方法签名不匹配。\n  - **解决方案**：确保 `fallbackMethod` 的参数与原始方法匹配。"
  },
  {
    "name": "spring-boot-starter-aop",
    "summary": "提供对 Spring AOP（面向切面编程）和 AspectJ 的支持，用于实现日志记录、安全控制、性能监控等横切关注点。",
    "notes": "# spring-boot-starter-aop\n\n## 示例\n\n### 添加依赖\n在 Maven 项目的 `pom.xml` 中添加 `spring-boot-starter-aop` 依赖。如果已经引入了 `spring-boot-starter-web`，通常已包含 AOP 支持。\n\n```xml\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt;\n&lt;/dependency&gt;\n```\n\n### 创建切面 (Aspect)\n定义一个切面来记录方法的执行时间：\n\n```java\nimport org.aspectj.lang.ProceedingJoinPoint;\nimport org.aspectj.lang.annotation.Around;\nimport org.aspectj.lang.annotation.Aspect;\nimport org.springframework.stereotype.Component;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n@Aspect\n@Component\npublic class ExecutionTimeAspect {\n\n    private static final Logger logger = LoggerFactory.getLogger(ExecutionTimeAspect.class);\n\n    // 拦截 com.example.service 包下所有方法的执行\n    @Around(&quot;execution(* com.example.service..*(..))&quot;)\n    public Object logExecutionTime(ProceedingJoinPoint joinPoint) throws Throwable {\n        long startTime = System.currentTimeMillis();\n        \n        Object proceed = joinPoint.proceed(); // 执行目标方法\n        \n        long executionTime = System.currentTimeMillis() - startTime;\n        logger.info(&quot;{} executed in {} ms&quot;, joinPoint.getSignature(), executionTime);\n        return proceed;\n    }\n}\n```\n\n## 解决的问题\n\n`spring-boot-starter-aop` 旨在解决软件开发中的“横切关注点”（Cross-cutting Concerns）问题，即那些分散在应用多个模块中但功能相似的逻辑：\n\n- **代码解耦**：将日志记录、权限校验、事务管理等通用逻辑从业务代码中分离出来，提高代码模块化和可维护性。\n- **简化配置**：Spring Boot 自动配置 AOP 支持（包括 AspectJ AutoProxy），无需手动配置代理创建器。\n- **统一处理**：提供一种机制来统一处理异常、监控性能或进行缓存操作。\n\n## 核心功能与使用方法\n\n### 1. 启用 AOP\nSpring Boot 默认启用 AOP。如果需要显式启用或配置 AspectJ 自动代理，可以使用 `@EnableAspectJAutoProxy` 注解。\n\n```java\n@SpringBootApplication\n@EnableAspectJAutoProxy(proxyTargetClass = true) // 强制使用 CGLIB 代理\npublic class Application {\n    // ...\n}\n```\n\n### 2. 定义切面 (Aspect)\n使用 `@Aspect` 注解标记一个类为切面，并使用 `@Component` 将其注册为 Spring Bean。\n\n### 3. 定义通知 (Advice)\n通知定义了在何时执行切面逻辑：\n\n- **`@Before`**：在目标方法执行前执行。\n- **`@After`**：在目标方法执行后执行（无论是否发生异常）。\n- **`@AfterReturning`**：在目标方法成功返回后执行。\n- **`@AfterThrowing`**：在目标方法抛出异常后执行。\n- **`@Around`**：环绕通知，最强大，可以控制目标方法是否执行，以及在执行前后添加逻辑。\n\n### 4. 定义切点 (Pointcut)\n切点使用 AspectJ 表达式定义在何处应用通知：\n\n```java\n@Pointcut(&quot;execution(* com.example.repository.*.*(..))&quot;)\npublic void repositoryMethods() {}\n\n@Before(&quot;repositoryMethods()&quot;)\npublic void logBeforeRepositoryCall(JoinPoint joinPoint) {\n    logger.info(&quot;Calling repository method: {}&quot;, joinPoint.getSignature().getName());\n}\n```\n\n## 版本与依赖管理\n\n版本由 `spring-boot-starter-parent` 统一管理。查看最新版本：[Maven 中央仓库](https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-aop)。\n\n## 常用配置文件\n\n在 `application.yml` 中配置 AOP 行为：\n\n```yaml\nspring:\n  aop:\n    # 启用/禁用 AOP 自动配置 (默认为 true)\n    auto: true\n    # 强制使用 CGLIB 代理 (基于类的代理)，即使目标实现了接口 (默认为 false)\n    # 当需要代理未实现接口的类时，或需要调用代理对象内部方法时，设为 true\n    proxy-target-class: true \n```\n\n## 注意事项\n\n- **代理机制**：\n  - 默认情况下，如果目标对象实现了接口，Spring AOP 使用 JDK 动态代理（基于接口）。\n  - 如果目标对象没有实现接口，则使用 CGLIB 代理（基于子类）。\n  - 可以通过 `spring.aop.proxy-target-class=true` 强制使用 CGLIB。\n- **内部方法调用**：AOP 是基于代理实现的。在同一个类中，一个方法调用另一个方法（`this.method()`）不会触发代理逻辑（即切面不会生效）。只有通过代理对象调用方法时才会生效。\n- **Final/Static 方法**：AOP 无法拦截 `final` 或 `static` 方法。\n- **依赖包含**：`spring-boot-starter-web` 和 `spring-boot-starter-data-jpa` 等许多其他 Starter 已经间接包含了 AOP 支持（例如用于事务管理 `@Transactional`）。\n\n## 常用注解\n\n- `@EnableAspectJAutoProxy`：启用对 AspectJ 注解的支持。\n- `@Aspect`：标记一个类为切面。\n- `@Pointcut`：定义切点表达式，可复用。\n- `@Before`, `@After`, `@AfterReturning`, `@AfterThrowing`, `@Around`：定义通知类型。\n\n## 常见问题排查\n\n### 1. 切面未生效\n**原因**：\n1. 切面类未被 Spring 扫描到。\n2. 目标方法被内部调用（`this.method()`）。\n3. 切点表达式（Pointcut）编写错误，未匹配到目标方法。\n4. 目标方法是 `final` 或 `static`。\n\n**解决**：\n- 确保切面类上有 `@Aspect` 和 `@Component` 注解。\n- 检查切点表达式是否正确匹配目标方法签名和包路径。\n- 对于内部调用问题，需要通过注入自身代理对象或重构代码来解决。\n\n### 2. CGLIB 代理错误 (ClassCastException)\n**问题**：尝试将代理对象强制转换为具体实现类时抛出 `ClassCastException`。\n**原因**：如果使用了 JDK 动态代理（默认接口代理），代理对象实现了目标接口，但不是目标实现类的实例。\n**解决**：\n- 尽量面向接口编程，使用接口类型接收代理对象。\n- 如果必须使用实现类类型，设置 `spring.aop.proxy-target-class=true` 强制使用 CGLIB 代理（创建目标类的子类）。\n\n### 3. 事务注解 (@Transactional) 不生效\n**原因**：事务管理也是基于 AOP 实现的。如果 AOP 配置错误或发生内部调用，事务可能不会生效。\n**解决**：参考 AOP 未生效的排查方法，并确保 `spring-boot-starter-data-jpa` 或 `spring-tx` 依赖存在。"
  },
  {
    "name": "spring-boot-starter-amqp",
    "summary": "提供对 AMQP（高级消息队列协议）的支持，默认集成 RabbitMQ。用于实现异步消息传递、服务解耦和流量削峰。",
    "notes": "# spring-boot-starter-amqp\n\n`spring-boot-starter-amqp` 是 Spring Boot 集成 RabbitMQ（或其他支持 AMQP 0-9-1 的代理）的核心 Starter。\n\n## 示例\n\n### 添加依赖\n在 Maven 项目的 `pom.xml` 中添加依赖：\n\n```xml\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;\n&lt;/dependency&gt;\n```\n\n### 配置 RabbitMQ 连接\n在 `application.yml` 中配置：\n\n```yaml\nspring:\n  rabbitmq:\n    host: localhost\n    port: 5672\n    username: user\n    password: password\n```\n\n### 发送消息 (Producer)\n使用 `RabbitTemplate` 发送消息：\n\n```java\nimport org.springframework.amqp.rabbit.core.RabbitTemplate;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Service;\n\n@Service\npublic class MessageProducer {\n\n    @Autowired\n    private RabbitTemplate rabbitTemplate;\n\n    public void sendMessage(String exchange, String routingKey, Object message) {\n        rabbitTemplate.convertAndSend(exchange, routingKey, message);\n        System.out.println(&quot;Message sent: &quot; + message);\n    }\n}\n```\n\n### 接收消息 (Consumer)\n使用 `@RabbitListener` 接收消息：\n\n```java\nimport org.springframework.amqp.rabbit.annotation.RabbitListener;\nimport org.springframework.stereotype.Component;\n\n@Component\npublic class MessageConsumer {\n\n    // 监听名为 &quot;myQueue&quot; 的队列\n    @RabbitListener(queues = &quot;myQueue&quot;)\n    public void handleMessage(String message) {\n        System.out.println(&quot;Message received: &quot; + message);\n    }\n}\n```\n\n### 声明队列和交换机\n\n```java\nimport org.springframework.amqp.core.Queue;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\n\n@Configuration\npublic class RabbitMQConfig {\n\n    @Bean\n    public Queue myQueue() {\n        return new Queue(&quot;myQueue&quot;, true); // true 表示持久化\n    }\n}\n```\n\n## 解决的问题\n\n`spring-boot-starter-amqp` 解决了分布式系统中的通信和集成问题：\n\n- **异步处理**：将耗时操作异步化，提高系统响应速度。\n- **服务解耦**：生产者和消费者之间通过消息队列通信，互不直接依赖。\n- **流量削峰**：在高并发场景下，通过队列缓冲请求，保护后端服务不被冲垮。\n- **简化集成**：Spring Boot 自动配置连接工厂（ConnectionFactory）、RabbitTemplate 和 RabbitAdmin，简化了 RabbitMQ 的使用。\n\n## 核心功能与使用方法\n\n### 1. RabbitTemplate\n用于发送和接收消息的核心模板类。Spring Boot 自动配置了 `RabbitTemplate`。\n\n### 2. @RabbitListener\n声明式地创建消息监听器。Spring Boot 会自动创建消息监听容器（MessageListenerContainer）来管理监听器。\n\n### 3. 声明 Exchange, Queue, Binding\n可以通过在 `@Configuration` 类中定义 `Queue`, `Exchange`, `Binding` 的 Bean 来自动在 RabbitMQ Broker 上创建这些组件。\n\n```java\n@Bean\npublic TopicExchange topicExchange() {\n    return new TopicExchange(&quot;app.topic&quot;);\n}\n\n@Bean\npublic Binding binding(Queue myQueue, TopicExchange topicExchange) {\n    return BindingBuilder.bind(myQueue).to(topicExchange).with(&quot;routing.key.#&quot;);\n}\n```\n\n### 4. 消息确认 (Confirms &amp; Returns)\n支持生产者确认（Publisher Confirms）和退回（Returns），确保消息可靠投递到 Broker。\n\n### 5. JSON 消息转换\n支持自动将 Java 对象与 JSON 消息进行转换（需要配置 `Jackson2JsonMessageConverter`）。\n\n## 常用配置文件\n\n在 `application.yml` 中配置 RabbitMQ：\n\n```yaml\nspring:\n  rabbitmq:\n    host: localhost\n    port: 5672\n    username: user\n    password: password\n    virtual-host: /myvhost\n    \n    # 生产者确认模式 (CORRELATED 表示异步确认)\n    publisher-confirms: true\n    # 消息无法路由时退回给生产者\n    publisher-returns: true\n\n    listener:\n      simple:\n        # 消费者确认模式 (AUTO: 自动确认, MANUAL: 手动确认)\n        acknowledge-mode: manual\n        # 消费者并发数\n        concurrency: 5\n        # 最大并发数\n        max-concurrency: 10\n        # 预取消息数 (QoS)\n        prefetch: 1\n```\n\n## 注意事项\n\n- **前置条件**：需要一个正在运行的 RabbitMQ Broker。\n- **消息序列化**：默认使用 Java 序列化。在生产环境中，推荐配置 `Jackson2JsonMessageConverter` 使用 JSON 格式，以实现跨语言和更好的可读性。\n\n  ```java\n  @Bean\n  public MessageConverter jsonMessageConverter() {\n      return new Jackson2JsonMessageConverter();\n  }\n  // RabbitTemplate 需要配置此 Converter\n  ```\n\n- **消费者确认 (Ack)**：\n  - `AUTO` (默认)：消费者收到消息后自动确认。如果处理失败，消息会丢失。\n  - `MANUAL`：需要在代码中手动调用 `channel.basicAck()` 或 `basicNack()`。适用于需要确保消息成功处理的场景。\n- **连接池**：在高并发场景下，需要调整连接工厂的缓存配置 (`spring.rabbitmq.cache.*`)。\n\n## 常用注解\n\n- `@EnableRabbit`：启用 RabbitMQ 注解驱动功能（Spring Boot 自动配置通常会启用）。\n- `@RabbitListener`：监听队列或交换机，用于消费者方法。\n- `@RabbitHandler`：用于在类级别 `@RabbitListener` 中根据消息类型分发到不同的处理方法。\n- `@Queue`, `@Exchange`, `@QueueBinding`：在 `@RabbitListener` 中用于声明和绑定队列与交换机。\n\n## 常见问题排查\n\n### 1. 连接 RabbitMQ 失败\n**问题**：启动时报 `Connection refused` 或认证失败。\n**原因**：RabbitMQ Broker 未运行，或主机、端口、用户名、密码配置错误。\n**解决**：检查 `spring.rabbitmq.*` 配置，并确保 RabbitMQ 服务可用。\n\n### 2. 消息发送成功但消费者未收到\n**原因**：\n1. 生产者发送的 Routing Key 与队列绑定不匹配。\n2. 消费者监听的队列名称错误。\n3. 消费者配置了手动确认（`MANUAL`）但未调用 `basicAck()`。\n\n**解决**：\n- 检查 RabbitMQ 管理界面，确认 Exchange、Queue 和 Binding 配置。\n- 确保消费者的 `acknowledge-mode` 配置正确。\n\n### 3. 消息反序列化失败 (JSON)\n**问题**：消费者收到消息但抛出反序列化异常。\n**原因**：生产者和消费者使用的消息转换器不一致，或者 JSON 结构与目标 Java 类型不匹配。\n**解决**：\n- 确保生产者和消费者都配置了 `Jackson2JsonMessageConverter`。\n- 检查 `@RabbitListener` 方法参数的类型是否与发送的消息匹配。\n\n### 4. 消息重复消费\n**原因**：消费者处理消息失败（抛出异常）且配置为自动确认（`AUTO`）或手动确认时调用了 `basicNack(requeue=true)`。\n**解决**：\n- 确保消息处理逻辑是幂等的。\n- 使用手动确认模式，并在处理失败时根据情况选择 `basicNack(requeue=false)`（丢弃或移入死信队列）。"
  },
  {
    "name": "spring-boot-starter-batch",
    "summary": "提供 Spring Batch 支持，用于构建健壮的批处理应用程序，适合处理大数据量、ETL 任务和定时作业。",
    "notes": "# spring-boot-starter-batch\n\n## 示例\n\n### 添加依赖\n在 Maven 项目的 `pom.xml` 中添加 `spring-boot-starter-batch` 和数据库依赖（用于存储批处理元数据）：\n\n```xml\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-batch&lt;/artifactId&gt;\n&lt;/dependency&gt;\n&lt;!-- 批处理元数据需要数据库存储，例如 H2 --&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;com.h2database&lt;/groupId&gt;\n    &lt;artifactId&gt;h2&lt;/artifactId&gt;\n    &lt;scope&gt;runtime&lt;/scope&gt;\n&lt;/dependency&gt;\n```\n\n### 配置批处理任务 (Job)\n\n```java\nimport org.springframework.batch.core.Job;\nimport org.springframework.batch.core.Step;\nimport org.springframework.batch.core.configuration.annotation.EnableBatchProcessing;\nimport org.springframework.batch.core.job.builder.JobBuilder;\nimport org.springframework.batch.core.repository.JobRepository;\nimport org.springframework.batch.core.step.builder.StepBuilder;\nimport org.springframework.batch.item.ItemProcessor;\nimport org.springframework.batch.item.ItemReader;\nimport org.springframework.batch.item.ItemWriter;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.transaction.PlatformTransactionManager;\n\n@Configuration\n@EnableBatchProcessing // Spring Boot 3.x 中可能不再需要\npublic class BatchConfig {\n\n    // 示例 Reader (简化)\n    @Bean\n    public ItemReader&lt;String&gt; reader() {\n        // 实际应从文件或数据库读取\n        return new ListItemReader&lt;&gt;(Arrays.asList(&quot;item1&quot;, &quot;item2&quot;, &quot;item3&quot;));\n    }\n\n    // 示例 Processor\n    @Bean\n    public ItemProcessor&lt;String, String&gt; processor() {\n        return item -&gt; item.toUpperCase();\n    }\n\n    // 示例 Writer\n    @Bean\n    public ItemWriter&lt;String&gt; writer() {\n        return items -&gt; items.forEach(System.out::println);\n    }\n\n    // 定义 Step (Spring Boot 3.x 语法)\n    @Bean\n    public Step myStep(JobRepository jobRepository, PlatformTransactionManager transactionManager) {\n        return new StepBuilder(&quot;myStep&quot;, jobRepository)\n                .&lt;String, String&gt;chunk(10, transactionManager) // 块处理，每次 10 条\n                .reader(reader())\n                .processor(processor())\n                .writer(writer())\n                .build();\n    }\n\n    // 定义 Job\n    @Bean\n    public Job myJob(JobRepository jobRepository, Step myStep) {\n        return new JobBuilder(&quot;myJob&quot;, jobRepository)\n                .start(myStep)\n                .build();\n    }\n}\n```\n\n## 解决的问题\n\n`spring-boot-starter-batch` 解决了大规模数据处理和批处理任务中的复杂性问题：\n\n- **大数据量处理**：提供块处理（Chunk-oriented processing）机制，有效处理大量数据而不耗尽内存。\n- **健壮性和可靠性**：支持事务管理、失败重试（Retry）和跳过（Skip）机制。\n- **可追溯和可管理性**：将批处理的元数据（Job执行状态、Step进度等）持久化到数据库，便于监控和管理。\n- **可重启性**：如果批处理中断，可以从上次失败的地方恢复执行。\n- **自动化配置**：Spring Boot 自动配置 JobRepository、JobLauncher 和必要的数据库表结构。\n\n## 核心功能与使用方法\n\nSpring Batch 的核心概念包括 Job, Step, Reader, Processor, Writer。\n\n### 1. Job 和 Step\n- **Job**：一个完整的批处理任务。\n- **Step**：Job 的一个独立阶段。一个 Job 可以包含一个或多个 Step。\n\n### 2. 块处理 (Chunk Processing)\nStep 通常采用块处理模式：\n- **ItemReader**：读取数据（例如从文件、数据库）。\n- **ItemProcessor**（可选）：处理数据（转换、过滤）。\n- **ItemWriter**：写入数据（例如到数据库、文件）。\n\n数据被分块读取、处理和写入，每个块在一个事务中完成。\n\n### 3. Job Repository\n用于存储批处理执行的元数据（如 JobInstance, JobExecution, StepExecution）。Spring Boot 会自动配置它连接到应用的数据源。\n\n### 4. Job Launcher\n用于启动 Job。Spring Boot 默认在应用启动时执行所有找到的 Job（可以通过配置关闭）。\n\n## 常用配置文件\n\n在 `application.yml` 中配置 Spring Batch：\n\n```yaml\nspring:\n  datasource:\n    # 批处理元数据需要数据库支持\n    url: jdbc:h2:mem:testdb\n    driverClassName: org.h2.Driver\n  jpa:\n    # 确保JPA不会与Batch的表初始化冲突（如果同时使用JPA）\n    hibernate:\n      ddl-auto: none\n\n  batch:\n    job:\n      # 启动时是否自动运行所有 Job (默认为 true)。生产中常设为 false，通过调度器触发。\n      enabled: false \n    jdbc:\n      # 启动时初始化数据库表结构 (默认为 EMBEDDED)。可选 ALWAYS, NEVER。\n      initialize-schema: ALWAYS\n      # 数据库表前缀 (默认为 BATCH_)\n      table-prefix: BATCH_\n```\n\n## 注意事项\n\n- **数据库依赖**：Spring Batch 必须依赖一个数据库来存储 Job 的执行元数据。需要添加相应的 JDBC 驱动和 `spring-boot-starter-data-jpa` 或 `spring-boot-starter-jdbc`。\n- **Spring Boot 2 vs 3**：\n  - Spring Boot 2 使用 `JobBuilderFactory` 和 `StepBuilderFactory`（已废弃）。\n  - Spring Boot 3（Spring Batch 5）使用新的 `JobBuilder` 和 `StepBuilder` API，并且 `@EnableBatchProcessing` 的作用发生了变化（现在用于显式配置，而不是简单启用）。\n- **Job 自动执行**：默认情况下，Spring Boot 会在启动时执行应用中定义的所有 Job。在生产环境中，通常设置 `spring.batch.job.enabled=false`，并通过调度器（如 Quartz）或外部命令手动触发 Job。\n- **事务管理**：确保配置了 `PlatformTransactionManager`。Spring Boot 会自动配置。\n\n## 常用注解\n\n- `@EnableBatchProcessing`：启用 Spring Batch 功能并提供基础配置。\n- `@JobScope`, `@StepScope`：用于延迟初始化 Bean，直到 Job 或 Step 执行时才创建，可以访问 Job/Step 的上下文参数。\n\n## 常见问题排查\n\n### 1. 启动时找不到 Batch 元数据表\n**问题**：启动报错，提示 `BATCH_JOB_INSTANCE` 等表不存在。\n**原因**：数据库未初始化 Spring Batch 所需的表结构。\n**解决**：设置 `spring.batch.jdbc.initialize-schema=ALWAYS` 或 `EMBEDDED`（对于嵌入式数据库），让 Spring Boot 自动创建表。或者手动执行 Spring Batch 提供的 DDL 脚本。\n\n### 2. Job 在应用启动时自动运行\n**问题**：不希望 Job 在应用启动时就执行。\n**解决**：在 `application.yml` 中设置 `spring.batch.job.enabled=false`。然后通过 `JobLauncher` 手动或定时触发 Job。\n\n### 3. 并发执行 Job 问题\n**问题**：同一个 Job 实例被并发执行导致数据冲突。\n**解决**：Spring Batch 默认不允许同一个 Job 实例（相同参数）同时运行。如果需要并发执行不同的 Job 实例，确保 `JobLauncher` 配置为异步执行。\n\n### 4. 内存溢出 (OutOfMemoryError)\n**问题**：处理大数据量时发生 OOM。\n**原因**：块大小（Chunk size）设置过大，或者 Reader/Writer 实现不当导致对象堆积。\n**解决**：减小 `chunk()` 的大小。确保 Reader 实现了流式读取（如 `JdbcCursorItemReader`），而不是一次性加载所有数据。"
  },
  {
    "name": "spring-boot-starter-data-elasticsearch",
    "summary": "提供对 Elasticsearch 的集成支持，通过 Spring Data 简化索引、搜索和分析操作，适用于全文检索和日志分析场景。",
    "notes": "# spring-boot-starter-data-elasticsearch\n\n## 示例\n\n### 添加依赖\n在 Maven 项目的 `pom.xml` 中添加依赖：\n\n```xml\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-data-elasticsearch&lt;/artifactId&gt;\n&lt;/dependency&gt;\n```\n\n### 配置 Elasticsearch 连接\n在 `application.yml` 中配置 (Spring Boot 3.x)：\n\n```yaml\nspring:\n  elasticsearch:\n    uris: http://localhost:9200\n    # 如果启用了安全认证\n    # username: elastic\n    # password: password\n```\n\n### 创建文档实体 (Document)\n\n```java\nimport org.springframework.data.annotation.Id;\nimport org.springframework.data.elasticsearch.annotations.Document;\nimport org.springframework.data.elasticsearch.annotations.Field;\nimport org.springframework.data.elasticsearch.annotations.FieldType;\n\n@Document(indexName = &quot;products&quot;)\npublic class Product {\n\n    @Id\n    private String id;\n\n    @Field(type = FieldType.Text, analyzer = &quot;standard&quot;)\n    private String name;\n\n    @Field(type = FieldType.Double)\n    private Double price;\n    \n    // Getters and Setters\n}\n```\n\n### 创建 Repository\n\n```java\nimport org.springframework.data.elasticsearch.repository.ElasticsearchRepository;\n\npublic interface ProductRepository extends ElasticsearchRepository&lt;Product, String&gt; {\n    List&lt;Product&gt; findByName(String name);\n}\n```\n\n### 使用 Repository\n\n```java\n@Service\npublic class ProductService {\n    @Autowired\n    private ProductRepository repository;\n\n    public Product saveProduct(Product product) {\n        return repository.save(product);\n    }\n\n    public List&lt;Product&gt; searchByName(String name) {\n        return repository.findByName(name);\n    }\n}\n```\n\n## 解决的问题\n\n`spring-boot-starter-data-elasticsearch` 简化了在 Spring Boot 应用中集成和使用 Elasticsearch 的过程，解决了：\n\n- **全文检索和复杂查询**：提供对 Elasticsearch 强大搜索能力的便捷访问。\n- **简化数据访问**：利用 Spring Data Repository 抽象，减少了编写 CRUD 和查询的样板代码。\n- **对象文档映射 (ODM)**：自动将 Java 对象映射到 Elasticsearch 文档（JSON）。\n- **自动化配置**：Spring Boot 自动配置 Elasticsearch 客户端（Java Client）和 `ElasticsearchRestTemplate` / `ReactiveElasticsearchTemplate`。\n\n## 核心功能与使用方法\n\n### 1. Elasticsearch Repositories\n通过继承 `ElasticsearchRepository`，可以获得开箱即用的 CRUD 和基本查询功能。\n\n### 2. ElasticsearchRestTemplate / ReactiveElasticsearchTemplate\n提供更底层的模板 API，用于执行复杂查询、聚合操作或索引管理。\n\n```java\n@Autowired\nprivate ElasticsearchRestTemplate elasticsearchTemplate;\n\npublic List&lt;Product&gt; search(String keyword) {\n    Query query = NativeQuery.builder()\n        .withQuery(q -&gt; q.match(m -&gt; m.field(&quot;name&quot;).query(keyword)))\n        .build();\n    \n    SearchHits&lt;Product&gt; searchHits = elasticsearchTemplate.search(query, Product.class);\n    // ... 处理结果\n}\n```\n\n### 3. 文档映射注解\n使用 `@Document`, `@Field` 等注解定义索引名称、字段类型、分析器等。\n\n## 版本与依赖管理\n\n版本由 `spring-boot-starter-parent` 统一管理。查看最新版本：[Maven 中央仓库](https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-data-elasticsearch)。\n\n## 常用配置文件\n\n在 `application.yml` 中配置 (Spring Boot 3.x)：\n\n```yaml\nspring:\n  elasticsearch:\n    # Elasticsearch 集群地址\n    uris: http://localhost:9200,http://localhost:9201\n    # 连接超时\n    connection-timeout: 2s\n    # Socket 超时\n    socket-timeout: 1s\n    # 安全认证 (如果需要)\n    username: elastic\n    password: changeme\n    # SSL 配置 (如果使用 HTTPS)\n    ssl:\n      verification-mode: none # 或 full, certificate\n```\n\n## 注意事项\n\n- **客户端变化 (重要)**：\n  - Spring Boot 2.x 早期版本默认使用 High-Level REST Client (HLRC)。\n  - Elasticsearch 7.15 宣布废弃 HLRC，推荐使用新的 Java Client。\n  - Spring Boot 3.x 和 Spring Data Elasticsearch 5.x 完全移除了 HLRC 支持，仅支持新的 Java Client。迁移时需要注意 API 的变化。\n- **前置条件**：需要一个正在运行的 Elasticsearch 集群。\n- **版本兼容性**：确保 `spring-boot-starter-data-elasticsearch` 的版本与 Elasticsearch 服务器的版本兼容。Spring Boot 3.x 通常与 Elasticsearch 8.x 配合使用。\n- **索引管理**：Spring Data Elasticsearch 可以在启动时自动创建索引和映射，但在生产环境中，建议手动管理索引生命周期和映射。\n\n## 常用注解\n\n- `@Document`：标记实体类，指定索引名称 (`indexName`)。\n- `@Id`：标记文档 ID。\n- `@Field`：配置字段映射，包括类型 (`FieldType`)、分析器 (`analyzer`) 等。\n- `@Setting`：配置索引设置（如分片数、副本数）。\n\n## 常见问题排查\n\n### 1. 连接 Elasticsearch 失败\n**问题**：启动时报连接超时或拒绝连接。\n**原因**：Elasticsearch 集群未运行，或 `spring.elasticsearch.uris` 配置错误。\n**解决**：检查 Elasticsearch 状态和网络连接配置。\n\n### 2. SSL/TLS 握手失败 (HTTPS)\n**问题**：连接启用了 HTTPS 的 Elasticsearch 时报 SSL 错误。\n**原因**：客户端不信任 Elasticsearch 的证书。\n**解决**：\n- 配置 `spring.elasticsearch.ssl.verification-mode`（开发环境可设为 `none`，但不安全）。\n- 将 Elasticsearch 的 CA 证书导入到 JVM 的信任库中。\n\n### 3. 字段映射错误\n**问题**：查询结果不正确或索引数据时报错。\n**原因**：Java 字段类型与 Elasticsearch 索引映射不匹配，或者分析器配置错误。\n**解决**：检查 `@Field` 注解配置。如果修改了映射，可能需要重新创建索引（Reindex）。\n\n### 4. Spring Boot 2.x 升级到 3.x\n**问题**：High-Level REST Client (HLRC) 相关的类找不到。\n**原因**：Spring Boot 3.x 移除了 HLRC 支持。\n**解决**：将使用 HLRC 的代码迁移到新的 Java Client API，或使用更新后的 `ElasticsearchRestTemplate` API。"
  },
  {
    "name": "spring-boot-starter-data-jdbc",
    "summary": "提供对 Spring Data JDBC 的支持，作为 JPA 的轻量级替代品，用于关系型数据库操作，强调简单性和对 SQL 的直接控制。",
    "notes": "# spring-boot-starter-data-jdbc\n\n## 示例\n\n### 添加依赖\n在 Maven 项目的 `pom.xml` 中添加 `spring-boot-starter-data-jdbc` 和数据库驱动：\n\n```xml\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-data-jdbc&lt;/artifactId&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;com.h2database&lt;/groupId&gt;\n    &lt;artifactId&gt;h2&lt;/artifactId&gt;\n    &lt;scope&gt;runtime&lt;/scope&gt;\n&lt;/dependency&gt;\n```\n\n### 配置数据源\n在 `application.yml` 中配置数据库连接：\n\n```yaml\nspring:\n  datasource:\n    url: jdbc:h2:mem:testdb\n    driver-class-name: org.h2.Driver\n    username: sa\n    password: \n```\n\n### 创建实体类\n定义实体，与 JPA 不同，关系通常通过 ID 引用，而不是复杂的对象引用。\n\n```java\nimport org.springframework.data.annotation.Id;\nimport org.springframework.data.relational.core.mapping.Table;\n\n@Table(&quot;users&quot;)\npublic class User {\n    @Id\n    private Long id;\n    private String name;\n\n    // Getters and Setters\n}\n```\n\n### 创建 Repository\n定义数据访问接口，继承 `CrudRepository`。\n\n```java\nimport org.springframework.data.repository.CrudRepository;\n\npublic interface UserRepository extends CrudRepository&lt;User, Long&gt; {\n    List&lt;User&gt; findByName(String name);\n}\n```\n\n## 解决的问题\n\n`spring-boot-starter-data-jdbc` 为那些认为 JPA/Hibernate 过于复杂或“魔法”太多的开发者提供了一个更简单的选择：\n\n- **简化 ORM**：提供基本的对象关系映射，避免了 JPA 的复杂性，如懒加载、会话管理和复杂的级联操作。\n- **明确的数据操作**：开发者对 SQL 的执行有更清晰的认知。没有“自动”的脏检查和 flush。\n- **聚合根导向**：鼓励面向领域驱动设计（DDD）中的聚合根概念，只为聚合根创建 Repository。\n- **性能可控**：由于没有复杂的代理和缓存机制，性能行为更加直接和可预测。\n\n## 核心功能与使用方法\n\n### 1. CrudRepository 和 PagingAndSortingRepository\n提供基本的 CRUD 和分页排序功能，与 Spring Data JPA 类似。\n\n### 2. 基于聚合的设计\nSpring Data JDBC 的核心思想是围绕聚合（Aggregate）进行设计。一个 Repository 对应一个聚合根。对聚合的修改是整体性的 `save` 操作，而不是部分更新。\n\n### 3. JdbcTemplate 集成\n自动配置 `JdbcTemplate` 和 `NamedParameterJdbcTemplate`，方便执行自定义的 SQL 查询。\n\n```java\n@Autowired\nprivate NamedParameterJdbcTemplate jdbcTemplate;\n\npublic int countUsersByName(String name) {\n    SqlParameterSource params = new MapSqlParameterSource(&quot;name&quot;, name);\n    return jdbcTemplate.queryForObject(&quot;SELECT count(*) FROM users WHERE name = :name&quot;, params, Integer.class);\n}\n```\n\n### 4. 自动化的表和列名映射\n- 默认情况下，类名 `User` 映射到表名 `user`。\n- 属性名 `userName` 映射到列名 `user_name`。\n- 可以通过 `@Table` 和 `@Column` 注解自定义。\n\n## 版本与依赖管理\n\n版本由 `spring-boot-starter-parent` 统一管理。查看最新版本：[Maven 中央仓库](https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-data-jdbc)。\n\n## 常用配置文件\n\n配置与 `spring-boot-starter-data-jpa` 类似，主要集中在 `spring.datasource`。\n\n```yaml\nspring:\n  datasource:\n    url: jdbc:mysql://localhost:3306/mydb\n    username: root\n    password: password\n    driver-class-name: com.mysql.cj.jdbc.Driver\n  # Spring Data JDBC 没有像 JPA ddl-auto 这样的复杂模式管理，\n  # 通常需要手动或通过 Flyway/Liquibase 管理数据库 schema\n```\n\n## 注意事项\n\n- **非完整 ORM**：它不是一个功能完整的 ORM。不支持懒加载、级联删除、二级缓存等 JPA 特性。\n- **Schema 管理**：Spring Data JDBC 不负责数据库模式的创建和更新。推荐使用 Flyway 或 Liquibase 进行数据库迁移。\n- **更新操作**：`save` 方法执行的是 `UPDATE` 语句，会更新聚合根的所有字段，而不是只更新变化的字段。\n- **前置条件**：需要一个 JDBC 驱动依赖。\n\n## 常用注解\n\n- `@Table`：指定实体类映射的数据库表名。\n- `@Column`：指定属性映射的数据库列名。\n- `@Id`：标记主键。\n- `@MappedCollection`：用于定义一对多关系，其中子实体被视为聚合的一部分。\n\n## 常见问题排查\n\n### 1. 数据库连接失败\n**原因**：与 JPA 相同，通常是 `spring.datasource` 配置错误或数据库服务不可用。\n**解决**：检查数据源配置和数据库状态。\n\n### 2. 找不到表或列 (Table/Column Not Found)\n**原因**：实体类名/属性名与数据库表/列名不匹配，且未通过注解自定义。\n**解决**：\n- 确保命名约定一致（例如，`userName` -&gt; `user_name`）。\n- 使用 `@Table` 和 `@Column` 注解显式指定名称。\n\n### 3. 如何处理一对多关系？\n**原因**：Spring Data JDBC 的关系处理方式与 JPA 不同。\n**解决**：使用 `@MappedCollection` 注解。例如，一个 `Order` 聚合根可以包含一个 `Set&lt;OrderItem&gt;`。`OrderItem` 表需要一个外键指向 `Order`。\n\n```java\n@Table(&quot;orders&quot;)\nclass Order {\n    @Id private Long id;\n    @MappedCollection(idColumn = &quot;order_id&quot;)\n    private Set&lt;OrderItem&gt; items;\n}\n```\n\n### 4. 如何执行自定义复杂查询？\n**原因**：方法名派生查询功能有限。\n**解决**：直接注入并使用 `JdbcTemplate` 或 `NamedParameterJdbcTemplate` 来编写和执行原生 SQL。"
  },
  {
    "name": "spring-boot-starter-data-rest",
    "summary": "自动将 Spring Data Repositories 暴露为 RESTful API，提供 HATEOAS 支持，极大减少编写 CRUD Controller 的样板代码。",
    "notes": "# spring-boot-starter-data-rest\n\n## 示例\n\n### 添加依赖\n在 `pom.xml` 中添加 `spring-boot-starter-data-rest`。通常需要与一个 Spring Data 模块（如 JPA）一起使用。\n\n```xml\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-data-rest&lt;/artifactId&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;com.h2database&lt;/groupId&gt;\n    &lt;artifactId&gt;h2&lt;/artifactId&gt;\n    &lt;scope&gt;runtime&lt;/scope&gt;\n&lt;/dependency&gt;\n```\n\n### 创建实体和 Repository\n```java\n@Entity\npublic class User {\n    @Id @GeneratedValue\n    private Long id;\n    private String name;\n    // Getters and setters\n}\n\n// 无需任何代码，此 Repository 将被自动暴露为 REST API\npublic interface UserRepository extends JpaRepository&lt;User, Long&gt; {}\n```\n\n### 自动生成的 API\n启动应用后，Spring Data REST 会自动创建以下端点：\n- `GET /users`：获取所有用户列表（支持分页和排序）。\n- `POST /users`：创建一个新用户。\n- `GET /users/{id}`：获取单个用户。\n- `PUT /users/{id}`：更新用户。\n- `DELETE /users/{id}`：删除用户。\n\n## 解决的问题\n\n`spring-boot-starter-data-rest` 旨在解决为数据实体编写大量重复的 RESTful CRUD Controller 的问题：\n\n- **快速原型开发**：在几分钟内为数据模型创建一个功能完整的 REST API。\n- **减少样板代码**：无需编写任何 Controller 或 Service 代码即可实现标准的 CRUD 操作。\n- **标准化 API**：自动生成的 API 遵循 REST 和 HATEOAS 原则，提供一致的接口风格。\n- **与数据层解耦**：API 直接建立在 Repository 之上，开发者只需关注数据模型和仓库接口。\n\n## 核心功能与使用方法\n\n### 1. 自动端点暴露\n自动扫描所有 `Repository` 接口并为其生成 REST 端点。端点路径默认基于实体类的复数形式（例如 `User` -&gt; `/users`）。\n\n### 2. HATEOAS 支持\n响应中自动包含 `_links` 字段，提供相关资源的链接，增强 API 的可发现性。\n\n### 3. 分页和排序\n通过 URL 参数自动支持分页和排序：\n- `GET /users?page=0&amp;size=10`\n- `GET /users?sort=name,desc`\n\n### 4. 查询方法暴露\nRepository 中定义的查询方法也会被自动暴露为 REST 端点。例如：\n`List&lt;User&gt; findByName(String name);` -&gt; `GET /users/search/findByName?name=John`\n\n### 5. 自定义路径和暴露行为\n使用 `@RepositoryRestResource` 注解可以自定义 API 的路径和暴露行为。\n\n```java\n@RepositoryRestResource(path = &quot;people&quot;, collectionResourceRel = &quot;people&quot;)\npublic interface UserRepository extends JpaRepository&lt;User, Long&gt; {}\n// 端点变为 /people\n\n@RepositoryRestResource(exported = false)\npublic interface InternalRepository extends JpaRepository&lt;InternalData, Long&gt; {}\n// 此 Repository 不会生成 REST API\n```\n\n## 常用配置文件\n\n在 `application.yml` 中配置 Spring Data REST 的行为：\n\n```yaml\nspring:\n  data:\n    rest:\n      # API 的基础路径，例如 /api\n      base-path: /api\n      # 默认分页大小\n      default-page-size: 20\n      # 返回的 JSON 中是否包含实体本身（除了链接）\n      return-body-on-create: true\n      return-body-on-update: true\n```\n\n## 注意事项\n\n- **安全性**：默认情况下，Spring Data REST 会暴露 Repository 的所有方法，包括 `delete`。在生产环境中，必须结合 Spring Security 来保护这些端点，限制未授权的访问和操作。\n- **业务逻辑**：Spring Data REST 适合简单的 CRUD 场景。对于复杂的业务逻辑，仍然需要编写自定义的 Controller。\n- **事务性**：所有操作都在事务中执行。\n- **依赖**：需要 `spring-boot-starter-web` 和一个 Spring Data 模块（如 JPA, MongoDB 等）。\n\n## 常用注解\n\n- `@RepositoryRestResource`：自定义 Repository 暴露为 REST 资源的行为，如路径 (`path`)、关系名称 (`rel`)、是否暴露 (`exported`)。\n\n## 常见问题排查\n\n### 1. 端点返回 404 Not Found\n**原因**：\n1. `spring-boot-starter-data-rest` 依赖未添加。\n2. Repository 接口未被 Spring 扫描到。\n3. Repository 使用了 `@RepositoryRestResource(exported = false)`。\n\n**解决**：检查依赖、包扫描路径和注解配置。\n\n### 2. 如何自定义 JSON 输出？\n**问题**：希望隐藏某些字段或改变 JSON 结构。\n**解决**：\n- 使用 `@JsonIgnore` 等 Jackson 注解在实体类上控制序列化。\n- 使用投影（Projections）：定义一个接口，只包含需要暴露的字段，并在请求时通过 `projection` 参数指定。\n\n  ```java\n  interface UserSummary {\n      String getName();\n  }\n  // GET /users?projection=userSummary\n  ```\n\n### 3. 如何保护 API？\n**问题**：API 默认是开放的，任何人都可以删除数据。\n**解决**：\n- 集成 `spring-boot-starter-security`。\n- 覆盖 Repository 的 `delete` 方法并添加 `@PreAuthorize` 注解。\n- 配置 SecurityFilterChain 来限制对特定 HTTP 方法和路径的访问。\n\n### 4. 如何添加自定义业务逻辑？\n**问题**：需要在保存实体前进行校验或处理。\n**解决**：使用事件监听器。可以监听 `BeforeCreateEvent`, `AfterSaveEvent` 等事件，并执行自定义逻辑。\n\n```java\n@Component\n@RepositoryEventHandler\npublic class UserEventHandler {\n    @HandleBeforeCreate\n    public void handleUserCreate(User user) {\n        // 在创建用户前执行的逻辑\n    }\n}\n```"
  },
  {
    "name": "spring-boot-starter-freemarker",
    "summary": "提供对 FreeMarker 模板引擎的集成，用于服务端渲染动态 HTML 页面，是 Thymeleaf 的一个强大替代方案。",
    "notes": "# spring-boot-starter-freemarker\n\n## 示例\n\n### 添加依赖\n在 `pom.xml` 中添加 `spring-boot-starter-freemarker` 依赖。\n\n```xml\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-freemarker&lt;/artifactId&gt;\n&lt;/dependency&gt;\n```\n\n### 创建 FreeMarker 模板\n模板文件位于 `src/main/resources/templates/`，后缀为 `.ftl` (FreeMarker Template Language)。\n`src/main/resources/templates/greeting.ftl`:\n\n```html\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n    &lt;title&gt;Greeting&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;h1&gt;Hello, ${name}!&lt;/h1&gt;\n\n    &lt;p&gt;Items:&lt;/p&gt;\n    &lt;ul&gt;\n        &lt;#list items as item&gt;\n            &lt;li&gt;${item}&lt;/li&gt;\n        &lt;/#list&gt;\n    &lt;/ul&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n```\n\n### 创建 Controller\n使用 `@Controller` 返回模板名称，并通过 `Model` 传递数据。\n\n```java\n@Controller\npublic class GreetingController {\n\n    @GetMapping(&quot;/greet&quot;)\n    public String greet(Model model) {\n        model.addAttribute(&quot;name&quot;, &quot;World&quot;);\n        model.addAttribute(&quot;items&quot;, Arrays.asList(&quot;Apple&quot;, &quot;Banana&quot;, &quot;Cherry&quot;));\n        return &quot;greeting&quot;; // 对应 greeting.ftl\n    }\n}\n```\n\n## 解决的问题\n\n`spring-boot-starter-freemarker` 解决了服务端视图渲染的需求，尤其适用于：\n\n- **复杂的视图逻辑**：FreeMarker 提供了强大的模板语言，包括宏、函数和复杂的表达式，适合需要较多显示逻辑的场景。\n- **与 Thymeleaf 不同的选择**：为开发者提供了 Thymeleaf 之外的另一个成熟的模板引擎选项。\n- **自动化配置**：Spring Boot 自动配置了 `FreeMarkerConfigurer`，包括模板加载路径和视图解析器，极大简化了集成工作。\n\n## 核心功能与使用方法\n\n### 1. 自动配置\n引入 Starter 后，Spring Boot 会自动配置 FreeMarker，默认从 `classpath:/templates/` 加载模板文件。\n\n### 2. 与 Spring MVC 集成\n与 `@Controller` 和 `Model` 无缝协作，控制器方法返回的字符串被解析为模板文件名。\n\n### 3. FreeMarker 模板语言 (FTL)\n支持丰富的模板语法：\n- **变量插值**: `${...}`\n- **指令 (Directives)**: `&lt;#if ...&gt;`, `&lt;#list ...&gt;`, `&lt;#include ...&gt;` 等。\n- **宏 (Macros)**: 用于定义可复用的模板片段。\n\n### 4. 静态资源\n静态资源（CSS, JS）的处理方式与 Thymeleaf 相同，默认从 `src/main/resources/static/` 加载。\n\n## 版本与依赖管理\n\n版本由 `spring-boot-starter-parent` 统一管理。查看最新版本：[Maven 中央仓库](https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-freemarker)。\n\n## 常用配置文件\n\n在 `application.yml` 中配置 FreeMarker：\n\n```yaml\nspring:\n  freemarker:\n    # 开发时禁用缓存，以便实时看到模板修改\n    cache: false\n    # 模板文件的前缀路径 (默认为 classpath:/templates/)\n    prefix: classpath:/templates/\n    # 模板文件的后缀 (默认为 .ftl)\n    suffix: .ftl\n    # 字符编码\n    charset: UTF-8\n    # 模板加载器路径\n    template-loader-path: classpath:/templates/\n    # FreeMarker 设置\n    settings:\n      number_format: &#x27;0.##&#x27;\n```\n\n## 注意事项\n\n- **前置条件**：需要 `spring-boot-starter-web` 来提供 MVC 环境。\n- **与 Thymeleaf 的比较**：\n  - **语法**：FreeMarker 的语法更像编程语言，而 Thymeleaf 使用标准的 HTML 属性，更适合“自然模板”。\n  - **性能**：两者性能相当，通常不会成为瓶颈。\n  - **生态**：两者都是成熟的模板引擎，有广泛的社区支持。\n- **开发模式**：在开发时，强烈建议设置 `spring.freemarker.cache: false` 以避免重启应用才能看到模板的改动。\n\n## 常用注解\n\n主要使用标准的 Spring MVC 注解：\n- `@Controller`：标记一个类为 MVC 控制器。\n- `@GetMapping`, `@PostMapping` 等：映射 HTTP 请求。\n- `@ModelAttribute`：将数据添加到全局模型中。\n\n## 常见问题排查\n\n### 1. 模板未找到 (TemplateNotFoundException)\n**原因**：\n1. 模板文件位置不正确或文件名拼写错误。\n2. Controller 返回的视图名称与模板文件名不匹配。\n3. `spring.freemarker.prefix` 或 `spring.freemarker.suffix` 配置错误。\n\n**解决**：\n- 确保模板位于 `src/main/resources/templates/` 目录下。\n- 检查文件名和 Controller 返回的字符串是否一致。\n- 验证 `application.yml` 中的配置。\n\n### 2. FreeMarker 模板解析错误\n**问题**：页面报错，提示 FTL 语法错误。\n**原因**：模板文件中的 FreeMarker 语法不正确，例如变量名错误、指令未正确闭合等。\n**解决**：仔细检查模板文件的语法，参考 FreeMarker 官方文档。\n\n### 3. 静态资源（CSS/JS）无法加载\n**原因**：与模板引擎无关，是 Spring MVC 的静态资源处理问题。\n**解决**：\n- 确保静态资源位于 `src/main/resources/static/` 目录下。\n- 在模板中使用上下文相关的路径引用，例如 `&lt;link href=&quot;/css/style.css&quot; rel=&quot;stylesheet&quot;&gt;`。"
  },
  {
    "name": "spring-boot-starter-graphql",
    "summary": "提供对 GraphQL 的一站式支持，用于构建高效、灵活的 API，允许客户端精确请求所需数据。",
    "notes": "# spring-boot-starter-graphql\n\n## 示例\n\n### 添加依赖\n在 `pom.xml` 中添加 `spring-boot-starter-graphql`。它需要一个 Web Starter（`web` 或 `webflux`）。\n\n```xml\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-graphql&lt;/artifactId&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;\n&lt;/dependency&gt;\n```\n\n### 创建 GraphQL Schema\n在 `src/main/resources/graphql/` 目录下创建 schema 文件，例如 `schema.graphqls`：\n\n```graphql\ntype Query {\n    bookById(id: ID!): Book\n}\n\ntype Book {\n    id: ID!\n    name: String\n    author: Author\n}\n\ntype Author {\n    id: ID!\n    firstName: String\n    lastName: String\n}\n```\n\n### 创建数据获取器 (Controller)\n使用 `@QueryMapping`, `@MutationMapping` 等注解将方法绑定到 schema 中的字段。\n\n```java\nimport org.springframework.graphql.data.method.annotation.Argument;\nimport org.springframework.graphql.data.method.annotation.QueryMapping;\nimport org.springframework.graphql.data.method.annotation.SchemaMapping;\nimport org.springframework.stereotype.Controller;\n\n@Controller\npublic class BookController {\n\n    // 绑定到 Query.bookById\n    @QueryMapping\n    public Book bookById(@Argument String id) {\n        return Book.getById(id);\n    }\n\n    // 绑定到 Book.author 字段\n    @SchemaMapping\n    public Author author(Book book) {\n        return Author.getById(book.getAuthorId());\n    }\n}\n```\n\n## 解决的问题\n\n`spring-boot-starter-graphql` 解决了传统 REST API 在数据交互方面的一些痛点：\n\n- **数据过度获取 (Over-fetching)**：客户端不再需要接收不需要的字段。\n- **数据获取不足 (Under-fetching)**：客户端可以通过单个请求获取多个关联资源，避免多次 API 调用。\n- **强类型 Schema**：GraphQL 的 schema 定义了 API 的能力，充当了服务器和客户端之间的契约。\n- **API 演进**：可以向 schema 添加新字段和类型，而不会影响现有查询。\n\n## 核心功能与使用方法\n\n### 1. 自动配置 GraphQL 端点\n默认在 `/graphql` 路径上创建一个 HTTP 端点来处理 GraphQL 请求。\n\n### 2. Schema 发现\n自动加载 `src/main/resources/graphql/**/*.graphqls` 路径下的所有 schema 文件。\n\n### 3. 注解驱动的控制器\n- `@QueryMapping`：处理 `Query` 类型的操作。\n- `@MutationMapping`：处理 `Mutation` 类型的操作（数据修改）。\n- `@SubscriptionMapping`：处理 `Subscription` 类型的操作（实时数据）。\n- `@SchemaMapping`：为一个类型的特定字段提供数据，常用于解决 N+1 问题。\n\n### 4. GraphiQL UI\n提供一个交互式的浏览器内 IDE，用于测试和探索 GraphQL API。通过配置可以启用。\n\n## 常用配置文件\n\n在 `application.yml` 中配置 GraphQL：\n\n```yaml\nspring:\n  graphql:\n    # GraphQL HTTP 端点的路径\n    path: /graphql\n    # 启用 GraphiQL UI (非常适合开发)\n    graphiql:\n      enabled: true\n      path: /graphiql\n    # schema 文件位置\n    schema:\n      locations: classpath:graphql/\n      file-extensions:\n        - .graphqls\n        - .graphql\n```\n\n## 注意事项\n\n- **Web 依赖**：必须与 `spring-boot-starter-web` 或 `spring-boot-starter-webflux` 一起使用。\n- **N+1 问题**：在解析嵌套对象时，容易出现 N+1 查询问题。需要使用 `DataLoader` 模式来批量获取数据。Spring for GraphQL 提供了对此模式的支持。\n- **错误处理**：Spring for GraphQL 会自动处理异常，并将其格式化为 GraphQL 错误响应。可以自定义 `DataFetcherExceptionResolver` 来控制错误处理逻辑。\n- **安全性**：与 REST API 一样，需要使用 Spring Security 等框架来保护 GraphQL 端点。\n\n## 常用注解\n\n- `@QueryMapping`, `@MutationMapping`, `@SubscriptionMapping`：将方法映射到 schema 中的顶级字段。\n- `@SchemaMapping(typeName=&quot;...&quot;, field=&quot;...&quot;)`：将方法映射到特定类型中的字段。\n- `@Argument`：将 GraphQL 查询中的参数绑定到方法参数。\n\n## 常见问题排查\n\n### 1. 启动时报 Schema 解析错误\n**问题**：`SchemaProblem` 或类似的异常。\n**原因**：GraphQL schema 文件（`.graphqls`）存在语法错误。\n**解决**：仔细检查 schema 文件的语法，确保类型定义、字段和参数都正确无误。\n\n### 2. 访问 `/graphql` 返回 404\n**原因**：\n1. `spring-boot-starter-graphql` 或 Web Starter 依赖缺失。\n2. `spring.graphql.path` 配置被修改，但访问的仍然是旧路径。\n\n**解决**：检查依赖和 `application.yml` 中的路径配置。\n\n### 3. 字段返回 `null` 或报错 “No DataFetcher found”\n**原因**：Spring for GraphQL 找不到为 schema 中某个字段提供数据的方法。\n**解决**：\n- 确保有一个 `@QueryMapping` 或 `@SchemaMapping` 方法与该字段匹配。\n- 对于嵌套对象，如果字段名与 Java Pojo 的 getter 方法不匹配（例如，GraphQL 字段是 `fullName`，而 Pojo 中只有 `getFirstName`），则需要一个 `@SchemaMapping` 来显式提供数据。\n\n### 4. GraphiQL UI 无法访问\n**问题**：访问 `/graphiql` 路径返回 404。\n**原因**：GraphiQL UI 未启用。\n**解决**：在 `application.yml` 中设置 `spring.graphql.graphiql.enabled: true`。"
  },
  {
    "name": "spring-boot-starter-integration",
    "summary": "提供对 Spring Integration 的支持，用于构建基于企业集成模式（EIP）的消息驱动架构，简化系统间的集成。",
    "notes": "# spring-boot-starter-integration\n\n## 示例\n\n### 添加依赖\n在 `pom.xml` 中添加 `spring-boot-starter-integration` 依赖。\n\n```xml\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-integration&lt;/artifactId&gt;\n&lt;/dependency&gt;\n&lt;!-- 示例需要文件适配器 --&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.integration&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-integration-file&lt;/artifactId&gt;\n&lt;/dependency&gt;\n```\n\n### 创建集成流 (Integration Flow)\n使用 Java DSL 定义一个简单的集成流，该流从一个目录读取文件，并打印其内容。\n\n```java\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.integration.dsl.IntegrationFlow;\nimport org.springframework.integration.dsl.Pollers;\nimport org.springframework.integration.file.dsl.Files;\nimport java.io.File;\n\n@Configuration\npublic class FileIntegrationConfig {\n\n    private static final String INPUT_DIR = &quot;/tmp/input&quot;;\n\n    @Bean\n    public IntegrationFlow fileIntegrationFlow() {\n        return IntegrationFlow.from(Files.inboundAdapter(new File(INPUT_DIR)).autoCreateDirectory(true),\n                                  e -&gt; e.poller(Pollers.fixedDelay(5000)))\n                .transform(Files.toStringTransformer())\n                .handle(message -&gt; {\n                    System.out.println(&quot;File content: &quot; + message.getPayload());\n                })\n                .get();\n    }\n}\n```\n\n## 解决的问题\n\n`spring-boot-starter-integration` 旨在解决复杂的系统集成问题，特别是在企业环境中：\n\n- **系统解耦**：通过消息通道连接不同的系统组件（如文件系统、FTP、JMS、AMQP、HTTP），使它们可以独立演进。\n- **实现企业集成模式 (EIP)**：提供了对 EIP（如管道和过滤器、消息路由、转换器、聚合器）的开箱即用实现，简化了集成逻辑的开发。\n- **简化异步处理**：轻松构建消息驱动的异步流程，提高系统的响应性和吞吐量。\n- **自动化配置**：Spring Boot 自动配置了核心的集成组件，如默认的通道和调度器。\n\n## 核心功能与使用方法\n\n### 1. 通道 (Channel)\n消息在集成流中通过通道传递。可以是点对点的 (`DirectChannel`) 或发布-订阅的 (`PublishSubscribeChannel`)。\n\n### 2. 端点 (Endpoint)\n- **消息源 (Inbound Adapter)**：集成流的起点，从外部系统接收消息（如 `Files.inboundAdapter`）。\n- **服务激活器 (Service Activator)**：调用一个方法来处理消息 (`.handle()`)。\n- **转换器 (Transformer)**：转换消息的载荷或头部 (`.transform()`)。\n- **过滤器 (Filter)**：根据条件决定是否传递消息 (`.filter()`)。\n- **路由器 (Router)**：根据消息内容将其发送到不同的通道 (`.route()`)。\n\n### 3. Java DSL\n推荐使用流畅的 Java DSL (`IntegrationFlow` Bean) 来定义集成流程，比传统的 XML 配置更简洁、类型安全。\n\n## 版本与依赖管理\n\n版本由 `spring-boot-starter-parent` 管理。查看最新版本：[Maven 中央仓库](https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-integration)。\n\n## 常用配置文件\n\n大多数配置在 Java DSL 中完成，但可以在 `application.yml` 中调整一些全局行为：\n\n```yaml\nspring:\n  integration:\n    # 全局通道配置\n    channel:\n      auto-create: true\n    # 默认轮询器配置\n    poller:\n      fixed-delay: 1000\n      max-messages-per-poll: 1\n```\n\n## 注意事项\n\n- **模块化依赖**：Spring Integration 是模块化的。除了核心 Starter，你还需要为要集成的特定系统添加相应的模块依赖，如 `spring-integration-ftp`, `spring-integration-jms`, `spring-integration-kafka` 等。\n- **复杂性**：Spring Integration 是一个功能强大的框架，但学习曲线较陡峭。对于简单的任务，可能有更轻量级的解决方案。\n- **事务支持**：支持与事务管理器集成，确保消息处理的原子性。\n\n## 常用注解\n\n- `@EnableIntegration`：启用 Spring Integration 功能（通常由 Spring Boot 自动完成）。\n- `@IntegrationComponentScan`：扫描 `@MessagingGateway` 等集成特定注解。\n- `@MessagingGateway`：定义一个网关接口，作为进入集成流的入口。\n- `@ServiceActivator`, `@Transformer`, `@Filter`, `@Router`：注解驱动的方式定义端点。\n\n## 常见问题排查\n\n### 1. 集成流未启动或未按预期工作\n**原因**：\n1. `IntegrationFlow` Bean 未被正确定义或扫描。\n2. 轮询器（Poller）配置不正确，导致入站适配器未被触发。\n3. 通道或端点之间的连接逻辑错误。\n\n**解决**：\n- 确保配置类上有 `@Configuration`。\n- 仔细检查 `.from()`, `.channel()`, `.handle()` 等方法的连接逻辑。\n- 启用 DEBUG 级别的日志（`logging.level.org.springframework.integration=DEBUG`）以观察消息在流中的传递路径。\n\n### 2. 消息处理失败\n**问题**：消息在流中传递时抛出异常。\n**原因**：转换器逻辑错误、服务激活器方法签名不匹配、或目标系统不可用。\n**解决**：\n- 检查每个端点的输入和输出消息类型。\n- 为集成流配置错误通道 (`errorChannel`)，以统一处理异常情况。\n\n### 3. 内存泄漏或消息堆积\n**原因**：通道容量不足或下游消费者处理速度跟不上，导致消息在通道中堆积。\n**解决**：\n- 对于需要缓冲的通道，使用有界容量的 `QueueChannel`。\n- 监控通道的 `queueSize` 指标。\n- 优化下游消费者的性能或增加并发处理能力。"
  },
  {
    "name": "spring-boot-starter-jersey",
    "summary": "提供对 JAX-RS (Java API for RESTful Web Services) 和其参考实现 Jersey 的支持，作为构建 REST API 的 Spring MVC 替代方案。",
    "notes": "# spring-boot-starter-jersey\n\n## 示例\n\n### 添加依赖\n在 `pom.xml` 中添加 `spring-boot-starter-jersey`。注意，它与 `spring-boot-starter-web` 互斥，不应同时使用。\n\n```xml\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-jersey&lt;/artifactId&gt;\n&lt;/dependency&gt;\n```\n\n### 创建 JAX-RS 资源 (Resource)\n使用 JAX-RS 注解定义 REST 端点。\n\n```java\nimport jakarta.ws.rs.GET;\nimport jakarta.ws.rs.Path;\nimport jakarta.ws.rs.PathParam;\nimport jakarta.ws.rs.Produces;\nimport jakarta.ws.rs.core.MediaType;\nimport org.springframework.stereotype.Component;\n\n@Component\n@Path(&quot;/hello&quot;)\npublic class HelloResource {\n\n    @GET\n    @Path(&quot;/{name}&quot;)\n    @Produces(MediaType.TEXT_PLAIN)\n    public String sayHello(@PathParam(&quot;name&quot;) String name) {\n        return &quot;Hello, &quot; + name;\n    }\n}\n```\n\n### 配置 Jersey\n创建一个继承自 `ResourceConfig` 的类来注册 JAX-RS 资源。\n\n```java\nimport org.glassfish.jersey.server.ResourceConfig;\nimport org.springframework.stereotype.Component;\n\n@Component\npublic class JerseyConfig extends ResourceConfig {\n\n    public JerseyConfig() {\n        // 注册所有 @Path 注解的资源类\n        packages(&quot;com.example.resources&quot;); \n        // 或者手动注册\n        // register(HelloResource.class);\n    }\n}\n```\n\n## 解决的问题\n\n`spring-boot-starter-jersey` 主要为那些熟悉或偏好 JAX-RS 标准的开发者提供了在 Spring Boot 环境中构建 REST API 的能力：\n\n- **遵循 JAX-RS 标准**：提供了一种基于标准规范（JAX-RS）的 Web 开发方式。\n- **替代 Spring MVC**：为不想使用 Spring MVC 的团队提供了另一种成熟的选择。\n- **与 Spring 生态集成**：虽然使用了 Jersey，但仍然可以无缝地使用 Spring 的依赖注入（`@Autowired`）和其他核心功能。\n\n## 核心功能与使用方法\n\n### 1. JAX-RS 注解\n使用 `@Path`, `@GET`, `@POST`, `@Produces`, `@Consumes`, `@PathParam` 等标准 JAX-RS 注解来定义资源和端点。\n\n### 2. ResourceConfig\n通过继承 `ResourceConfig` 并将其注册为 Spring Bean，可以自定义 Jersey 的行为，如注册资源、提供者（Providers）和特性（Features）。\n\n### 3. Spring DI 支持\n可以直接在 JAX-RS 资源类中注入 Spring 的 Bean（`@Autowired`）。\n\n## 版本与依赖管理\n\n版本由 `spring-boot-starter-parent` 管理。查看最新版本：[Maven 中央仓库](https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-jersey)。\n\n## 常用配置文件\n\n在 `application.yml` 中配置 Jersey 的基本行为：\n\n```yaml\nserver:\n  port: 8080\n\nspring:\n  jersey:\n    # type: servlet (默认) 或 filter\n    type: servlet\n    # Jersey 应用的基础路径\n    application-path: /api\n    # Jersey 初始化参数\n    init:\n      jersey.config.server.provider.packages: com.example.resources\n```\n\n## 注意事项\n\n- **与 Spring MVC 互斥**：不要在同一个项目中同时引入 `spring-boot-starter-jersey` 和 `spring-boot-starter-web`，除非你有意将它们映射到不同的路径下，但这会增加复杂性。\n- **Spring Boot 3.x / Jakarta EE**：Spring Boot 3.x 使用 Jakarta EE 9+。因此，需要使用 `jakarta.ws.rs.*` 包下的 JAX-RS 注解，而不是 `javax.ws.rs.*`。\n- **资源注册**：必须通过 `ResourceConfig` Bean 来注册你的资源类，否则它们不会被 Jersey 发现。\n\n## 常用注解 (JAX-RS)\n\n- `@Path`：定义资源类或方法的相对路径。\n- `@GET`, `@POST`, `@PUT`, `@DELETE`：映射 HTTP 方法。\n- `@Produces`：指定响应的媒体类型（Content-Type）。\n- `@Consumes`：指定请求体可接受的媒体类型。\n- `@PathParam`：从 URL 路径中提取参数。\n- `@QueryParam`：从 URL 查询字符串中提取参数。\n- `@HeaderParam`：从 HTTP 头部提取参数。\n\n## 常见问题排查\n\n### 1. 端点返回 404 Not Found\n**原因**：\n1. JAX-RS 资源类没有被 Jersey 发现。\n2. 请求的 URL 路径不正确，可能没有包含 `spring.jersey.application-path` 定义的基础路径。\n3. 资源类没有 `@Path` 注解。\n\n**解决**：\n- 确保 `JerseyConfig` 类正确注册了资源包或资源类。\n- 确认资源类和方法上的 `@Path` 注解正确。\n- 检查请求的完整 URL 是否为 `http://host:port/application-path/resource-path`。\n\n### 2. 依赖注入失败 (`@Autowired` 的 Bean 为 null)\n**原因**：JAX-RS 资源类本身不是一个 Spring Bean，或者 Spring Boot 的组件扫描没有覆盖它。\n**解决**：\n- 在 JAX-RS 资源类上添加 `@Component` 或其他 Spring Stereotype 注解。\n- 确保主应用类的 `@SpringBootApplication` 注解所在的包路径能够扫描到资源类。\n\n### 3. 如何处理异常？\n**问题**：希望返回自定义的错误响应。\n**解决**：创建一个实现了 `ExceptionMapper&lt;T&gt;` 接口的类，并将其注册为提供者。这允许你将一个特定的异常映射到一个 HTTP 响应。\n\n```java\n@Provider // Jersey 会自动发现 @Provider 注解的类\npublic class MyExceptionMapper implements ExceptionMapper&lt;IllegalArgumentException&gt; {\n    @Override\n    public Response toResponse(IllegalArgumentException exception) {\n        return Response.status(Response.Status.BAD_REQUEST)\n                       .entity(exception.getMessage()).build();\n    }\n}\n```"
  },
  {
    "name": "spring-boot-starter-jdbc",
    "summary": "提供对传统 JDBC 的简化支持，通过 `JdbcTemplate` 自动管理连接和资源，是进行底层数据库操作的基础。",
    "notes": "# spring-boot-starter-jdbc\n\n## 示例\n\n### 添加依赖\n在 `pom.xml` 中添加 `spring-boot-starter-jdbc` 和数据库驱动依赖。\n\n```xml\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;com.h2database&lt;/groupId&gt;\n    &lt;artifactId&gt;h2&lt;/artifactId&gt;\n    &lt;scope&gt;runtime&lt;/scope&gt;\n&lt;/dependency&gt;\n```\n\n### 配置数据源\n在 `application.yml` 中配置数据库连接。\n\n```yaml\nspring:\n  datasource:\n    url: jdbc:h2:mem:testdb\n    driver-class-name: org.h2.Driver\n    username: sa\n    password: \n```\n\n### 使用 JdbcTemplate\nSpring Boot 会自动配置一个 `JdbcTemplate` Bean，可以直接注入并使用。\n\n```java\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.jdbc.core.JdbcTemplate;\nimport org.springframework.stereotype.Repository;\n\n@Repository\npublic class UserRepository {\n\n    @Autowired\n    private JdbcTemplate jdbcTemplate;\n\n    public int countUsers() {\n        return jdbcTemplate.queryForObject(&quot;SELECT count(*) FROM users&quot;, Integer.class);\n    }\n\n    public int addUser(String name, String email) {\n        return jdbcTemplate.update(&quot;INSERT INTO users (name, email) VALUES (?, ?)&quot;, name, email);\n    }\n}\n```\n\n## 解决的问题\n\n`spring-boot-starter-jdbc` 旨在解决直接使用原生 JDBC API 时的繁琐和易错问题：\n\n- **资源管理**：自动处理数据库连接的获取和释放，避免连接泄漏。\n- **异常处理**：将特定于数据库的 `SQLException` 转换为 Spring 的、与技术无关的 `DataAccessException` 层次结构，使异常处理更清晰。\n- **减少样板代码**：封装了创建 `Statement`、处理 `ResultSet`、循环遍历等重复性代码。\n- **提供基础支持**：是 `spring-boot-starter-data-jpa`、`spring-boot-starter-data-jdbc` 和 `spring-boot-starter-batch` 等更高级数据访问框架的基础。\n\n## 核心功能与使用方法\n\n### 1. JdbcTemplate\n核心类，提供了一系列方法来执行 SQL 查询、更新和存储过程调用。\n- `queryForObject()`: 执行查询并期望返回单个结果。\n- `query()`: 执行查询并使用 `RowMapper` 将结果集的多行映射为对象列表。\n- `update()`: 执行 INSERT, UPDATE, DELETE 操作，返回受影响的行数。\n- `execute()`: 执行任意 SQL，通常用于 DDL 语句。\n\n### 2. NamedParameterJdbcTemplate\n`JdbcTemplate` 的一个变种，允许使用命名参数（如 `:name`）而不是传统的 `?` 占位符，提高了代码的可读性。\n\n### 3. RowMapper\n一个接口，用于将 `ResultSet` 的每一行数据映射到一个 Java 对象。\n\n```java\nclass UserRowMapper implements RowMapper&lt;User&gt; {\n    @Override\n    public User mapRow(ResultSet rs, int rowNum) throws SQLException {\n        User user = new User();\n        user.setId(rs.getLong(&quot;id&quot;));\n        user.setName(rs.getString(&quot;name&quot;));\n        return user;\n    }\n}\n\nList&lt;User&gt; users = jdbcTemplate.query(&quot;SELECT * FROM users&quot;, new UserRowMapper());\n```\n\n## 版本与依赖管理\n\n版本由 `spring-boot-starter-parent` 管理。查看最新版本：[Maven 中央仓库](https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-jdbc)。\n\n## 常用配置文件\n\n配置主要集中在 `spring.datasource`，用于设置数据源信息。\n\n```yaml\nspring:\n  datasource:\n    url: jdbc:mysql://localhost:3306/mydb\n    username: root\n    password: password\n    driver-class-name: com.mysql.cj.jdbc.Driver\n    # 配置连接池 (HikariCP 默认)\n    hikari:\n      connection-timeout: 30000\n      maximum-pool-size: 10\n```\n\n## 注意事项\n\n- **数据源**：Spring Boot 默认使用 HikariCP 作为连接池。如果它在 classpath 上可用，会自动配置。\n- **SQL 注入**：始终使用 `?` 占位符或命名参数来传递参数，绝不要直接拼接字符串来构造 SQL 语句，以防止 SQL 注入攻击。\n- **与 ORM 的关系**：这个 Starter 提供了最底层的数据库访问方式。如果你需要对象关系映射、懒加载等高级功能，应考虑使用 `spring-boot-starter-data-jpa` 或 `spring-boot-starter-data-jdbc`。\n\n## 常用注解\n\n此 Starter 本身没有特定的注解，它主要提供可注入的 Bean（如 `JdbcTemplate`）。通常与 `@Repository`, `@Service`, `@Autowired` 等标准 Spring 注解一起使用。\n\n## 常见问题排查\n\n### 1. 无法获取数据库连接\n**问题**：启动时报 `Failed to obtain a connection from the pool` 或类似的连接错误。\n**原因**：`spring.datasource` 配置不正确（URL、用户名、密码错误），或数据库服务未运行。\n**解决**：仔细核对数据源配置，并确保数据库服务可访问。\n\n### 2. IncorrectResultSizeDataAccessException\n**问题**：调用 `queryForObject()` 时抛出此异常。\n**原因**：该方法期望查询结果不多不少正好是一行。如果查询返回了零行或多于一行，就会抛出此异常。\n**解决**：\n- 如果可能返回多行，请改用 `query()` 方法。\n- 如果可能返回零行，请将查询包装在 `try-catch(EmptyResultDataAccessException)` 块中，或者改用返回 `Optional` 的方法（需要自定义或使用第三方库）。\n\n### 3. SQL 语法错误\n**问题**：`BadSqlGrammarException`。\n**原因**：执行的 SQL 语句本身存在语法问题，或者与所使用的数据库方言不兼容。\n**解决**：\n- 在数据库客户端中直接运行并测试 SQL 语句。\n- 确保 SQL 语法与目标数据库（MySQL, PostgreSQL, Oracle 等）兼容。"
  },
  {
    "name": "spring-boot-starter-kafka",
    "summary": "提供对 Apache Kafka 的无缝集成，用于构建高性能、分布式的事件驱动和流处理应用程序。",
    "notes": "# spring-boot-starter-kafka\n\n## 示例\n\n### 添加依赖\n在 `pom.xml` 中添加 `spring-boot-starter-kafka` 依赖。\n\n```xml\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-kafka&lt;/artifactId&gt;\n&lt;/dependency&gt;\n```\n\n### 配置 Kafka\n在 `application.yml` 中配置 Kafka Broker 地址和消费者组 ID。\n\n```yaml\nspring:\n  kafka:\n    bootstrap-servers: localhost:9092\n    consumer:\n      group-id: my-group\n      auto-offset-reset: earliest\n    producer:\n      key-serializer: org.apache.kafka.common.serialization.StringSerializer\n      value-serializer: org.springframework.kafka.support.serializer.JsonSerializer\n```\n\n### 创建生产者 (Producer)\n使用 `KafkaTemplate` 发送消息。\n\n```java\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.kafka.core.KafkaTemplate;\nimport org.springframework.stereotype.Service;\n\n@Service\npublic class MessageProducer {\n\n    @Autowired\n    private KafkaTemplate&lt;String, Object&gt; kafkaTemplate;\n\n    public void sendMessage(String topic, Object message) {\n        kafkaTemplate.send(topic, message);\n        System.out.println(&quot;Sent message to topic &quot; + topic + &quot;: &quot; + message);\n    }\n}\n```\n\n### 创建消费者 (Consumer)\n使用 `@KafkaListener` 注解创建一个消息监听器。\n\n```java\nimport org.springframework.kafka.annotation.KafkaListener;\nimport org.springframework.stereotype.Component;\n\n@Component\npublic class MessageConsumer {\n\n    @KafkaListener(topics = &quot;my-topic&quot;, groupId = &quot;my-group&quot;)\n    public void listen(String message) {\n        System.out.println(&quot;Received message: &quot; + message);\n    }\n}\n```\n\n## 解决的问题\n\n`spring-boot-starter-kafka` 简化了与 Kafka 的集成，解决了构建现代数据密集型应用的需求：\n\n- **事件驱动架构**：使服务之间可以通过异步事件进行通信，实现高度解耦。\n- **高吞吐量消息传递**：利用 Kafka 的能力处理海量消息，适用于日志收集、指标监控等场景。\n- **流处理**：可以与 Kafka Streams 集成，对实时数据流进行处理和分析。\n- **简化开发**：自动配置了 `KafkaTemplate`、生产者/消费者工厂等核心组件，并通过 `@KafkaListener` 大大简化了消费者的编写。\n\n## 核心功能与使用方法\n\n### 1. KafkaTemplate\n用于发送消息到 Kafka 主题的核心模板类。支持同步和异步发送。\n\n### 2. @KafkaListener\n声明式地创建 Kafka 消费者。Spring Boot 会自动为其创建和管理底层的 `MessageListenerContainer`。\n\n### 3. 序列化与反序列化 (SerDe)\n需要为消息的键和值配置序列化器（生产者）和反序列化器（消费者）。Spring for Kafka 提供了对 JSON 的便捷支持 (`JsonSerializer`, `JsonDeserializer`)。\n\n### 4. 错误处理和重试\n`@KafkaListener` 支持配置重试和死信队列（Dead-Letter Topic, DLT），以处理消费失败的消息。\n\n### 5. 事务支持\n支持 Kafka 事务，可以实现“精确一次”处理语义（Exactly-Once Semantics）。\n\n## 版本与依赖管理\n\n版本由 `spring-boot-starter-parent` 管理。确保其版本与 Kafka Broker 的版本兼容。查看最新版本：[Maven 中央仓库](https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-kafka)。\n\n## 常用配置文件\n\n```yaml\nspring:\n  kafka:\n    bootstrap-servers: kafka1:9092,kafka2:9092\n    consumer:\n      group-id: my-app-group\n      auto-offset-reset: earliest # 从最早的 offset 开始消费\n      key-deserializer: org.apache.kafka.common.serialization.StringDeserializer\n      value-deserializer: org.springframework.kafka.support.serializer.JsonDeserializer\n      properties:\n        # 信任所有包，用于 JSON 反序列化\n        spring.json.trusted.packages: &quot;*&quot;\n    producer:\n      key-serializer: org.apache.kafka.common.serialization.StringSerializer\n      value-serializer: org.springframework.kafka.support.serializer.JsonSerializer\n```\n\n## 注意事项\n\n- **前置条件**：需要一个正在运行的 Kafka 集群和 Zookeeper（对于旧版本 Kafka）。\n- **JSON 序列化**：使用 `JsonSerializer` 和 `JsonDeserializer` 时，消费者端需要配置 `spring.json.trusted.packages` 来信任要反序列化的目标类所在的包，否则会因安全原因失败。\n- **消费者组**：`group-id` 非常重要。同一个组内的消费者会分摊主题分区的消费。改变 `group-id` 会导致从头开始消费（取决于 `auto-offset-reset`）。\n- **幂等性**：消息可能会被重复消费（例如，在消费者失败并恢复后）。消费逻辑应设计为幂等的。\n\n## 常用注解\n\n- `@EnableKafka`：启用 Kafka 注解支持（通常由 Spring Boot 自动完成）。\n- `@KafkaListener`：将一个方法标记为 Kafka 消费者端点。\n- `@KafkaHandler`：用于在类级别的 `@KafkaListener` 中，根据消息载荷类型将消息路由到不同的处理方法。\n\n## 常见问题排查\n\n### 1. 无法连接到 Kafka Broker\n**问题**：启动时报 `Connection refused` 或连接超时。\n**原因**：`spring.kafka.bootstrap-servers` 配置错误，或者 Kafka Broker/网络存在问题。\n**解决**：检查配置的 Kafka 主机和端口，并确认 Kafka 服务正在运行且可访问。\n\n### 2. 消费者不消费消息\n**原因**：\n1. `@KafkaListener` 注解的 `topics` 或 `groupId` 不正确。\n2. 消费者启动时，主题中没有新消息，且 `auto-offset-reset` 设置为 `latest` (默认)。\n3. 消费者的反序列化器配置错误，导致消息在被消费前就因反序列化失败而被跳过。\n\n**解决**：\n- 核对主题名称和消费者组 ID。\n- 将 `auto-offset-reset` 设置为 `earliest` 进行测试。\n- 检查消费者日志中是否有反序列化错误。\n\n### 3. DeserializationException\n**问题**：消费者日志中出现反序列化异常。\n**原因**：生产者使用的序列化器与消费者使用的反序列化器不匹配，或者消息格式与目标 Java 类型不兼容。\n**解决**：\n- 确保生产者和消费者的 SerDe 配置一致。\n- 如果使用 JSON，请检查发送的 JSON 结构是否能正确映射到 `@KafkaListener` 方法参数的 Pojo 类。\n- 确认 `spring.json.trusted.packages` 配置正确。"
  },
  {
    "name": "spring-boot-starter-aop",
    "summary": "集成 Spring AOP 和 AspectJ，用于实现切面编程，简化日志记录、安全控制、事务管理等横切关注点。",
    "notes": "# spring-boot-starter-aop\n\n## 示例\n\n### 添加依赖\n在 Maven 项目的 `pom.xml` 中添加 `spring-boot-starter-aop` 依赖：\n\n```xml\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt;\n&lt;/dependency&gt;\n```\n\n### 创建切面（Aspect）\n创建一个日志切面，在目标方法执行前记录日志：\n\n```java\nimport org.aspectj.lang.JoinPoint;\nimport org.aspectj.lang.annotation.Aspect;\nimport org.aspectj.lang.annotation.Before;\nimport org.aspectj.lang.annotation.Pointcut;\nimport org.springframework.stereotype.Component;\n\n@Aspect\n@Component\npublic class LoggingAspect {\n\n    @Pointcut(&quot;execution(* com.example.service.*.*(..))&quot;)\n    public void serviceMethods() {}\n\n    @Before(&quot;serviceMethods()&quot;)\n    public void logBefore(JoinPoint joinPoint) {\n        String methodName = joinPoint.getSignature().getName();\n        System.out.println(&quot;Executing method: &quot; + methodName);\n    }\n}\n```\n\n## 解决的问题\n\n`spring-boot-starter-aop` 引入了面向切面编程（AOP），用于解决以下问题：\n\n- **代码重复**：将散布在多个模块中的通用功能（如日志、安全、事务）提取出来，形成可重用的切面，避免代码冗余。\n- **业务逻辑耦合**：将横切关注点与核心业务逻辑分离，使业务代码更纯粹、更易于维护。\n- **提高模块化**：通过切面将横切关注点模块化，提升系统的整体设计和可扩展性。\n\n## 核心功能与使用方法\n\n### 1. 定义切面（Aspect）\n使用 `@Aspect` 注解标记一个类为切面，并使用 `@Component` 将其注册为 Spring Bean。\n\n### 2. 定义切点（Pointcut）\n使用 `@Pointcut` 注解和 AspectJ 表达式定义一个切点，用于匹配需要被增强的目标方法（连接点）。\n\n### 3. 定义通知（Advice）\n通知是切面的具体逻辑，在切点匹配的方法执行时触发。常用通知类型包括：\n- `@Before`：在方法执行前运行。\n- `@After`：在方法执行后运行（无论成功或失败）。\n- `@AfterReturning`：在方法成功返回后运行。\n- `@AfterThrowing`：在方法抛出异常后运行。\n- `@Around`：环绕通知，可以控制目标方法的执行，功能最强大。\n\n### 4. 获取连接点信息\n通过 `JoinPoint` 参数可以获取目标方法的签名、参数等信息。\n\n## 版本与依赖管理\n\n- **版本管理**：版本由 `spring-boot-starter-parent` 或 `spring-boot-dependencies` BOM 统一管理。\n- **核心依赖**：自动引入 `spring-aop` 和 `aspectjweaver`。\n\n## 常用配置文件\n\n在 `application.yml` 中配置 AOP 相关行为：\n\n```yaml\nspring:\n  aop:\n    auto: true  # 默认开启AOP\n    proxy-target-class: true # 默认使用CGLIB代理\n```\n\n## 注意事项\n\n- **代理机制**：Spring AOP 基于动态代理实现。默认情况下，如果目标对象实现了接口，使用 JDK 动态代理；如果未实现接口，使用 CGLIB 代理。可通过 `spring.aop.proxy-target-class=true` 强制使用 CGLIB。\n- **方法可见性**：只有 Spring Bean 的 `public` 方法才能被 AOP 增强。\n- **自身调用问题（Self-Invocation）**：在一个 Bean 内部调用自身的其他方法时，AOP 不会生效，因为调用绕过了代理对象。解决方法是注入代理对象自身再进行调用。\n\n## 常用注解\n\n- `@Aspect`：声明一个类为切面。\n- `@Component`：将切面注册为 Spring Bean。\n- `@Pointcut`：定义切点表达式。\n- `@Before`, `@After`, `@Around`, `@AfterReturning`, `@AfterThrowing`：定义不同类型的通知。\n\n## 常见问题排查\n\n### 1. 切面不生效\n**原因**：\n- 切面类未被 Spring 扫描到。\n- 切点表达式错误，未匹配到任何方法。\n- 目标方法非 `public`。\n**排查**：\n- 确保切面类上有 `@Aspect` 和 `@Component` 注解，且所在包被主启动类扫描。\n- 仔细检查 `@Pointcut` 表达式是否正确。\n- 确认目标方法是 `public` 的。\n\n### 2. 自身调用（Self-Invocation）导致 AOP 失效\n**问题**：在一个 Service 方法中调用同类的另一个被 AOP 增强的方法，但 AOP 未生效。\n**原因**：调用的是 `this` 对象，而不是 Spring 代理对象。\n**解决**：\n- 注入自身代理对象：`@Autowired private MyService self;` 然后通过 `self.otherMethod()` 调用。\n- 使用 `AopContext.currentProxy()` 获取当前代理对象。\n\n### 3. `NoClassDefFoundError: org/aspectj/weaver/Advice`\n**原因**：缺少 `aspectjweaver` 依赖。\n**解决**：确保 `spring-boot-starter-aop` 已正确添加到 `pom.xml` 中。"
  },
  {
    "name": "spring-boot-starter-logging",
    "summary": "提供灵活且统一的日志记录功能，默认使用 Logback，并支持 Log4j2 和 JUL，是其他 Starter 的基础依赖。",
    "notes": "# spring-boot-starter-logging\n\n## 示例\n\n### 依赖说明\n`spring-boot-starter-logging` 通常作为其他 Starter（如 `spring-boot-starter-web`）的传递性依赖，无需手动添加。如果你需要切换日志实现（如 Log4j2），则需要手动管理依赖。\n\n### 配置日志\n在 `application.yml` 中配置日志级别、输出文件和格式：\n\n```yaml\nlogging:\n  level:\n    root: INFO\n    org.springframework.web: DEBUG\n    com.example.myapp: TRACE\n  file:\n    name: my-app.log\n    path: /var/log/\n  pattern:\n    console: &quot;%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n&quot;\n    file: &quot;%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n&quot;\n  group:\n    web: org.springframework.web, org.springframework.http\n    db: org.springframework.jdbc, org.hibernate\n\n# 可以按组设置级别\n# logging.level.web: DEBUG\n```\n\n## 解决的问题\n\n`spring-boot-starter-logging` 旨在简化和统一应用日志管理，解决以下问题：\n\n- **日志框架配置繁琐**：自动配置 Logback（默认）、Log4j2 或 JUL，开发者无需编写复杂的 XML 配置文件。\n- **环境隔离**：支持通过 Spring Profiles 为不同环境（开发、测试、生产）设置不同的日志配置。\n- **统一管理**：提供一种通过 `application.properties` 或 `application.yml` 统一管理日志级别、格式和输出目标的方式。\n- **灵活性**：支持切换底层日志实现，并能与 `slf4j` 无缝集成。\n\n## 核心功能与使用方法\n\n### 1. 默认日志实现\nSpring Boot 默认使用 **Logback** 作为日志实现。它提供了高性能和丰富的功能。\n\n### 2. 通过配置文件配置\n- `logging.level.*`：设置特定包或类的日志级别（`TRACE`, `DEBUG`, `INFO`, `WARN`, `ERROR`, `FATAL`, `OFF`）。\n- `logging.file.name` / `logging.file.path`：配置日志文件的名称和路径。\n- `logging.pattern.console` / `logging.pattern.file`：自定义控制台和文件的日志输出格式。\n- `logging.group`：定义日志组，方便统一管理多个包的日志级别。\n\n### 3. 切换日志实现\n如需切换到 **Log4j2**，需在 `pom.xml` 中排除 `spring-boot-starter-logging` 并引入 `spring-boot-starter-log4j2`：\n\n```xml\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;\n    &lt;exclusions&gt;\n        &lt;exclusion&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt;\n        &lt;/exclusion&gt;\n    &lt;/exclusions&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-log4j2&lt;/artifactId&gt;\n&lt;/dependency&gt;\n```\n\n### 4. 高级配置\n如果需要更复杂的配置（如滚动策略、多 appender），可以在 `classpath` 下提供特定于日志框架的配置文件，如 `logback-spring.xml` (Logback) 或 `log4j2-spring.xml` (Log4j2)。Spring Boot 会优先加载这些文件。\n\n## 注意事项\n\n- **传递性依赖**：该 Starter 已被大多数核心 Starter 包含，通常无需显式声明。\n- **配置文件命名**：使用 `logback-spring.xml` 而不是 `logback.xml` 可以利用 Spring Boot 的高级功能，如基于 Profile 的配置。\n- **性能**：在生产环境中，避免将日志级别设置为 `DEBUG` 或 `TRACE`，以免影响性能和产生过多日志。\n\n## 常见问题排查\n\n### 1. 日志配置未生效\n**原因**：\n- 属性名拼写错误，如 `logging.levels` (应为 `logging.level`)。\n- `classpath` 下存在 `logback.xml` 等配置文件，其优先级高于 `application.yml`。\n**排查**：\n- 仔细检查 `application.yml` 中的属性路径和拼写。\n- 检查项目中是否存在 `logback.xml` 或 `log4j2.xml` 等文件。\n\n### 2. 日志文件未创建\n**原因**：应用程序没有在指定路径下创建文件的权限。\n**排查**：\n- 检查 `logging.file.path` 配置的目录是否存在，以及应用的运行用户是否有写入权限。\n- 如果只配置了 `logging.file.name`，日志文件会创建在项目根目录，检查该位置的权限。\n\n### 3. 控制台或文件输出乱码\n**原因**：编码格式不一致。\n**解决**：\n- 确保 IDE、操作系统和日志配置文件的编码均为 `UTF-8`。\n- 在 `application.yml` 中设置 `server.servlet.encoding.charset=UTF-8` 和 `spring.messages.encoding=UTF-8`。\n- 在 JVM 启动参数中添加 `-Dfile.encoding=UTF-8`。"
  },
  {
    "name": "spring-boot-starter-security",
    "summary": "为 Spring Boot 应用提供全面的安全支持，包括身份认证、授权、CSRF 防护和会话管理，实现开箱即用的安全防护。",
    "notes": "# spring-boot-starter-security\n\n## 示例\n\n### 添加依赖\n在 Maven 项目的 `pom.xml` 中添加 `spring-boot-starter-security` 依赖：\n\n```xml\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;\n&lt;/dependency&gt;\n```\n\n### 配置安全规则\n创建一个配置类，定义安全过滤链（SecurityFilterChain）来保护 HTTP 请求：\n\n```java\n@Configuration\n@EnableWebSecurity\npublic class SecurityConfig {\n\n    @Bean\n    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {\n        http\n            .authorizeHttpRequests(authorize -&gt; authorize\n                .requestMatchers(&quot;/public/**&quot;, &quot;/login&quot;).permitAll() // 允许公开访问\n                .requestMatchers(&quot;/api/admin/**&quot;).hasRole(&quot;ADMIN&quot;)   // 需要ADMIN角色\n                .anyRequest().authenticated()                       // 其他任何请求都需要认证\n            )\n            .formLogin(form -&gt; form\n                .loginPage(&quot;/login&quot;) // 自定义登录页面\n                .permitAll()\n            )\n            .logout(logout -&gt; logout.permitAll());\n\n        return http.build();\n    }\n\n    @Bean\n    public UserDetailsService userDetailsService() {\n        UserDetails user = User.withDefaultPasswordEncoder()\n            .username(&quot;user&quot;)\n            .password(&quot;password&quot;)\n            .roles(&quot;USER&quot;)\n            .build();\n        UserDetails admin = User.withDefaultPasswordEncoder()\n            .username(&quot;admin&quot;)\n            .password(&quot;password&quot;)\n            .roles(&quot;ADMIN&quot;)\n            .build();\n        return new InMemoryUserDetailsManager(user, admin);\n    }\n}\n```\n\n## 解决的问题\n\n`spring-boot-starter-security` 是一个功能强大的安全框架，解决了以下关键问题：\n\n- **身份认证（Authentication）**：验证用户身份，支持多种认证方式（表单登录、HTTP Basic、OAuth2、LDAP 等）。\n- **授权（Authorization）**：控制已认证用户对资源的访问权限，支持基于角色和权限的访问控制。\n- **Web 攻击防护**：内置 CSRF（跨站请求伪造）、会话固定、点击劫持等常见 Web 攻击的防护机制。\n- **密码安全**：提供安全的密码存储方案，强制使用密码编码器（如 BCrypt）。\n- **简化配置**：通过自动化配置，以最少的代码实现强大的安全功能。\n\n## 核心功能与使用方法\n\n### 1. 基于组件的安全配置\n从 Spring Security 5.7 开始，推荐使用 `SecurityFilterChain` Bean 的方式进行配置，替代已废弃的 `WebSecurityConfigurerAdapter`。\n\n### 2. 身份认证\n- **`UserDetailsService`**：自定义用户信息的来源，如从数据库查询。\n- **`PasswordEncoder`**：定义密码加密和匹配的策略，推荐使用 `BCryptPasswordEncoder`。\n\n### 3. 授权\n- **请求授权**：使用 `http.authorizeHttpRequests()` 配置不同 URL 路径的访问规则。\n- **方法级安全**：使用 `@EnableMethodSecurity` 和 `@PreAuthorize` / `@PostAuthorize` 注解在方法级别进行更细粒度的权限控制。\n\n### 4. CSRF 防护\n默认开启，保护所有状态变更的 HTTP 请求（POST, PUT, DELETE）。对于无状态的 REST API，通常需要禁用 CSRF。\n\n## 版本与依赖管理\n\n版本由 `spring-boot-starter-parent` 管理。它传递性地依赖于 `spring-security-config` 和 `spring-security-web`。\n\n## 常用配置文件\n\n在 `application.yml` 中可以进行一些快速配置：\n\n```yaml\nspring:\n  security:\n    user:\n      name: user # 快速配置一个内存用户\n      password: password\n# 禁用默认安全配置（不推荐，除非完全自定义）\n# security.basic.enabled: false \n```\n\n## 注意事项\n\n- **默认行为**：一旦引入此 Starter，默认会保护所有端点，并启用 HTTP Basic 认证和表单登录。\n- **静态资源**：需要显式配置以允许对静态资源（如 CSS, JS）的匿名访问。\n- **无状态 API**：对于 RESTful API，通常需要禁用会话管理和 CSRF 防护：\n\n  ```java\n  http.csrf(csrf -&gt; csrf.disable());\n  http.sessionManagement(session -&gt; session.sessionCreationPolicy(SessionCreationPolicy.STATELESS));\n  ```\n\n## 常用注解\n\n- `@EnableWebSecurity`：启用 Spring Security 的 Web 安全支持。\n- `@Configuration`：标记类为配置类。\n- `@EnableMethodSecurity`：启用方法级别的安全注解。\n- `@PreAuthorize`, `@PostAuthorize`：在方法执行前后进行权限检查。\n- `@AuthenticationPrincipal`：在控制器方法中注入当前认证用户主体。\n\n## 常见问题排查\n\n### 1. 访问资源返回 403 Forbidden\n**原因**：\n- 用户权限不足。\n- CSRF 防护开启时，POST/PUT 请求缺少 CSRF 令牌。\n**解决**：\n- 检查用户的角色和配置的访问规则。\n- 在表单中添加 CSRF 令牌，或为无状态 API 禁用 CSRF。\n\n### 2. 登录后无限重定向\n**原因**：登录页面（如 `/login`）本身被安全规则拦截，导致循环跳转。\n**解决**：确保登录页面、处理登录的 URL 以及相关静态资源被 `permitAll()` 规则放行。\n\n### 3. 静态资源被拦截，无法加载\n**原因**：静态资源路径未被允许匿名访问。\n**解决**：在 `SecurityFilterChain` 配置中为静态资源路径添加 `permitAll()` 规则。\n\n```java\n.requestMatchers(&quot;/css/**&quot;, &quot;/js/**&quot;, &quot;/images/**&quot;).permitAll()\n```\n\n### 4. 密码验证失败\n**原因**：未配置 `PasswordEncoder`，或使用的编码器与数据库存储的密码格式不匹配。\n**解决**：提供一个 `PasswordEncoder` Bean（如 `BCryptPasswordEncoder`），并确保所有密码都使用该编码器加密。"
  },
  {
    "name": "spring-boot-configuration-processor",
    "summary": "一个注解处理器，在编译时为 `@ConfigurationProperties` 类生成元数据，从而在 IDE 中提供配置项的自动补全和文档提示。",
    "notes": "# spring-boot-configuration-processor\n\n## 示例\n\n### 添加依赖\n在 Maven 项目的 `pom.xml` 中添加 `spring-boot-configuration-processor` 依赖。注意，它是一个注解处理器。\n\n```xml\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt;\n    &lt;optional&gt;true&lt;/optional&gt;\n&lt;/dependency&gt;\n```\n\n### 创建配置属性类\n使用 `@ConfigurationProperties` 注解创建一个类来映射配置文件中的属性。\n\n```java\nimport org.springframework.boot.context.properties.ConfigurationProperties;\nimport org.springframework.context.annotation.Configuration;\n\n@Configuration\n@ConfigurationProperties(prefix = &quot;myapp&quot;)\npublic class MyAppProperties {\n\n    /**\n     * Application name.\n     */\n    private String name;\n    private String version;\n    private final Security security = new Security();\n\n    public static class Security {\n        /**\n         * Enable security features.\n         */\n        private boolean enabled = true;\n\n        // Getters and Setters\n        public boolean isEnabled() { return enabled; }\n        public void setEnabled(boolean enabled) { this.enabled = enabled; }\n    }\n\n    // Getters and Setters\n    public String getName() { return name; }\n    public void setName(String name) { this.name = name; }\n    public String getVersion() { return version; }\n    public void setVersion(String version) { this.version = version; }\n    public Security getSecurity() { return security; }\n}\n```\n\n### IDE 体验\n在 `application.yml` 中输入 `myapp.`，IDE（如 IntelliJ IDEA 或 VS Code）会自动提示 `name`, `version`, `security.enabled` 等属性，并显示 Javadoc 注释。\n\n```yaml\nmyapp:\n  name: My Awesome App\n  version: 1.0.0\n  security:\n    enabled: true\n```\n\n## 解决的问题\n\n`spring-boot-configuration-processor` 是一个开发时工具，主要解决以下问题：\n\n- **配置易错性**：手动在 `application.properties` 或 `yml` 文件中输入配置项时，容易出现拼写错误，导致配置不生效且难以排查。\n- **配置项不透明**：开发者不清楚有哪些自定义配置项可用，以及它们的含义和默认值。\n- **开发效率低下**：需要频繁在代码和配置文件之间切换，以确认属性名称和结构。\n\n通过生成元数据，该处理器极大地提升了配置文件的编写体验和准确性。\n\n## 核心功能与使用方法\n\n- **元数据生成**：在项目编译期间，处理器会扫描所有被 `@ConfigurationProperties` 注解的类。\n- **生成 JSON 文件**：它会根据扫描结果生成一个 `META-INF/spring-configuration-metadata.json` 文件。这个文件包含了所有配置项的名称、类型、描述（来自 Javadoc）和默认值。\n- **IDE 集成**：现代 IDE 会读取这个 `json` 文件，从而为开发者提供强大的代码补全、悬停提示和语法检查功能。\n\n## 版本与依赖管理\n\n- **版本**：其版本应与你的 Spring Boot 版本保持一致，由 `spring-boot-starter-parent` 管理。\n- **依赖范围**：通常将其声明为 `optional`，因为它是一个编译时工具，应用程序运行时并不需要它。在 Gradle 中，使用 `annotationProcessor` 范围。\n\n## 注意事项\n\n- **构建时工具**：这是一个纯粹的编译时依赖，对应用的运行时行为没有任何影响。\n- **重新构建**：当你修改了 `@ConfigurationProperties` 类（例如添加或删除字段）后，需要重新构建项目（如 `mvn clean install`），IDE 才能加载最新的元数据。\n- **不支持 `@Value`**：该处理器只对 `@ConfigurationProperties` 注解生效，不支持通过 `@Value` 注入的零散属性。\n- **Lombok 兼容性**：如果使用 Lombok 的 `@Getter` 和 `@Setter`，处理器也能正常工作。\n\n## 常用注解\n\n- `@ConfigurationProperties`：此处理器专门为这个注解服务，用于将外部配置绑定到强类型对象上。\n- `@NestedConfigurationProperty`：当嵌套对象不是一个内部静态类时，使用此注解可以确保其属性也被处理。\n\n## 常见问题排查\n\n### 1. IDE 中没有自动补全提示\n**原因**：\n- 依赖未正确配置为注解处理器。\n- 项目未成功编译，或 IDE 未重新加载项目变更。\n- IDE 插件问题。\n**排查**：\n- 确认 `pom.xml` 或 `build.gradle` 中依赖配置正确。\n- 执行一次完整的项目清理和构建 (`mvn clean install`)。\n- 在 IDE 中尝试 “Invalidate Caches / Restart” 或 “Reimport Maven/Gradle Project”。\n\n### 2. 元数据文件中缺少某些属性\n**原因**：\n- 对应的字段没有 public 的 getter/setter 方法（对于集合或 Map 类型，只需要 getter）。\n- 字段被标记为 `transient` 或其他不参与绑定的修饰符。\n- 嵌套的配置类不是 `public static` 内部类，且未使用 `@NestedConfigurationProperty`。\n**解决**：为所有需要绑定的字段提供标准的 getter 和 setter。\n\n### 3. Javadoc 注释未出现在 IDE 提示中\n**原因**：字段或 getter 方法上缺少 Javadoc 注释。\n**解决**：为需要文档的配置项添加清晰的 Javadoc 注释。"
  },
  {
    "name": "spring-boot-starter-quartz",
    "summary": "集成 Quartz 调度框架，用于在 Spring Boot 应用中创建、配置和管理复杂的定时任务，支持持久化和集群。",
    "notes": "# spring-boot-starter-quartz\n\n## 示例\n\n### 添加依赖\n在 Maven 项目的 `pom.xml` 中添加 `spring-boot-starter-quartz` 依赖：\n\n```xml\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-quartz&lt;/artifactId&gt;\n&lt;/dependency&gt;\n```\n\n### 创建任务（Job）\n创建一个继承自 `QuartzJobBean` 的任务类。\n\n```java\nimport org.quartz.JobExecutionContext;\nimport org.springframework.scheduling.quartz.QuartzJobBean;\n\npublic class SimpleJob extends QuartzJobBean {\n\n    @Override\n    protected void executeInternal(JobExecutionContext context) {\n        System.out.println(&quot;Executing Quartz Job: &quot; + context.getJobDetail().getKey());\n    }\n}\n```\n\n### 配置任务和触发器\n通过 `@Bean` 定义 `JobDetail` 和 `Trigger`。\n\n```java\n@Configuration\npublic class QuartzConfig {\n\n    @Bean\n    public JobDetail simpleJobDetail() {\n        return JobBuilder.newJob(SimpleJob.class)\n                .withIdentity(&quot;simpleJob&quot;)\n                .storeDurably()\n                .build();\n    }\n\n    @Bean\n    public Trigger simpleJobTrigger() {\n        // 每 10 秒执行一次\n        SimpleScheduleBuilder scheduleBuilder = SimpleScheduleBuilder.simpleSchedule()\n                .withIntervalInSeconds(10)\n                .repeatForever();\n\n        return TriggerBuilder.newTrigger()\n                .forJob(simpleJobDetail())\n                .withIdentity(&quot;simpleJobTrigger&quot;)\n                .withSchedule(scheduleBuilder)\n                .build();\n    }\n}\n```\n\n## 解决的问题\n\n`spring-boot-starter-quartz` 提供了比 Spring 内置 `@Scheduled` 更强大的任务调度功能，解决了以下问题：\n\n- **复杂调度需求**：支持 Cron 表达式、固定间隔、延迟执行等复杂的调度策略。\n- **任务持久化**：可以将任务和触发器的状态存储在数据库中，实现应用重启后任务的恢复。\n- **集群高可用**：在多实例部署时，通过数据库锁机制确保任务在集群中只被一个节点执行，实现任务调度的负载均衡和高可用。\n- **动态任务管理**：支持在运行时动态添加、修改、暂停和删除任务。\n\n## 核心功能与使用方法\n\n### 1. Job, JobDetail, 和 Trigger\n- **Job**: 任务的实际执行逻辑，通常继承 `QuartzJobBean`。\n- **JobDetail**: 任务的实例，包含任务的身份（`JobKey`）、关联的 Job 类和任务数据（`JobDataMap`）。\n- **Trigger**: 触发器，定义了任务何时执行，支持 `SimpleTrigger`（固定间隔）和 `CronTrigger`（Cron 表达式）。\n\n### 2. Scheduler\n调度器是 Quartz 的核心，负责管理和执行所有任务和触发器。Spring Boot 自动配置一个 `Scheduler` Bean。\n\n### 3. 持久化存储\n通过配置 `spring.quartz.job-store-type=jdbc`，可以将任务信息持久化到数据库。需要配合 `spring-boot-starter-jdbc` 或 `spring-boot-starter-data-jpa`。\n\n## 版本与依赖管理\n\n版本由 `spring-boot-starter-parent` 统一管理。它自动引入 `quartz` 依赖。\n\n## 常用配置文件\n\n在 `application.yml` 中配置 Quartz：\n\n```yaml\nspring:\n  quartz:\n    job-store-type: memory # 或 jdbc\n    jdbc:\n      initialize-schema: embedded # never, embedded, always\n    properties:\n      org.quartz.scheduler.instanceName: MyScheduler\n      org.quartz.threadPool.threadCount: 10\n    wait-for-jobs-to-complete-on-shutdown: true\n```\n\n## 注意事项\n\n- **Job 依赖注入**：默认情况下，Quartz 创建的 Job 实例不受 Spring 管理。Spring Boot 自动配置的 `Scheduler` 会使用 `SpringBeanJobFactory`，从而允许在 Job 类中使用 `@Autowired` 注入依赖。\n- **任务状态**：默认 Job 是无状态的，每次执行都会创建新实例。如果需要在多次执行间保持状态，可以使用 `JobDataMap`。使用 `@DisallowConcurrentExecution` 可以防止同一任务并发执行。\n- **数据库表**：当使用 `jdbc` 存储时，需要初始化 Quartz 的数据库表。可以通过设置 `spring.quartz.jdbc.initialize-schema=always` 让 Spring Boot 自动执行 `schema-*.sql` 脚本。\n\n## 常见问题排查\n\n### 1. 任务未执行\n**原因**：\n- `Scheduler` 未启动或被关闭。\n- Cron 表达式不正确。\n- `JobDetail` 和 `Trigger` 未正确关联。\n**排查**：\n- 检查 Quartz 相关的日志，确认 `Scheduler` 是否成功启动。\n- 使用在线工具验证 Cron 表达式的正确性。\n- 确认 `Trigger` 的 `forJob()` 方法指向了正确的 `JobDetail`。\n\n### 2. 数据库表未创建\n**原因**：未正确配置数据库初始化。\n**解决**：\n- 设置 `spring.quartz.job-store-type: jdbc`。\n- 设置 `spring.quartz.jdbc.initialize-schema` 为 `embedded` 或 `always`。确保 `classpath` 下有 Quartz 提供的 SQL 脚本。\n\n### 3. Job 中无法注入 Spring Bean\n**原因**：`Scheduler` 没有使用 `SpringBeanJobFactory`。\n**排查**：通常 Spring Boot 会自动配置，如果自定义了 `Scheduler`，需要确保为其设置了 `jobFactory`。\n\n### 4. 集群中任务重复执行\n**原因**：\n- 所有节点的 `org.quartz.scheduler.instanceId` 配置相同（应设为 `AUTO`）。\n- 数据库时间与应用服务器时间不同步。\n**解决**：\n- 确保 `instanceId` 为 `AUTO` 或为每个节点设置唯一值。\n- 同步所有服务器和数据库的时间。"
  },
  {
    "name": "spring-boot-starter-rsocket",
    "summary": "提供对 RSocket 协议的支持，用于构建高性能、响应式的双向通信应用，支持多种交互模型。",
    "notes": "# spring-boot-starter-rsocket\n\n## 示例\n\n### 添加依赖\n在 Maven 项目的 `pom.xml` 中添加 `spring-boot-starter-rsocket` 依赖：\n\n```xml\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-rsocket&lt;/artifactId&gt;\n&lt;/dependency&gt;\n```\n\n### 创建 RSocket 控制器\n创建一个处理 RSocket 请求的控制器。\n\n```java\n@Controller\npublic class RSocketController {\n\n    // Request-Response 模型\n    @MessageMapping(&quot;request-response&quot;)\n    public Mono&lt;String&gt; requestResponse(String name) {\n        return Mono.just(&quot;Hello, &quot; + name + &quot;!&quot;);\n    }\n\n    // Fire-and-Forget 模型\n    @MessageMapping(&quot;fire-and-forget&quot;)\n    public Mono&lt;Void&gt; fireAndForget(String message) {\n        System.out.println(&quot;Received: &quot; + message);\n        return Mono.empty();\n    }\n\n    // Request-Stream 模型\n    @MessageMapping(&quot;request-stream&quot;)\n    public Flux&lt;String&gt; requestStream(String name) {\n        return Flux.interval(Duration.ofSeconds(1))\n                   .map(i -&gt; &quot;Hello, &quot; + name + &quot;! Event #&quot; + i);\n    }\n}\n```\n\n## 解决的问题\n\n`spring-boot-starter-rsocket` 引入了 RSocket 协议，旨在解决传统 HTTP 协议在现代应用中的一些局限性：\n\n- **通信模式单一**：HTTP 主要是客户端请求-服务器响应模式。RSocket 支持多种交互模型，如请求-响应、请求-流、即发即忘和双向通道，更适合微服务和实时应用。\n- **性能开销**：RSocket 是一个二进制协议，相比基于文本的 HTTP，性能更高，开销更小。\n- **响应式支持**：原生支持响应式流（Reactive Streams），内置背压（Backpressure）机制，能有效处理高吞吐量数据流。\n- **双向通信**：允许客户端和服务器双向发起请求，打破了 HTTP 的单向请求限制。\n\n## 核心功能与使用方法\n\n### 1. 多种交互模型\n- **Request-Response**: 一次请求，一次响应（返回 `Mono`）。\n- **Fire-and-Forget**: 一次请求，无响应（返回 `Mono&lt;Void&gt;`）。\n- **Request-Stream**: 一次请求，多次响应流（返回 `Flux`）。\n- **Channel**: 双向通信流（方法参数和返回值均为 `Flux`）。\n\n### 2. RSocket 控制器\n使用 `@Controller` 标记类，并用 `@MessageMapping(&quot;route&quot;)` 注解方法来处理指定路由的请求。\n\n### 3. RSocket 客户端 (`RSocketRequester`)\nSpring 提供了 `RSocketRequester` 来方便地构建 RSocket 客户端，发起不同模式的请求。\n\n### 4. 传输层\nRSocket 独立于传输层，Spring Boot 支持将其运行在 **TCP** 或 **WebSocket** 之上。\n\n## 版本与依赖管理\n\n版本由 `spring-boot-starter-parent` 管理。它依赖于 Project Reactor 和 `rsocket-core`。\n\n## 常用配置文件\n\n在 `application.yml` 中配置 RSocket 服务器：\n\n```yaml\nspring:\n  rsocket:\n    server:\n      port: 7000\n      transport: tcp # 或 websocket\n      mapping-path: /rsocket # 当 transport 为 websocket 时使用\n```\n\n## 注意事项\n\n- **技术栈**：RSocket 是基于响应式编程模型的，需要熟悉 Project Reactor（`Mono` 和 `Flux`）。\n- **传输选择**：TCP 适用于服务器间的通信。WebSocket 适用于需要与浏览器客户端通信的场景。\n- **安全性**：可以与 Spring Security 集成，为 RSocket 连接和路由提供认证和授权。\n- **数据格式**：需要配置编码器和解码器（如 JSON、CBOR），Spring Boot 默认配置了多种常用格式。\n\n## 常用注解\n\n- `@Controller`：标记一个类为 RSocket 控制器。\n- `@MessageMapping`：将方法映射到指定的 RSocket 路由。\n- `@ConnectMapping`：处理新的 RSocket 连接事件，可用于连接级别的设置。\n- `@Payload`：将消息的负载绑定到方法参数。\n- `@DestinationVariable`：从路由中提取变量，类似于 HTTP 的 `@PathVariable`。\n\n## 常见问题排查\n\n### 1. 客户端连接失败\n**原因**：\n- 服务器未启动，或端口、传输协议配置错误。\n- 防火墙或网络策略阻止了连接。\n**排查**：\n- 确认服务器已启动并监听在正确的端口和传输协议上。\n- 检查客户端连接的 URI 是否正确。\n\n### 2. 消息路由不到正确的方法\n**原因**：`@MessageMapping` 中的路由与客户端请求的路由不匹配。\n**排查**：\n- 检查客户端和服务端定义的路由字符串是否完全一致。\n- 使用日志在控制器中打印所有接收到的请求路由，进行调试。\n\n### 3. 数据序列化/反序列化失败\n**原因**：客户端和服务器使用的编码/解码器不匹配，或数据格式与目标 Java 类型不兼容。\n**解决**：\n- 确保客户端和服务器都配置了相同的 `MimeType`（如 `application/json`）。\n- 确认发送的 JSON 结构与接收方的 POJO 字段匹配。"
  },
  {
    "name": "spring-boot-devtools",
    "summary": "提供一系列开发时工具，包括应用自动重启、LiveReload 和远程调试，旨在显著提升开发效率。",
    "notes": "# spring-boot-devtools\n\n## 示例\n\n### 添加依赖\n在 Maven 项目的 `pom.xml` 中添加 `spring-boot-devtools` 依赖。通常设为可选，以防传递到其他模块。\n\n```xml\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;\n    &lt;scope&gt;runtime&lt;/scope&gt;\n    &lt;optional&gt;true&lt;/optional&gt;\n&lt;/dependency&gt;\n```\n\n### 使用\n添加依赖后，当你修改项目中的代码或配置文件并保存时，DevTools 会自动重新启动 Spring Boot 应用。无需其他任何代码配置。\n\n## 解决的问题\n\n`spring-boot-devtools` 是一个纯粹的开发辅助工具，解决了以下痛点：\n\n- **开发周期缓慢**：每次修改代码后，都需要手动停止并重新启动应用，过程耗时，中断开发思路。\n- **前后端联调不便**：修改静态资源（HTML, CSS, JS）或模板文件后，需要手动刷新浏览器才能看到效果。\n- **配置缓存**：开发时，模板引擎（如 Thymeleaf）和静态资源的缓存会阻碍即时预览，需要手动禁用。\n\n## 核心功能与使用方法\n\n### 1. 自动重启（Automatic Restart）\n当 `classpath` 下的文件发生变更时，DevTools 会自动重启应用。它通过维护两个类加载器（一个加载不变的第三方库，一个加载你自己的代码）来实现快速重启，比冷启动快得多。\n\n### 2. LiveReload\nDevTools 内置了一个 LiveReload 服务器。当资源文件（如静态资源、模板）发生变化时，它会触发浏览器自动刷新。需要配合浏览器端的 LiveReload 插件使用。\n\n### 3. 属性默认值\n为方便开发，DevTools 会自动调整一些 Spring Boot 属性的默认值，例如：\n- 禁用模板缓存 (`spring.thymeleaf.cache=false`)。\n- 启用 Web 日志组的 `DEBUG` 级别。\n\n### 4. 远程应用（Remote Application）\nDevTools 支持远程更新和重启部署在远端的应用，便于远程调试。这需要客户端和服务端都进行相应配置。\n\n## 版本与依赖管理\n\n版本由 `spring-boot-starter-parent` 管理。这是一个独立的工具，不依赖其他 Starter。\n\n## 常用配置文件\n\n在 `application.yml` 中可以微调 DevTools 的行为：\n\n```yaml\nspring:\n  devtools:\n    restart:\n      enabled: true # 默认为 true\n      exclude: static/**, public/** # 指定哪些路径下的文件变更不触发重启\n      trigger-file: .triggerfile # 指定一个触发文件，只有当这个文件更新时才重启\n    livereload:\n      enabled: true # 默认为 true\n```\n\n## 注意事项\n\n- **生产环境安全**：DevTools 在生产环境中会自动禁用。它通过检测应用是否以完全打包的方式（如 `java -jar myapp.jar`）运行来判断。这是一个非常重要的安全特性。\n- **IDE 配置**：为了让自动重启生效，需要确保你的 IDE（如 IntelliJ IDEA 或 Eclipse）配置为在保存时自动编译文件。对于 IntelliJ IDEA，需要开启 “Build project automatically” 并通过注册表启用 “automake”。\n- **依赖范围**：通常将 `scope` 设为 `runtime`，因为它在编译时不需要。`optional=true` 可以防止它被打包到最终的生产 JAR/WAR 中，或被其他依赖此项目的模块继承。\n\n## 常见问题排查\n\n### 1. 自动重启不工作\n**原因**：\n- IDE 未配置为自动构建项目。\n- 修改的文件位于被 `exclude` 的路径下。\n- DevTools 依赖未正确添加到项目中。\n**解决**：\n- 检查并配置 IDE 的自动编译功能。\n- 确认 `pom.xml` 中已添加 `spring-boot-devtools` 依赖。\n- 检查 `spring.devtools.restart.exclude` 配置。\n\n### 2. LiveReload 不工作\n**原因**：\n- 浏览器未安装或未启用 LiveReload 插件。\n- `spring.devtools.livereload.enabled` 被设为 `false`。\n**解决**：\n- 安装并启用浏览器插件。\n- 确认配置中 `livereload` 是开启的。\n\n### 3. 每次重启还是很慢\n**原因**：可能是某些耗时的初始化操作在每次重启时都被执行。\n**排查**：\n- 检查启动日志，定位耗时长的 Bean 初始化过程。\n- 可以考虑使用 `spring.devtools.restart.trigger-file` 来手动控制重启时机，避免频繁因小改动而重启。"
  },
  {
    "name": "spring-session-data-redis",
    "summary": "集成 Spring Session 和 Redis，用于实现分布式会话管理，解决多实例应用下的会话共享和持久化问题。",
    "notes": "# spring-session-data-redis\n\n## 示例\n\n### 添加依赖\n在 Maven 项目的 `pom.xml` 中添加 `spring-session-data-redis` 和 `spring-boot-starter-data-redis` 依赖。\n\n```xml\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.session&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-session-data-redis&lt;/artifactId&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;\n&lt;/dependency&gt;\n```\n\n### 配置 Redis 和 Session\n在 `application.yml` 中配置 Redis 连接信息和 Session 存储类型。\n\n```yaml\nspring:\n  redis:\n    host: localhost\n    port: 6379\n  session:\n    store-type: redis # 关键配置，指定使用 Redis 存储 Session\n    timeout: 30m # Session 超时时间\n```\n\n### 使用 Session\n在控制器中像往常一样使用 `HttpSession`，Spring Session 会自动将其存储到 Redis。\n\n```java\n@RestController\npublic class SessionController {\n\n    @GetMapping(&quot;/&quot;)\n    public String home(HttpSession session) {\n        Integer visitCount = (Integer) session.getAttribute(&quot;visitCount&quot;);\n        if (visitCount == null) {\n            visitCount = 0;\n        }\n        visitCount++;\n        session.setAttribute(&quot;visitCount&quot;, visitCount);\n        return &quot;Your session ID: &quot; + session.getId() + &quot;, Visit count: &quot; + visitCount;\n    }\n}\n```\n\n## 解决的问题\n\n`spring-session-data-redis` 解决了传统基于 Servlet 容器的 `HttpSession` 在分布式环境中的核心问题：\n\n- **会话共享**：在微服务或负载均衡集群中，用户的请求可能被路由到不同的应用实例。该 Starter 将会话数据集中存储在 Redis 中，确保所有实例都能访问到同一份会话数据，实现无缝的用户体验。\n- **会话持久化**：传统 Session 存储在应用服务器内存中，应用重启会导致所有会话丢失。将会话存储在 Redis 中，可以实现会话的持久化，即使应用重启，用户登录状态依然保留。\n- **高可用性**：解耦了会话存储和应用服务器，应用服务器可以无状态地水平扩展，提高了系统的可伸缩性和容错能力。\n\n## 核心功能与使用方法\n\n- **透明替换**：自动通过一个 Filter 替换 Servlet 容器的 `HttpSession` 实现，对应用代码完全透明，开发者无需更改任何使用 `HttpSession` 的代码。\n- **自动化配置**：Spring Boot 提供了强大的自动化配置。只需添加依赖并在配置文件中指定 `spring.session.store-type: redis`，即可启用。\n- **会话超时管理**：支持通过 `spring.session.timeout` 或 `server.servlet.session.timeout` 配置会话的过期时间，并利用 Redis 的过期机制自动清理过期会话。\n\n## 版本与依赖管理\n\n版本由 `spring-boot-dependencies` BOM 管理。它需要 `spring-boot-starter-data-redis` 提供 Redis 连接能力。\n\n## 常用配置文件\n\n在 `application.yml` 中配置 Session 和 Redis：\n\n```yaml\nspring:\n  session:\n    store-type: redis\n    redis:\n      namespace: &quot;myapp:session&quot; # 在 Redis 中存储的 key 的命名空间\n      flush-mode: ON_SAVE # on-save: 修改时保存; immediate: 立即保存\n  redis:\n    host: 127.0.0.1\n    port: 6379\n```\n\n## 注意事项\n\n- **序列化**：所有存入 Session 的对象都必须实现 `java.io.Serializable` 接口，因为它们需要被序列化后才能存入 Redis。\n- **依赖关系**：必须同时引入 `spring-session-data-redis` 和 `spring-boot-starter-data-redis`。\n- **激活方式**：在较新版本的 Spring Boot 中，仅需配置 `spring.session.store-type: redis` 即可。在旧版本或需要自定义配置时，可能需要在配置类上添加 `@EnableRedisHttpSession` 注解。\n\n## 常见问题排查\n\n### 1. `NotSerializableException`\n**问题**：向 Session 中存入一个对象时抛出此异常。\n**原因**：该对象的类没有实现 `java.io.Serializable` 接口。\n**解决**：让该类及其所有非瞬态（`transient`）的成员变量都实现 `Serializable` 接口。\n\n### 2. Session 未被存储到 Redis\n**原因**：\n- 未配置 `spring.session.store-type: redis`。\n- Redis 连接配置错误，导致无法连接到 Redis 服务器。\n**排查**：\n- 检查 `application.yml` 中 `store-type` 是否已正确设置。\n- 检查 Redis 连接参数，并确认 Redis 服务是否正常运行。\n\n### 3. 会话数据读取不一致\n**原因**：可能与 `spring.session.redis.flush-mode` 配置有关。`ON_SAVE` 模式只在 HTTP 响应提交时才写入 Redis，而 `IMMEDIATE` 模式会立即写入。\n**排查**：如果应用在响应完成前需要读取其他实例写入的最新会话数据，可以考虑将 `flush-mode` 设为 `IMMEDIATE`，但这会增加 Redis 的写入频率。"
  },
  {
    "name": "lombok",
    "summary": "一个 Java 库，通过注解在编译时自动生成样板代码（如 getters, setters, constructors），极大简化 Java 类的编写。",
    "notes": "# lombok\n\n## 示例\n\n### 添加依赖\n在 Maven 项目的 `pom.xml` 中添加 `lombok` 依赖。\n\n```xml\n&lt;dependency&gt;\n    &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;\n    &lt;artifactId&gt;lombok&lt;/artifactId&gt;\n    &lt;optional&gt;true&lt;/optional&gt;\n&lt;/dependency&gt;\n```\n\n### 使用 Lombok 注解\n使用 `@Data`、`@Builder` 等注解简化 POJO 或实体类的编写。\n\n```java\nimport lombok.Data;\nimport lombok.Builder;\nimport lombok.NoArgsConstructor;\nimport lombok.AllArgsConstructor;\n\n@Data // 自动生成 @Getter, @Setter, @ToString, @EqualsAndHashCode, @RequiredArgsConstructor\n@Builder\n@NoArgsConstructor\n@AllArgsConstructor\npublic class User {\n    private Long id;\n    private String username;\n    private String email;\n}\n\n// 使用 Builder 创建对象\nUser user = User.builder()\n              .id(1L)\n              .username(&quot;john_doe&quot;)\n              .email(&quot;john.doe@example.com&quot;)\n              .build();\n```\n\n## 解决的问题\n\nLombok 旨在解决 Java 语言中的一个常见痛点：**样板代码（Boilerplate Code）**。\n\n- **代码冗余**：JavaBean、实体类等通常需要编写大量的 getter, setter, `toString()`, `equals()`, `hashCode()` 和构造函数，这些代码结构固定，但占用大量空间，降低了代码的可读性。\n- **维护成本高**：每当添加或修改一个字段时，都需要手动更新相关的样板方法，容易出错或遗漏。\n- **可读性差**：充斥着样板代码的类，其核心逻辑和数据结构不够突出，难以快速理解。\n\nLombok 通过注解，将这些重复性工作交给编译器自动完成，让代码更简洁、更专注于业务逻辑。\n\n## 核心功能与使用方法\n\nLombok 提供了丰富的注解，以下是一些最常用的：\n\n- **`@Getter` / `@Setter`**: 为字段生成 public 的 getter 和 setter 方法。\n- **`@ToString`**: 生成一个包含类名和所有字段的 `toString()` 方法。\n- **`@EqualsAndHashCode`**: 生成 `equals()` 和 `hashCode()` 方法。\n- **`@NoArgsConstructor`, `@RequiredArgsConstructor`, `@AllArgsConstructor`**: 分别生成无参、包含 `final` 或 `@NonNull` 字段的、以及包含所有字段的构造函数。\n- **`@Data`**: 一个复合注解，相当于 `@Getter` + `@Setter` + `@ToString` + `@EqualsAndHashCode` + `@RequiredArgsConstructor`。\n- **`@Builder`**: 实现建造者模式，提供链式调用的方式创建对象。\n- **`@Slf4j`**: 为类生成一个 `private static final` 的 SLF4J logger，字段名为 `log`。\n- **`@Value`**: 一个不可变版本的 `@Data`，所有字段默认为 `private final`，且只生成 getter。\n\n## 版本与依赖管理\n\n- **版本**：推荐使用最新的稳定版本。Spring Boot 的父 POM 中通常也会管理一个推荐的 Lombok 版本。\n- **IDE 插件**：除了在项目中添加依赖，**必须**在你的 IDE（如 IntelliJ IDEA, Eclipse, VS Code）中安装 Lombok 插件。否则，IDE 会因为找不到 Lombok 生成的方法而报错。\n\n## 注意事项\n\n- **注解处理器**：Lombok 的工作原理是在编译期间作为一个注解处理器，修改 AST（抽象语法树）来添加代码，生成的代码会存在于最终的 `.class` 文件中，但不会出现在 `.java` 源码里。\n- **IDE 插件是必需的**：再次强调，没有 IDE 插件，Lombok 无法在开发环境正常工作。\n- **`@Data` 和 JPA/Hibernate**：在 JPA 实体类中使用 `@Data` 时要小心。它生成的 `@EqualsAndHashCode` 默认会包含所有字段，包括关联实体，这可能导致懒加载问题或无限循环。推荐手动指定 `of` 或 `exclude` 属性，或者单独使用 `@Getter`, `@Setter`, `@ToString`。\n- **`optional=true`**: 将其设为 `optional` 是一个好习惯，可以避免将 Lombok 依赖传递给其他依赖此项目的模块。\n\n## 常见问题排查\n\n### 1. IDE 报错，提示找不到 getter/setter 等方法\n**原因**：这是最常见的问题，原因通常是：\n- 未安装 Lombok IDE 插件。\n- 安装了插件但未启用注解处理（Annotation Processing）。\n**解决**：\n- 前往 IDE 的插件市场安装 Lombok 插件，并重启 IDE。\n- 在 IntelliJ IDEA 中，确保 “Settings -&gt; Build, Execution, Deployment -&gt; Compiler -&gt; Annotation Processors” 中 “Enable annotation processing” 已被勾选。\n\n### 2. `@Builder` 与构造函数冲突\n**原因**：如果同时使用了 `@Builder` 和 `@AllArgsConstructor`（或自定义了全参构造函数），可能会产生冲突。\n**解决**：通常 `@Builder` 会自动处理构造函数。如果需要同时存在，可以查阅 Lombok 文档关于 `@Builder` 的高级用法，如 `toBuilder=true`。\n\n### 3. JPA 实体懒加载或栈溢出问题\n**原因**：如上所述，`@Data` 或 `@EqualsAndHashCode` 的默认行为不适合包含双向关联的 JPA 实体。\n**解决**：\n- 不要在 JPA 实体上使用 `@Data`。\n- 手动实现 `equals()` 和 `hashCode()`，通常只基于主键 `id`。\n- 或者使用 `@EqualsAndHashCode(of = &quot;id&quot;)` 来指定只使用 `id` 字段。"
  },
  {
    "name": "spring-cloud-starter-bus-amqp",
    "summary": "集成 Spring Cloud Bus 与 RabbitMQ (AMQP)，用于在微服务集群中广播状态变更和管理事件，实现配置的动态刷新。",
    "notes": "# spring-cloud-starter-bus-amqp\n\n## 示例\n\n### 添加依赖\n在 Maven 项目的 `pom.xml` 中添加 `spring-cloud-starter-bus-amqp` 和 `spring-cloud-starter-config` 依赖。\n\n```xml\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-cloud-starter-bus-amqp&lt;/artifactId&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-cloud-starter-config&lt;/artifactId&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;\n&lt;/dependency&gt;\n```\n\n### 配置 RabbitMQ\n在 `application.yml` 中配置 RabbitMQ 的连接信息。\n\n```yaml\nspring:\n  rabbitmq:\n    host: localhost\n    port: 5672\n    username: guest\n    password: guest\n  cloud:\n    bus:\n      trace:\n        enabled: true # 开启总线事件跟踪，便于调试\n```\n\n### 触发刷新\n当在 Git 仓库中修改了配置文件并推送到 Config Server 后，可以向任意一个连接到总线的微服务实例发送一个 POST 请求到 `/actuator/bus-refresh` 端点，该事件会通过 RabbitMQ 广播到所有其他服务实例，触发它们刷新配置。\n\n```bash\n# 假设 app-instance-1 是连接到总线的服务\ncurl -X POST http://localhost:8081/actuator/bus-refresh\n```\n\n## 解决的问题\n\n`spring-cloud-starter-bus-amqp` 解决了微服务架构中**配置动态更新的广播问题**。\n\n- **单点刷新瓶颈**：在使用 Spring Cloud Config 时，如果配置发生变更，需要手动逐个调用每个微服务实例的 `/actuator/refresh` 端点才能使配置生效。这在实例数量众多时变得非常繁琐且容易遗漏。\n- **状态变更通知**：除了配置刷新，有时也需要在服务间广播其他类型的管理事件，如缓存清理、服务下线通知等。\n\nSpring Cloud Bus 通过引入一个轻量级的消息代理（如 RabbitMQ），将所有服务实例连接起来，形成一个事件总线。任何一个实例发布一个事件，其他所有实例都能接收到，从而实现“一处触发，处处生效”的效果。\n\n## 核心功能与使用方法\n\n- **事件广播**：将 `/actuator/bus-refresh` 事件通过 RabbitMQ 广播到所有监听了总线的服务。\n- **与 Config Server 集成**：当服务接收到 `RefreshRemoteApplicationEvent` 时，会自动向 Config Server 拉取最新的配置。\n- **自定义事件**：可以继承 `RemoteApplicationEvent` 来创建和广播自定义的业务或管理事件。\n- **服务寻址**：支持通过 `destination` 参数将事件发送给特定的服务实例或服务类型。\n\n## 版本与依赖管理\n\n- **版本**：版本由 `spring-cloud-dependencies` BOM 统一管理。\n- **依赖**：它依赖于 `spring-boot-starter-amqp`（RabbitMQ）和 `spring-cloud-bus`。\n\n## 常用配置文件\n\n```yaml\nspring:\n  cloud:\n    bus:\n      id: ${spring.application.name}:${server.port} # 定义总线上每个实例的唯一ID\n      enabled: true # 默认开启\n      destination: my-bus-topic # 自定义 RabbitMQ 的 exchange 名称\nmanagement:\n  endpoints:\n    web:\n      exposure:\n        include: bus-refresh, bus-env # 暴露 Actuator 端点\n```\n\n## 注意事项\n\n- **消息代理依赖**：必须部署并运行一个 RabbitMQ（或 Kafka，如果使用 `spring-cloud-starter-bus-kafka`）服务器。\n- **Actuator 依赖**：需要 `spring-boot-starter-actuator` 才能暴露 `/actuator/bus-refresh` 等端点。\n- **`@RefreshScope`**：要使配置动态刷新生效，相关的 Bean 必须使用 `@RefreshScope` 注解。\n- **幂等性**：刷新操作应设计为幂等的，因为在某些网络情况下，事件可能被重复接收。\n\n## 常见问题排查\n\n### 1. 刷新事件未被广播\n**原因**：\n- RabbitMQ 连接配置错误或服务不可用。\n- Spring Cloud Bus 未启用 (`spring.cloud.bus.enabled=false`)。\n- 服务实例未正确连接到总线。\n**排查**：\n- 检查 RabbitMQ 的连接日志，确认连接是否成功。\n- 查看应用启动日志，确认 `SpringCloudBusClient` 是否已初始化。\n- 使用 RabbitMQ 管理界面查看 `spring.cloud.bus.destination` 对应的 exchange 是否有消息传递。\n\n### 2. 服务接收到事件但配置未更新\n**原因**：需要更新的 Bean 没有被 `@RefreshScope` 注解。\n**解决**：在需要动态更新其属性的配置类或组件上添加 `@RefreshScope` 注解。\n\n### 3. 如何只刷新特定服务的配置？\n**原因**：默认的 `/actuator/bus-refresh` 会广播给所有服务。\n**解决**：使用带 `destination` 参数的端点，可以指定目标服务。\n\n```bash\n# 只刷新名为 &#x27;user-service&#x27; 的所有实例\ncurl -X POST http://localhost:8081/actuator/bus-refresh/user-service\n\n# 只刷新 &#x27;user-service&#x27; 的某个特定实例\ncurl -X POST http://localhost:8081/actuator/bus-refresh/user-service:9001\n```"
  },
  {
    "name": "spring-cloud-starter-kubernetes-client",
    "summary": "集成 Spring Cloud 与 Kubernetes，提供服务发现、配置管理和 Ribbon 负载均衡，使 Spring Boot 应用能原生感知和利用 Kubernetes 环境。",
    "notes": "# spring-cloud-starter-kubernetes-client\n\n## 示例\n\n### 添加依赖\n在 Maven 项目的 `pom.xml` 中添加 `spring-cloud-starter-kubernetes-client` 依赖。\n\n```xml\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-cloud-starter-kubernetes-client&lt;/artifactId&gt;\n&lt;/dependency&gt;\n```\n\n### 配置 Kubernetes 客户端\n在 `bootstrap.yml` 中启用 Kubernetes 服务发现和配置管理。\n\n```yaml\nspring:\n  application:\n    name: my-app # 应用名称，应与 Kubernetes Service 名称对应\n  cloud:\n    kubernetes:\n      discovery:\n        enabled: true # 启用服务发现\n      config:\n        enabled: true # 启用配置管理\n        sources:\n          - name: ${spring.application.name} # 从名为 my-app 的 ConfigMap 加载配置\n```\n\n### Kubernetes 资源示例\n创建一个 `Service` 用于服务发现，一个 `ConfigMap` 用于配置管理。\n\n```yaml\n# service.yaml\napiVersion: v1\nkind: Service\nmetadata:\n  name: user-service\nspec:\n  selector:\n    app: user-service\n  ports:\n    - port: 80\n      targetPort: 8080\n\n# configmap.yaml\napiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: my-app\ndata:\n  application.yml: |-\n    greeting.message: &quot;Hello from Kubernetes ConfigMap!&quot;\n```\n\n## 解决的问题\n\n当 Spring Boot 应用部署在 Kubernetes 环境中时，`spring-cloud-starter-kubernetes-client` 解决了**环境集成**的问题，使应用能够利用 K8s 的原生能力，而无需引入额外的服务注册中心（如 Eureka）或配置中心（如 Config Server）。\n\n- **服务发现**：替代 Eureka，直接使用 Kubernetes 的 `Service` 和 `Endpoint` 资源进行服务发现。\n- **配置管理**：替代 Config Server，直接从 Kubernetes 的 `ConfigMap` 和 `Secret` 中加载配置，并支持动态刷新。\n- **简化架构**：减少了中间件的部署和维护成本，使技术栈更贴近云原生生态。\n\n## 核心功能与使用方法\n\n- **服务发现 (`DiscoveryClient`)**：自动实现 Spring Cloud 的 `DiscoveryClient` 接口，使其能够从 Kubernetes API Server 查询 `Service` 的 `Endpoint`（即 Pod 的 IP 和端口），从而发现其他服务。\n- **配置管理 (`ConfigMap`/`Secret`)**：在应用启动时，从指定的 `ConfigMap` 或 `Secret` 中读取配置数据，并将其合并到 Spring `Environment` 中。支持配置的动态刷新。\n- **负载均衡 (Ribbon/LoadBalancer)**：与 Spring Cloud LoadBalancer（或旧版的 Ribbon）集成，当使用 `@LoadBalanced RestTemplate` 或 Feign 客户端时，能够对从 K8s 发现的服务实例进行客户端负载均衡。\n- **属性源优先级**：从 `ConfigMap`/`Secret` 加载的配置优先级高于项目内的 `application.yml`。\n\n## 版本与依赖管理\n\n- **版本**：版本由 `spring-cloud-dependencies` BOM 统一管理。\n- **依赖**：它依赖于 Fabric8 Kubernetes Client，用于与 Kubernetes API Server 交互。\n\n## 常用配置文件\n\n```yaml\nspring:\n  cloud:\n    kubernetes:\n      reload:\n        enabled: true # 启用配置自动刷新\n        mode: event # 刷新模式：event (推荐) 或 polling\n        strategy: refresh\n      discovery:\n        all-namespaces: false # 是否发现所有命名空间下的服务\n      config:\n        # 从多个 ConfigMap 加载配置\n        sources:\n          - name: common-config\n          - name: ${spring.application.name}\n        # 从 Secret 加载敏感配置\n        secrets:\n          sources:\n            - name: db-credentials\n```\n\n## 注意事项\n\n- **RBAC 权限**：运行应用的 `ServiceAccount` 必须有足够的 RBAC 权限来读取 `Services`, `Endpoints`, `ConfigMaps` 和 `Secrets`。通常需要创建一个 `Role` 和 `RoleBinding`。\n- **`bootstrap.yml`**：Kubernetes 相关的配置（特别是 `config` 和 `discovery`）需要放在 `bootstrap.yml`（或 `bootstrap.properties`）中，因为它需要在应用主上下文加载前初始化。\n- **与 Feign 集成**：使用 Feign 客户端时，`url` 属性应留空，`name` 属性应设为目标 Kubernetes `Service` 的名称。\n\n## 常见问题排查\n\n### 1. 服务发现失败或找不到服务\n**原因**：\n- 应用的 `ServiceAccount` 权限不足。\n- 应用部署的 `namespace` 与目标 `Service` 的 `namespace` 不一致，且未开启 `all-namespaces`。\n- `spring.application.name` 与 K8s `Service` 名称不匹配。\n**排查**：\n- 使用 `kubectl auth can-i get services -n &lt;namespace&gt; --as=system:serviceaccount:&lt;namespace&gt;:&lt;service-account-name&gt;` 检查权限。\n- 确认 `Service` 和 `Pod` 运行正常且 `Endpoints` 存在。\n\n### 2. 未能从 ConfigMap/Secret 加载配置\n**原因**：\n- `ServiceAccount` 缺少读取 `ConfigMap` 或 `Secret` 的权限。\n- `ConfigMap`/`Secret` 名称或 `namespace` 不正确。\n- `ConfigMap` 中的数据格式错误（例如，`application.yml` 的键下应该是 YAML 格式的字符串）。\n**排查**：\n- 检查 RBAC 权限。\n- 确认 `spring.cloud.kubernetes.config.sources` 中指定的名称与 K8s 资源名称一致。\n\n### 3. 配置动态刷新不生效\n**原因**：\n- `spring.cloud.kubernetes.reload.enabled` 未设为 `true`。\n- RBAC 权限不足以 `watch` `ConfigMap` 变更事件。\n- 需要刷新的 Bean 未使用 `@RefreshScope` 或 `@ConfigurationProperties`。\n**解决**：\n- 确保开启 `reload`，并将 `mode` 设为 `event`。\n- 在 `Role` 中为 `configmaps` 资源添加 `watch` 权限。\n- 为相关 Bean 添加 `@RefreshScope` 注解。"
  },
  {
    "name": "apache-poi-word-integration",
    "summary": "集成 Apache POI 库，用于在 Spring Boot 应用中创建、读取和修改 Microsoft Word 文档（.doc 和 .docx）。",
    "notes": "# Apache POI for Word Integration\n\n## 示例\n\n### 添加依赖\n在 Maven 项目的 `pom.xml` 中添加 Apache POI 相关依赖。这与处理 Excel 的依赖是相同的。\n\n```xml\n&lt;!-- POI 核心库，包含处理 .doc 的 HWPF --&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.apache.poi&lt;/groupId&gt;\n    &lt;artifactId&gt;poi&lt;/artifactId&gt;\n    &lt;version&gt;5.2.3&lt;/version&gt;\n&lt;/dependency&gt;\n&lt;!-- 用于处理 .docx 的 XWPF --&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.apache.poi&lt;/groupId&gt;\n    &lt;artifactId&gt;poi-ooxml&lt;/artifactId&gt;\n    &lt;version&gt;5.2.3&lt;/version&gt;\n&lt;/dependency&gt;\n```\n\n### 创建 Word 下载接口\n在控制器中动态生成一个 `.docx` 文件并提供下载。\n\n```java\n@RestController\npublic class WordController {\n\n    @GetMapping(&quot;/download-word&quot;)\n    public void downloadWord(HttpServletResponse response) throws IOException {\n        // 创建一个 .docx 格式的文档\n        try (XWPFDocument document = new XWPFDocument()) {\n            // 创建一个段落\n            XWPFParagraph title = document.createParagraph();\n            title.setAlignment(ParagraphAlignment.CENTER);\n            XWPFRun titleRun = title.createRun();\n            titleRun.setText(&quot;My First Word Document&quot;);\n            titleRun.setBold(true);\n            titleRun.setFontSize(20);\n\n            // 创建另一个段落\n            XWPFParagraph para = document.createParagraph();\n            XWPFRun paraRun = para.createRun();\n            paraRun.setText(&quot;This document was generated dynamically using Apache POI in a Spring Boot application.&quot;);\n\n            response.setContentType(&quot;application/vnd.openxmlformats-officedocument.wordprocessingml.document&quot;);\n            response.setHeader(&quot;Content-Disposition&quot;, &quot;attachment; filename=generated.docx&quot;);\n\n            document.write(response.getOutputStream());\n        }\n    }\n}\n```\n\n## 解决的问题\n\n在 Spring Boot 应用中集成 Apache POI 处理 Word 文档，可以解决以下常见需求：\n\n- **动态文档生成**：根据模板和业务数据生成合同、报告、官方通知等格式化的 Word 文档。\n- **数据导出**：将系统中的结构化或非结构化数据导出为 Word 文件，便于离线阅读和编辑。\n- **内容提取**：从上传的 Word 文档中读取文本、表格等内容，用于数据分析或信息录入。\n- **模板填充**：加载一个预先设计好的 `.docx` 模板文件，通过编程方式替换占位符（如 `${name}`），生成最终文档。\n\n## 核心功能与使用方法\n\n- **`HWPFDocument`**: 用于处理旧版 Word 文档 (`.doc`)。\n- **`XWPFDocument`**: 用于处理新版 OOXML 格式的 Word 文档 (`.docx`)，是目前的主流选择。\n- **`XWPFParagraph`, `XWPFRun`**: 分别代表段落和段落中的文本片段（可以有不同的样式），是构建文本内容的基础。\n- **`XWPFTable`**: 用于创建和操作 Word 文档中的表格。\n- **图片和样式**: POI 提供了 API 来插入图片、设置文本样式（字体、大小、颜色、加粗等）和段落样式（对齐、缩进等）。\n\n## 注意事项\n\n- **资源管理**：`XWPFDocument` 对象同样实现了 `Closeable` 接口，必须在 `try-with-resources` 或 `finally` 块中确保关闭，以避免资源泄漏。\n- **内存占用**：与 Excel 处理类似，POI 对 Word 文档的处理是基于 DOM 模型的，即会将整个文档加载到内存中。处理非常大的 Word 文件时，需要注意内存消耗。\n- **模板技术**：对于复杂的文档生成，直接用 POI API 从零构建会非常繁琐。更常见的做法是创建一个包含占位符的 `.docx` 模板，然后用程序加载该模板并替换占位符。\n- **版本一致性**：确保 `poi` 和 `poi-ooxml` 依赖的版本号保持一致。\n\n## 常见问题排查\n\n### 1. 下载的 Word 文件损坏\n**原因**：与 Excel 问题类似，通常是 `Content-Type` 错误或输出流被污染。\n**解决**：\n- 确保 `.docx` 的 `Content-Type` 为 `application/vnd.openxmlformats-officedocument.wordprocessingml.document`。\n- 确保 `.doc` 的 `Content-Type` 为 `application/msword`。\n- 保证 `document.write()` 是对响应输出流的最后一次写入操作。\n\n### 2. `ClassNotFoundException` 或 `NoSuchMethodError`\n**原因**：项目中可能存在其他依赖传递引入了不同版本的 POI 相关库（如 `xmlbeans`、`poi-ooxml-lite`），导致版本冲突。\n**解决**：\n- 使用 `mvn dependency:tree` 或 Gradle 的等效命令分析依赖树。\n- 在 `&lt;dependencyManagement&gt;` 中明确指定 POI 和其相关依赖的版本，或使用 `<exclusions>` 排除冲突的版本。\n\n### 3. 如何替换模板中的占位符？\n**问题**：如何实现基于模板的文档生成？\n**解决**：没有直接的 `replace` API。需要遍历文档的所有段落（`XWPFParagraph`）和表格单元格（`XWPFTableCell`），获取其中的文本片段（`XWPFRun`），然后对每个 `Run` 的文本执行字符串替换操作。这是一个相对复杂的过程，需要编写辅助方法来完成。"
  },
  {
    "name": "apache-poi-integration",
    "summary": "集成 Apache POI 库，用于在 Spring Boot 应用中创建、读取和修改 Microsoft Office 文档，特别是 Excel (XLS, XLSX)。",
    "notes": "# Apache POI Integration\n\n## 示例\n\n### 添加依赖\n在 Maven 项目的 `pom.xml` 中添加 Apache POI 相关依赖。\n\n```xml\n&lt;!-- 用于处理 .xls 格式 --&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.apache.poi&lt;/groupId&gt;\n    &lt;artifactId&gt;poi&lt;/artifactId&gt;\n    &lt;version&gt;5.2.3&lt;/version&gt;\n&lt;/dependency&gt;\n&lt;!-- 用于处理 .xlsx 格式 --&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.apache.poi&lt;/groupId&gt;\n    &lt;artifactId&gt;poi-ooxml&lt;/artifactId&gt;\n    &lt;version&gt;5.2.3&lt;/version&gt;\n&lt;/dependency&gt;\n```\n\n### 创建 Excel 下载接口\n在控制器中生成 Excel 文件并提供下载。\n\n```java\n@RestController\npublic class ExcelController {\n\n    @GetMapping(&quot;/download-excel&quot;)\n    public void downloadExcel(HttpServletResponse response) throws IOException {\n        // 创建一个 .xlsx 格式的工作簿\n        try (Workbook workbook = new XSSFWorkbook()) {\n            Sheet sheet = workbook.createSheet(&quot;Users&quot;);\n            Row header = sheet.createRow(0);\n            header.createCell(0).setCellValue(&quot;ID&quot;);\n            header.createCell(1).setCellValue(&quot;Name&quot;);\n\n            Row dataRow = sheet.createRow(1);\n            dataRow.createCell(0).setCellValue(1);\n            dataRow.createCell(1).setCellValue(&quot;John Doe&quot;);\n\n            response.setContentType(&quot;application/vnd.openxmlformats-officedocument.spreadsheetml.sheet&quot;);\n            response.setHeader(&quot;Content-Disposition&quot;, &quot;attachment; filename=users.xlsx&quot;);\n\n            workbook.write(response.getOutputStream());\n        }\n    }\n}\n```\n\n## 解决的问题\n\n在 Spring Boot 应用中集成 Apache POI，主要解决与 Office 文档交互的问题：\n\n- **动态报表生成**：根据数据库或业务数据动态生成 Excel 报表，供用户下载分析。\n- **数据导入导出**：实现通过 Excel 文件批量导入数据到系统，或将系统数据导出为 Excel 格式。\n- **简化集成**：虽然没有官方 Starter，但 POI 与 Spring MVC 的 `HttpServletResponse` 可以无缝集成，实现文件下载。\n- **复杂格式处理**：支持单元格样式、公式、图表等复杂 Excel 功能的编程实现。\n\n## 核心功能与使用方法\n\n- **`HSSFWorkbook`**: 用于处理老版本的 Excel 文件 (`.xls`)。\n- **`XSSFWorkbook`**: 用于处理新版本的 Excel 文件 (`.xlsx`)，功能更强大。\n- **`SXSSFWorkbook`**: `XSSFWorkbook` 的流式写入版本，用于生成大数据量的 Excel 文件，可以有效避免 `OutOfMemoryError`。\n- **`Sheet`, `Row`, `Cell`**: 分别代表工作表、行和单元格，是操作 Excel 内容的核心对象。\n- **`CellStyle`**: 用于设置单元格的样式，如字体、颜色、边框、对齐方式等。\n\n## 注意事项\n\n- **内存管理**：处理大型 Excel 文件时，一次性将整个文件读入内存的 `XSSFWorkbook` 可能会导致 `OutOfMemoryError`。读取时应使用事件模型（SAX），写入时应使用 `SXSSFWorkbook`。\n- **资源关闭**：`Workbook` 对象实现了 `Closeable` 接口，务必在 `try-with-resources` 语句中或 `finally` 块中确保其被关闭，以释放资源。\n- **版本选择**：保持 `poi` 和 `poi-ooxml` 的版本一致，以避免兼容性问题。\n\n## 常见问题排查\n\n### 1. OutOfMemoryError\n**问题**：生成或读取大型 Excel 文件时发生内存溢出。\n**原因**：使用了基于 DOM 的 `XSSFWorkbook` 处理了超过内存限制的数据。\n**解决**：\n- **写入**: 改用 `SXSSFWorkbook`，它会将数据以流的方式写入临时文件，只在内存中保留少量行。\n- **读取**: 使用 SAX 事件模型解析，逐行处理，而不是一次性加载整个文档。\n\n### 2. 下载的 Excel 文件损坏或无法打开\n**原因**：\n- `HttpServletResponse` 的 `ContentType` 设置不正确。\n- 在将工作簿写入输出流后，又向流中写入了其他内容。\n- 工作簿对象在写入完成前被关闭。\n**解决**：\n- 确保 `.xlsx` 格式的 `ContentType` 为 `application/vnd.openxmlformats-officedocument.spreadsheetml.sheet`。\n- 确保 `workbook.write()` 是对 `response.getOutputStream()` 的最后操作。\n\n### 3. `InvalidFormatException`\n**问题**：读取一个文件时抛出此异常。\n**原因**：文件格式与使用的 `Workbook` 实现不匹配（例如，用 `XSSFWorkbook` 尝试读取一个 `.xls` 文件），或者文件本身已损坏。\n**解决**：根据文件扩展名选择正确的 `Workbook` 实现，或使用 `WorkbookFactory.create(file)` 让 POI 自动检测。"
  },
  {
    "name": "apache-pdfbox-integration",
    "summary": "集成 Apache PDFBox 库，用于在 Spring Boot 应用中创建、解析和操作 PDF 文档。",
    "notes": "# Apache PDFBox Integration\n\n## 示例\n\n### 添加依赖\n在 Maven 项目的 `pom.xml` 中添加 Apache PDFBox 依赖。\n\n```xml\n&lt;dependency&gt;\n    &lt;groupId&gt;org.apache.pdfbox&lt;/groupId&gt;\n    &lt;artifactId&gt;pdfbox&lt;/artifactId&gt;\n    &lt;version&gt;2.0.27&lt;/version&gt; &lt;!-- Spring Boot 2.x 推荐版本 --&gt;\n    &lt;!-- 对于 Spring Boot 3.x，推荐使用 3.x.x 版本 --&gt;\n&lt;/dependency&gt;\n```\n\n### 创建 PDF 下载接口\n在控制器中生成一个简单的 PDF 文件并提供下载。\n\n```java\n@RestController\npublic class PdfController {\n\n    @GetMapping(&quot;/download-pdf&quot;)\n    public void downloadPdf(HttpServletResponse response) throws IOException {\n        try (PDDocument document = new PDDocument()) {\n            PDPage page = new PDPage();\n            document.addPage(page);\n\n            try (PDPageContentStream contentStream = new PDPageContentStream(document, page)) {\n                contentStream.beginText();\n                contentStream.setFont(PDType1Font.HELVETICA_BOLD, 12);\n                contentStream.newLineAtOffset(100, 700);\n                contentStream.showText(&quot;Hello, PDFBox in Spring Boot!&quot;);\n                contentStream.endText();\n            }\n\n            response.setContentType(&quot;application/pdf&quot;);\n            response.setHeader(&quot;Content-Disposition&quot;, &quot;attachment; filename=hello.pdf&quot;);\n\n            document.save(response.getOutputStream());\n        }\n    }\n}\n```\n\n## 解决的问题\n\n集成 Apache PDFBox 解决了在应用中以编程方式处理 PDF 的需求：\n\n- **动态文档生成**：根据业务数据生成 PDF 格式的合同、发票、证书等。\n- **内容提取与分析**：从现有的 PDF 文件中提取文本或图片，用于数据分析或内容索引。\n- **PDF 操作**：实现 PDF 文件的合并、拆分、添加水印等自动化处理。\n- **表单填充**：自动填充 PDF 表单字段（AcroForms）。\n\n## 核心功能与使用方法\n\n- **`PDDocument`**: 代表一个 PDF 文档对象，是所有操作的入口。\n- **`PDPage`**: 代表 PDF 中的一个页面。\n- **`PDPageContentStream`**: 用于向页面中添加内容（文本、图片、形状）的流。\n- **字体处理**: PDFBox 支持标准 Type 1 字体，也支持加载外部的 TrueType (`.ttf`) 字体。\n- **文本提取**: 使用 `PDFTextStripper` 类可以方便地从 PDF 中提取所有文本内容。\n\n## 注意事项\n\n- **字体处理**：默认的 Type 1 字体不支持中文字符。要显示中文，必须加载包含中文字形的 `.ttf` 字体文件，并将其随应用一起部署。\n  ```java\n  // 加载外部字体\n  File fontFile = new File(&quot;path/to/your/font.ttf&quot;);\n  PDType0Font font = PDType0Font.load(document, fontFile);\n  contentStream.setFont(font, 12);\n  ```\n- **资源管理**：`PDDocument` 和 `PDPageContentStream` 都需要被显式关闭以释放资源。强烈建议使用 `try-with-resources` 语句。\n- **性能**：处理非常大的或复杂的 PDF 文件可能会消耗较多内存和 CPU，操作时应考虑其性能影响。\n\n## 常见问题排查\n\n### 1. 中文字符显示为乱码或空白\n**原因**：使用了不支持中文的默认字体。\n**解决**：如 “注意事项” 中所述，加载一个支持中文的 TrueType 字体文件（如思源黑体、微软雅黑等），并在 `contentStream` 中设置该字体。\n\n### 2. `IOException: Font not found`\n**原因**：尝试加载一个不存在的字体文件。\n**解决**：确保字体文件的路径正确，并且应用有权限读取该文件。通常建议将字体文件放在项目的 `src/main/resources` 目录下，并通过 Classpath 获取。\n\n### 3. 生成的 PDF 布局混乱\n**原因**：PDF 的内容布局是基于坐标系统的，需要精确计算每个元素的位置。手动计算非常繁琐。\n**解决**：对于复杂的布局（如表格、多列文本），直接使用 PDFBox 的低级 API 会非常困难。可以考虑引入更高层次的库（如 [OpenPDF](https://github.com/LibrePDF/OpenPDF) 或商业库 iText），它们提供了更方便的布局管理器。"
  }
]