[
  {
    "name": "{{ }} (文本插值)",
    "summary": "将响应式数据的值渲染为纯文本 (Renders the value of reactive data as plain text)",
    "examples": [
      {
        "description": "显示一个消息变量",
        "code": "<span>Message: {{ msg }}</span>"
      },
      {
        "description": "使用 JavaScript 表达式",
        "code": "<p>Is the task complete? {{ done ? 'Yes' : 'No' }}</p>"
      },
      {
        "description": "调用一个方法",
        "code": "<time :title=\"toTitleDate(date)\">{{ formatDate(date) }}</time>"
      }
    ],
    "notes": "插值表达式 (Mustache) 只能用于元素的文本内容。要动态绑定 HTML 属性，请使用 `v-bind`。",
    "shell_type": "Vue Template"
  },
  {
    "name": "v-html",
    "summary": "更新元素的 innerHTML，用于渲染原始 HTML 内容 (Updates an element's innerHTML to render raw HTML content)",
    "examples": [
      {
        "description": "渲染一个包含 HTML 标签的字符串",
        "code": "<div v-html=\"rawHtml\"></div>"
      }
    ],
    "notes": "警告：在网站上动态渲染任意 HTML 是非常危险的，因为它很容易导致 XSS 攻击。只在内容安全可信时再使用 `v-html`，并且永远不要用在用户提交的内容上。",
    "shell_type": "Vue Template"
  },
  {
    "name": "v-bind",
    "summary": "动态地绑定一个或多个 HTML attribute 或一个组件 prop (Dynamically binds one or more HTML attributes, or a component prop)",
    "examples": [
      {
        "description": "绑定元素的 id",
        "code": "<div v-bind:id=\"dynamicId\"></div>"
      },
      {
        "description": "简写形式",
        "code": "<div :id=\"dynamicId\"></div>"
      },
      {
        "description": "动态绑定 class (对象语法)",
        "code": "<div :class=\"{ active: isActive, 'text-danger': hasError }\"></div>"
      },
      {
        "description": "动态绑定 class (数组语法)",
        "code": "<div :class=\"[activeClass, errorClass]\"></div>"
      },
      {
        "description": "绑定一个布尔值属性 (如 disabled)",
        "code": "<button :disabled=\"isButtonDisabled\">Button</button>"
      },
      {
        "description": "动态绑定多个属性",
        "code": "<form v-bind=\"formAttributes\"></form>"
      }
    ],
    "notes": "`:` 是 `v-bind:` 的简写。这是 Vue 中最常用和最重要的指令之一。",
    "shell_type": "Vue Template"
  },
  {
    "name": "v-if / v-else / v-else-if",
    "summary": "根据表达式的真假来条件性地渲染一个块 (Conditionally render a block based on the truthiness of an expression)",
    "examples": [
      {
        "description": "基本的条件渲染",
        "code": "<p v-if=\"seen\">Now you see me</p>"
      },
      {
        "description": "完整的 v-if, v-else-if, v-else 链",
        "code": "<div v-if=\"type === 'A'\">\n  A\n</div>\n<div v-else-if=\"type === 'B'\">\n  B\n</div>\n<div v-else>\n  Not A/B\n</div>"
      },
      {
        "description": "在 <template> 上使用 v-if 对元素进行分组",
        "code": "<template v-if=\"isLoggedIn\">\n  <button>Logout</button>\n  <p>Welcome back!</p>\n</template>"
      }
    ],
    "notes": "`v-if` 是“真正”的条件渲染，因为它会确保在切换时，条件块内的元素和组件都会被销毁与重建。相比之下, `v-show` 只是切换 `display` 样式。",
    "shell_type": "Vue Template"
  },
  {
    "name": "v-for",
    "summary": "基于源数据多次渲染一个元素或模板块 (Renders an element or template block multiple times based on a source data)",
    "examples": [
      {
        "description": "遍历一个对象数组",
        "code": "<li v-for=\"item in items\" :key=\"item.id\">\n  {{ item.text }}\n</li>"
      },
      {
        "description": "遍历数组并获取索引",
        "code": "<li v-for=\"(item, index) in items\" :key=\"item.id\">\n  {{ index }} - {{ item.text }}\n</li>"
      },
      {
        "description": "遍历一个对象的属性",
        "code": "<div v-for=\"(value, key, index) in myObject\" :key=\"key\">\n  {{ index }}. {{ key }}: {{ value }}\n</div>"
      },
      {
        "description": "遍历一个整数范围",
        "code": "<span v-for=\"n in 10\" :key=\"n\">{{ n }}</span>"
      }
    ],
    "notes": "始终为 `v-for` 提供一个唯一的 `:key` 属性，以帮助 Vue 跟踪每个节点的身份，从而高效地更新 DOM。不要在同一个元素上同时使用 `v-if` 和 `v-for`。",
    "shell_type": "Vue Template"
  },
  {
    "name": "v-on",
    "summary": "绑定事件监听器，调用方法或内联表达式 (Attaches an event listener, calling a method or an inline expression)",
    "examples": [
      {
        "description": "调用一个方法",
        "code": "<button v-on:click=\"increment\">Increment</button>"
      },
      {
        "description": "简写形式",
        "code": "<button @click=\"increment\">Increment</button>"
      },
      {
        "description": "使用内联表达式并访问原生 $event 对象",
        "code": "<button @click=\"say('hello', $event)\">Say Hello</button>"
      },
      {
        "description": "使用事件修饰符阻止默认行为",
        "code": "<form @submit.prevent=\"onSubmit\">...</form>"
      },
      {
        "description": "使用按键修饰符",
        "code": "<input @keyup.enter=\"submitForm\" />"
      }
    ],
    "notes": "`@` 是 `v-on:` 的简写。常用的事件修饰符包括 `.prevent`, `.stop`, `.once`, `.capture`。",
    "shell_type": "Vue Template"
  },
  {
    "name": "v-model",
    "summary": "在表单输入元素或组件上创建双向数据绑定 (Creates a two-way binding on a form input element or a component)",
    "examples": [
      {
        "description": "绑定到文本输入框",
        "code": "<input v-model=\"message\" placeholder=\"edit me\">"
      },
      {
        "description": "绑定到单个复选框 (布尔值)",
        "code": "<input type=\"checkbox\" v-model=\"isChecked\">"
      },
      {
        "description": "绑定到多个复选框 (数组)",
        "code": "<input type=\"checkbox\" v-model=\"checkedNames\" value=\"Jack\">"
      },
      {
        "description": "绑定到单选按钮",
        "code": "<input type=\"radio\" v-model=\"picked\" value=\"One\">"
      },
      {
        "description": "绑定到下拉选择框",
        "code": "<select v-model=\"selected\">\n  <option>A</option>\n</select>"
      },
      {
        "description": "使用修饰符 `.lazy`, `.number`, `.trim`",
        "code": "<input v-model.lazy.trim=\"msg\" />"
      }
    ],
    "notes": "`v-model` 是 `v-bind:value` 和 `v-on:input` (或特定元素的其他事件) 的语法糖。修饰符：`.lazy` 在 `change` 事件后同步, `.number` 将输入转为数字, `.trim` 去除首尾空格。",
    "shell_type": "Vue Template"
  },
  {
    "name": "ref()",
    "summary": "接受一个内部值，返回一个响应式的、可更改的 ref 对象 (Takes an inner value and returns a reactive and mutable ref object)",
    "examples": [
      {
        "description": "创建一个 ref 并在脚本和模板中使用",
        "code": "<script setup>\nimport { ref } from 'vue'\n\nconst count = ref(0)\n\nfunction increment() {\n  // 在脚本中，需要通过 .value 访问\n  count.value++\n}\n</script>\n\n<template>\n  <!-- 在模板中，会自动解包，无需 .value -->\n  <button @click=\"increment\">{{ count }}</button>\n</template>"
      }
    ],
    "notes": "`ref` 用于使任何值类型（包括基本类型如字符串、数字，以及对象）具有响应性。在 `<script setup>` 的脚本部分访问或修改其值时，必须使用 `.value`。",
    "shell_type": "Vue Composition API"
  },
  {
    "name": "reactive()",
    "summary": "返回一个对象的响应式代理。只能用于对象类型 (Returns a reactive proxy of an object. Only works for object types)",
    "examples": [
      {
        "description": "创建一个响应式状态对象",
        "code": "<script setup>\nimport { reactive } from 'vue'\n\nconst state = reactive({ count: 0, user: { name: 'Vue' } })\n\nfunction increment() {\n  state.count++\n}\n</script>\n\n<template>\n  <button @click=\"increment\">{{ state.count }}</button>\n  <p>User: {{ state.user.name }}</p>\n</template>"
      }
    ],
    "notes": "`reactive()` 只能用于对象（包括数组和 Map、Set 等内置类型）。它会深度地将对象的所有属性都变为响应式。与 `ref` 不同，访问其属性时无需 `.value`。",
    "shell_type": "Vue Composition API"
  },
  {
    "name": "computed()",
    "summary": "创建一个基于响应式依赖进行缓存的计算属性 ref (Creates a computed ref that is cached based on its reactive dependencies)",
    "examples": [
      {
        "description": "创建一个只读的计算属性",
        "code": "<script setup>\nimport { ref, computed } from 'vue'\n\nconst firstName = ref('John')\nconst lastName = ref('Doe')\n\nconst fullName = computed(() => `${firstName.value} ${lastName.value}`)\n</script>\n\n<template>\n  <p>Full Name: {{ fullName }}</p>\n</template>"
      },
      {
        "description": "创建一个可写的计算属性",
        "code": "const fullName = computed({\n  get: () => `${firstName.value} ${lastName.value}`,\n  set: (newValue) => {\n    [firstName.value, lastName.value] = newValue.split(' ')\n  }\n})"
      }
    ],
    "notes": "计算属性是基于其响应式依赖进行缓存的。只有在相关依赖发生改变时它们才会重新求值。这使得它们比每次都执行的方法更高效。",
    "shell_type": "Vue Composition API"
  },
  {
    "name": "watch()",
    "summary": "侦听一个或多个响应式数据源，并在数据源变化时执行回调函数 (Watches one or more reactive data sources and invokes a callback when they change)",
    "examples": [
      {
        "description": "侦听一个 ref",
        "code": "import { ref, watch } from 'vue'\nconst count = ref(0)\nwatch(count, (newCount, oldCount) => {\n  console.log(`count changed from ${oldCount} to ${newCount}`)\n})"
      },
      {
        "description": "侦听一个响应式对象的 getter",
        "code": "const state = reactive({ count: 0 })\nwatch(\n  () => state.count,\n  (count) => { console.log(`count is: ${count}`) }\n)"
      },
      {
        "description": "侦听多个数据源",
        "code": "watch([fooRef, barRef], ([newFoo, newBar]) => {\n  console.log(newFoo, newBar)\n})"
      },
      {
        "description": "深度侦听对象",
        "code": "const state = reactive({ nested: { count: 0 } })\nwatch(state, (newState) => {\n  // 默认情况下，对响应式对象的侦听是深度的\n  console.log('State changed:', newState)\n}, { deep: true }) // 对于 ref 包含的对象，需要 deep:true"
      }
    ],
    "notes": "`watch` 用于在数据变化时执行副作用，例如异步操作或 API 调用。使用 `immediate: true` 选项可以在侦听开始时立即执行一次回调。",
    "shell_type": "Vue Composition API"
  },
  {
    "name": "watchEffect()",
    "summary": "立即运行一个函数，同时响应式地追踪其依赖，并在依赖更改时重新执行 (Runs a function immediately while reactively tracking its dependencies and re-runs it whenever they change)",
    "examples": [
      {
        "description": "自动追踪依赖并执行副作用",
        "code": "import { ref, watchEffect } from 'vue'\n\nconst userID = ref(1)\n\nwatchEffect(async () => {\n  // 当 userID.value 变化时，此函数会自动重新执行\n  const response = await fetch(`https://api.example.com/users/${userID.value}`)\n  const data = await response.json()\n  console.log(data)\n})"
      }
    ],
    "notes": "`watchEffect` 不需要手动指定依赖源。它会自动收集在同步执行期间所有被访问的响应式属性作为依赖。比 `watch` 更简洁，但对依赖的控制不那么精确。",
    "shell_type": "Vue Composition API"
  },
  {
    "name": "生命周期钩子 (Lifecycle Hooks)",
    "summary": "在组件生命周期的不同阶段执行代码 (Execute code at different stages of the component's lifecycle)",
    "examples": [
      {
        "description": "在组件挂载后获取数据",
        "code": "import { onMounted } from 'vue'\nonMounted(() => {\n  console.log('Component has been mounted!')\n  // 通常在这里执行 API 调用\n})"
      },
      {
        "description": "在组件卸载前清理资源",
        "code": "import { onUnmounted } from 'vue'\nlet intervalId\nonMounted(() => {\n  intervalId = setInterval(() => { /* ... */ }, 1000)\n})\nonUnmounted(() => {\n  console.log('Component is being unmounted.')\n  clearInterval(intervalId)\n})"
      },
      {
        "description": "在组件更新后与 DOM 交互",
        "code": "import { onUpdated } from 'vue'\nonUpdated(() => {\n  console.log('Component DOM has been updated.')\n})"
      },
      {
        "description": "其他常用钩子",
        "code": "import { onBeforeMount, onBeforeUpdate, onBeforeUnmount } from 'vue'\n\nonBeforeMount(() => { /* ... */ })\nonBeforeUpdate(() => { /* ... */ })\nonBeforeUnmount(() => { /* ... */ })"
      }
    ],
    "notes": "所有生命周期钩子都应在 `<script setup>` 或 `setup()` 的顶层同步调用。它们提供了在组件不同生命阶段执行副作用的机会。",
    "shell_type": "Vue Composition API"
  },
  {
    "name": "Vue 组件基础 (Component Basics)",
    "summary": "介绍 Vue 的核心——单文件组件 (SFC)，它将模板、逻辑和样式封装在单个 `.vue` 文件中，实现代码的高效组织和复用。",
    "notes": "# Vue 组件基础 (Component Basics)\n\n## 示例\n\n一个典型的单文件组件 (`MyComponent.vue`):\n\n```vue\n<script setup>\nimport { ref } from 'vue'\nconst count = ref(0)\n</script>\n\n<template>\n  <button @click=\"count++\">You clicked me {{ count }} times.</button>\n</template>\n\n<style scoped>\nbutton {\n  color: #42b983;\n  font-size: 1em;\n  border-radius: 8px;\n  padding: 10px 20px;\n}\n</style>\n```\n\n## 解决的问题\n\n单文件组件 (SFC) 解决了传统 Web 开发中 HTML, CSS 和 JavaScript 分离导致的维护性问题：\n\n- **代码组织**：将与一个组件相关的所有代码集中在一个地方，而不是在多个文件中寻找。\n- **代码复用**：组件可以像积木一样被轻松地导入和复用在应用的不同地方。\n- **作用域样式**：通过 `scoped` 属性，可以编写只作用于当前组件的 CSS，避免全局样式污染。\n- **更好的开发体验**：语法高亮、代码提示和构建时优化都基于 SFC 结构。\n\n## 核心功能与使用方法\n\n### 1. `<script setup>`\nVue 3 推荐的组合式 API 语法糖。在此标签内：\n- 顶层导入的组件、指令和变量可以直接在 `<template>` 中使用。\n- 使用 `ref`, `reactive` 等 API 创建响应式状态。\n- 使用 `defineProps`, `defineEmits` 等宏来定义组件的接口。\n\n### 2. `<template>`\n定义组件的 HTML 结构。可以使用所有 Vue 的模板语法，如插值、指令和对 `<script setup>` 中定义状态的访问。\n\n### 3. `<style scoped>`\n定义组件的样式。`scoped` 属性会给模板中的所有元素添加一个唯一的 data-attribute，并相应地修改 CSS 选择器，从而实现样式隔离。\n\n### 4. 组件注册\n- **局部注册 (推荐)**：在父组件的 `<script setup>` 中直接 `import` 子组件即可使用。\n  ```js\n  import MyComponent from './MyComponent.vue'\n  ```\n- **全局注册**：在 `main.js` 中注册，可以在应用的任何地方使用，但会增加初始包体积。\n  ```js\n  import { createApp } from 'vue'\n  import App from './App.vue'\n  import MyComponent from './MyComponent.vue'\n\n  const app = createApp(App)\n  app.component('MyComponent', MyComponent)\n  app.mount('#app')\n  ```\n\n## 注意事项\n\n- **组件命名**：文件名推荐使用帕斯卡命名法 (PascalCase)，如 `MyComponent.vue`。在模板中使用时，可以用帕斯卡命名法 `<MyComponent/>` 或短横线命名法 `<my-component/>`。\n- **根元素**：Vue 3 的组件可以有多个根元素，无需像 Vue 2 那样必须包裹在一个 `<div>` 中。\n\n## 常见问题排查\n\n### 1. 组件未渲染或显示警告\n**原因**：组件可能未正确导入或注册。\n**排查**：\n- 检查 `import` 路径是否正确。\n- 如果是全局注册，确认 `app.component()` 是否在应用挂载前被调用。\n\n### 2. 样式不生效或影响了其他组件\n**原因**：忘记添加 `scoped` 属性，导致样式成为全局样式。\n**解决**：为 `<style>` 标签添加 `scoped` 属性：`<style scoped>`。"
  },
  {
    "name": "组件 Props (Component Props)",
    "summary": "实现父组件向子组件单向数据传递的核心机制，支持类型校验、默认值和必需性声明。",
    "notes": "# 组件 Props (Component Props)\n\n## 示例\n\n**父组件 (`Parent.vue`)**\n```vue\n<script setup>\nimport ChildComponent from './ChildComponent.vue'\nimport { ref } from 'vue'\n\nconst greeting = ref('Hello from parent')\nconst user = { id: 1, name: 'John Doe' }\n</script>\n\n<template>\n  <ChildComponent :message=\"greeting\" :user-info=\"user\" />\n</template>\n```\n\n**子组件 (`ChildComponent.vue`)**\n```vue\n<script setup>\nconst props = defineProps({\n  message: {\n    type: String,\n    required: true\n  },\n  userInfo: {\n    type: Object,\n    default: () => ({ id: 0, name: 'Guest' }) // 对象或数组的默认值需用工厂函数\n  }\n})\n</script>\n\n<template>\n  <h2>{{ message }}</h2>\n  <p>User: {{ userInfo.name }}</p>\n</template>\n```\n\n## 解决的问题\n\nProps 是父子组件通信的基石，解决了：\n- **数据传递**：让父组件可以向子组件传递动态或静态的数据。\n- **组件可配置性**：通过接收不同的 props，同一个组件可以展现不同的内容或行为，大大提高了组件的复用性。\n- **单向数据流**：规定了数据只能从父级流向子级，使得应用的数据流向更清晰，易于追踪和调试。\n\n## 核心功能与使用方法\n\n### 1. 声明 Props\n使用 `<script setup>` 中的 `defineProps` 宏来声明。\n- **数组语法** (简单，但无校验): `defineProps(['message', 'userInfo'])`\n- **对象语法** (推荐，支持校验):\n  ```js\n  defineProps({\n    propName: String, // 基础类型检查\n    propWithDetails: {\n      type: [String, Number], // 多种类型\n      required: true, // 是否必需\n      default: 'default value' // 默认值\n    }\n  })\n  ```\n\n### 2. Prop 类型\n可以是 `String`, `Number`, `Boolean`, `Array`, `Object`, `Date`, `Function`, `Symbol`。\n\n### 3. Prop 传递\n- **静态值**: `prop-name=\"a static value\"`\n- **动态值** (使用 `v-bind` 或 `:`): `:prop-name=\"dynamicValue\"`\n- **传递所有对象属性**: `<ChildComponent v-bind=\"userObject\" />`\n\n## 注意事项\n\n- **单向数据流**：子组件**不应该**直接修改 prop 的值。如果需要修改，应 `emit` 一个事件通知父组件来更改，或者将 prop 的值作为初始值赋给子组件本地的一个 `ref`。\n- **命名规范**：在 `<script>` 中使用驼峰命名法 (camelCase)，如 `userInfo`。在 `<template>` 中传递时，推荐使用短横线命名法 (kebab-case)，如 `user-info`。Vue 会自动转换。\n\n## 常见问题排查\n\n### 1. Prop 在子组件中是 `undefined`\n**原因**：父组件未传递该 prop，或者传递时的 prop 名称拼写错误（注意驼峰与短横线写法的对应）。\n**排查**：检查父组件的模板，确认 prop 是否被正确绑定和传递。\n\n### 2. 控制台出现 \"Invalid prop\" 警告\n**原因**：传递的 prop 值的类型与子组件中声明的 `type` 不匹配。\n**排查**：检查父组件传递的值的类型是否符合子组件的预期。\n\n### 3. 尝试修改 Prop 时报错\n**原因**：违反了单向数据流原则。\n**解决**：\n  - 创建一个本地的 ref 并用 prop 初始化：`const localValue = ref(props.initialValue)`。\n  - 或者，通知父组件更新：`emit('updateValue', newValue)`。"
  },
  {
    "name": "组件事件 (Component Emits)",
    "summary": "允许子组件向父组件发送消息（触发事件），实现子组件到父组件的数据和状态通信。",
    "notes": "# 组件事件 (Component Emits)\n\n## 示例\n\n**子组件 (`CustomButton.vue`)**\n```vue\n<script setup>\n// 声明组件会触发的事件\nconst emit = defineEmits(['button-click'])\n\nfunction handleClick() {\n  // 触发事件，并传递一个 payload\n  emit('button-click', { timestamp: Date.now() })\n}\n</script>\n\n<template>\n  <button @click=\"handleClick\">Click Me</button>\n</template>\n```\n\n**父组件 (`Parent.vue`)**\n```vue\n<script setup>\nimport CustomButton from './CustomButton.vue'\n\nfunction onCustomClick(payload) {\n  alert(`Button clicked at: ${payload.timestamp}`)\n}\n</script>\n\n<template>\n  <CustomButton @button-click=\"onCustomClick\" />\n</template>\n```\n\n## 解决的问题\n\n`Emits` (事件) 是子组件与父组件通信的桥梁，解决了 props 单向数据流的反向通信问题：\n- **子-父通信**：当子组件内部发生某个事件（如用户点击、表单提交）或状态变化时，它可以通过触发事件来通知父组件。\n- **解耦组件**：子组件只负责触发事件，不关心谁在监听或如何处理。父组件则监听这些事件并执行相应的逻辑，这使得组件之间保持松散耦合。\n\n## 核心功能与使用方法\n\n### 1. 声明事件\n使用 `<script setup>` 中的 `defineEmits` 宏来声明组件可以触发的事件列表。\n- **数组语法** (简单): `const emit = defineEmits(['submit', 'cancel'])`\n- **对象语法** (推荐，支持事件校验): 允许你为事件的 payload 定义一个校验函数。\n  ```js\n  const emit = defineEmits({\n    // 无校验\n    click: null,\n    // 带校验\n    submit: (payload) => {\n      // 如果 payload 有效，返回 true，否则返回 false\n      return payload.email && payload.password\n    }\n  })\n  ```\n\n### 2. 触发事件\n调用 `defineEmits` 返回的 `emit` 函数来触发事件。\n- **无参数**: `emit('close')`\n- **有参数**: `emit('update', newValue)`\n\n### 3. 在父组件中监听\n使用 `v-on` 指令（简写为 `@`）来监听子组件触发的事件。\n`<MyComponent @my-event=\"handleEvent\" />`\n\n## 注意事项\n\n- **事件命名**：推荐使用短横线命名法 (kebab-case) 来命名事件，如 `item-selected`。这与原生 DOM 事件的命名习惯保持一致。\n- **文档化**：显式地通过 `defineEmits` 声明事件是一个非常好的实践，它让其他开发者能清晰地了解该组件的 API。\n\n## 常见问题排查\n\n### 1. 父组件的事件处理器未被调用\n**原因**：\n- 事件名称拼写错误。在子组件 `emit` 的名称和父组件 `@` 监听的名称不一致。\n- 子组件的事件触发逻辑未被执行到。\n\n**排查**：\n- 仔细核对子组件 `emit('event-name')` 和父组件 `<Child @event-name=\"handler\">` 中的 `'event-name'` 是否完全相同。\n- 在子组件的事件触发函数中加入 `console.log`，确认函数是否被调用。\n\n### 2. 事件处理器接收到的 payload 是 `undefined`\n**原因**：在子组件调用 `emit` 时忘记传递第二个参数。\n**解决**：确保调用形式为 `emit('my-event', dataToPass)`。"
  },
  {
    "name": "组件上的 v-model (v-model on Components)",
    "summary": "在自定义组件上实现双向数据绑定的语法糖，简化父子组件间状态同步的编码。",
    "notes": "# 组件上的 v-model (v-model on Components)\n\n## 示例\n\n**子组件 (`CustomInput.vue`)**\n```vue\n<script setup>\n// 1. 接收 modelValue prop\ndeclareProps({ modelValue: String })\n\n// 2. 声明 update:modelValue 事件\nconst emit = defineEmits(['update:modelValue'])\n</script>\n\n<template>\n  <input \n    :value=\"modelValue\" \n    @input=\"emit('update:modelValue', $event.target.value)\" \n  />\n</template>\n```\n\n**父组件 (`Parent.vue`)**\n```vue\n<script setup>\nimport CustomInput from './CustomInput.vue'\nimport { ref } from 'vue'\n\nconst text = ref('initial value')\n</script>\n\n<template>\n  <CustomInput v-model=\"text\" />\n  <p>Current text: {{ text }}</p>\n</template>\n```\n\n## 解决的问题\n\n`v-model` 在组件上的应用，本质上是 `props` 和 `emits` 的组合语法糖。它解决了**状态同步的样板代码**问题。\n\n没有 `v-model` 时，你需要：\n1.  在父组件中传递一个 `value` prop。\n2.  在父组件中监听一个 `update` 事件。\n3.  在子组件中接收 `value` prop。\n4.  在子组件中当值变化时 `emit` 一个 `update` 事件。\n\n`v-model` 将这个常用模式简化为一行代码，让意图更清晰。\n\n## 核心功能与使用方法\n\n### 1. 默认 `v-model`\n-   `<CustomInput v-model=\"text\" />`\n\n    这等同于：\n\n-   `<CustomInput :modelValue=\"text\" @update:modelValue=\"text = $event\" />`\n\n    **子组件实现**：必须接收一个名为 `modelValue` 的 prop，并触发一个名为 `update:modelValue` 的事件。\n\n### 2. 带参数的 `v-model`\n可以为一个组件绑定多个 `v-model`。\n-   `<UserProfile v-model:firstName=\"first\" v-model:lastName=\"last\" />`\n\n    这等同于：\n\n-   `<UserProfile :firstName=\"first\" @update:firstName=\"first = $event\" :lastName=\"last\" @update:lastName=\"last = $event\" />`\n\n    **子组件实现**：需要接收名为 `firstName` 和 `lastName` 的 prop，并触发 `update:firstName` 和 `update:lastName` 事件。\n\n### 3. 自定义修饰符\n`v-model` 也支持自定义修饰符。\n-   `<CustomInput v-model.capitalize=\"myText\" />`\n\n    **子组件实现**：可以通过 `modelModifiers` prop 访问修饰符。`modelModifiers` 是一个对象，如果修饰符存在，其值为 `true`。\n\n    ```js\n    const props = defineProps({ \n      modelValue: String,\n      modelModifiers: { default: () => ({}) } \n    })\n\n    // 在 emit 前处理\n    let value = event.target.value\n    if (props.modelModifiers.capitalize) {\n      value = value.charAt(0).toUpperCase() + value.slice(1)\n    }\n    emit('update:modelValue', value)\n    ```\n\n## 注意事项\n\n- **显式声明**：在子组件中，必须使用 `defineProps` 和 `defineEmits` 显式声明 `modelValue` (或自定义参数名) prop 和对应的 `update:*` 事件，这是最佳实践。\n\n## 常见问题排查\n\n### 1. `v-model` 绑定不生效\n**原因**：\n-   子组件接收的 prop 名称不是 `modelValue` (对于默认 v-model)。\n-   子组件触发的事件名称不是 `update:modelValue`。\n-   `defineProps` 或 `defineEmits` 未正确声明。\n\n**排查**：严格按照 `v-model` 的协议检查子组件的 props 和 emits 定义。\n\n### 2. 如何在 `setup` 中直接修改 prop？\n**原因**：不能直接修改。需要通过计算属性来模拟。\n**解决**：\n```js\nimport { computed } from 'vue'\n\nconst props = defineProps({ modelValue: String })\nconst emit = defineEmits(['update:modelValue'])\n\nconst localValue = computed({\n  get() {\n    return props.modelValue\n  },\n  set(value) {\n    emit('update:modelValue', value)\n  }\n})\n\n// 在模板中使用 localValue\n<input v-model=\"localValue\" />\n```"
  },
  {
    "name": "Provide / Inject",
    "summary": "实现祖先组件向其所有后代组件传递数据或方法，有效解决深层组件嵌套（“prop drilling”）的问题。",
    "notes": "# Provide / Inject\n\n## 示例\n\n**祖先组件 (`Ancestor.vue`)**\n```vue\n<script setup>\nimport { provide, ref } from 'vue'\nimport Child from './Child.vue'\n\n// 提供一个静态值\nprovide('theme', 'dark')\n\n// 提供一个响应式的值\nconst userLocation = ref('New York')\nprovide('location', userLocation)\n\n// 提供一个方法\nconst updateUserLocation = (newLocation) => {\n  userLocation.value = newLocation\n}\nprovide('updateLocation', updateUserLocation)\n</script>\n\n<template>\n  <Child />\n</template>\n```\n\n**后代组件 (`Descendant.vue`)** - 可能是 Child 的子组件\n```vue\n<script setup>\nimport { inject } from 'vue'\n\n// 注入静态值\nconst theme = inject('theme')\n\n// 注入响应式值\nconst location = inject('location')\n\n// 注入方法\nconst updateLocation = inject('updateLocation')\n</script>\n\n<template>\n  <p>Theme: {{ theme }}</p>\n  <p>Current Location: {{ location }}</p>\n  <button @click=\"updateLocation('Tokyo')\">Change Location to Tokyo</button>\n</template>\n```\n\n## 解决的问题\n\n`Provide / Inject` 主要用于解决 **“属性透传” (Prop Drilling)** 问题。当一个深层嵌套的子组件需要来自祖先组件的数据时，如果没有 `Provide/Inject`，就需要将这个 prop 逐层传递过所有中间组件，即使这些中间组件本身并不需要这个 prop。这使得代码冗长且难以维护。\n\n`Provide / Inject` 就像一个“传送门”，允许数据直接从祖先传送到任何后代，无论层级多深。\n\n## 核心功能与使用方法\n\n### 1. `provide(key, value)`\n在祖先组件中调用，用于“提供”数据。\n-   `key`: 可以是一个字符串，或者更推荐使用 `Symbol` 以避免命名冲突。\n-   `value`: 任何类型的值，包括 `ref`, `reactive` 对象或方法。\n\n### 2. `inject(key, defaultValue)`\n在后代组件中调用，用于“注入”由祖先提供的数据。\n-   `key`: 必须与 `provide` 中使用的 `key` 完全匹配。\n-   `defaultValue` (可选): 如果祖先没有提供该 `key` 对应的数据，`inject` 会返回这个默认值。如果没有默认值，会返回 `undefined`。\n\n### 3. 响应性\n-   如果你 `provide` 一个 `ref` 或 `reactive` 对象，那么当这个响应式对象在祖先组件中发生变化时，所有 `inject` 了它的后代组件都会自动更新。\n-   如果 `provide` 的是一个普通值（如字符串或数字），它是非响应式的。\n\n## 注意事项\n\n- **非响应式数据源**：`Provide / Inject` 的绑定本身不是响应式的。如果你希望数据更新能通知到后代，你必须提供一个响应式对象。\n- **数据来源不明确**：与 props 不同，你无法在后代组件中轻易地看出注入的数据来自哪个祖先。这可能会增加调试的复杂性。因此，它通常被用于提供那些“全局性”的、不常变化的数据，如主题、当前用户信息、i18n 函数等。\n- **推荐使用 Symbol 作为 Key**：为了防止在大型应用或插件中发生命名冲突，推荐使用 `Symbol` 来作为 `provide` 的 `key`。\n  ```js\n  // keys.js\n  export const themeKey = Symbol()\n\n  // Ancestor.vue\n  import { themeKey } from './keys.js'\n  provide(themeKey, 'dark')\n\n  // Descendant.vue\n  import { themeKey } from './keys.js'\n  const theme = inject(themeKey)\n  ```\n\n## 常见问题排查\n\n### 1. 注入的值是 `undefined`\n**原因**：\n-   `provide` 和 `inject` 使用的 `key` 不匹配。\n-   `inject` 所在的组件并非 `provide` 所在组件的后代。\n\n**解决**：\n-   检查 `key` 的拼写和类型。如果使用 `Symbol`，确保导入的是同一个 `Symbol` 实例。\n-   在 `inject` 中提供一个默认值以避免运行时错误：`const theme = inject('theme', 'light')`。\n\n### 2. 注入的数据不更新\n**原因**：祖先组件 `provide` 的是一个非响应式的值。\n**解决**：确保 `provide` 的值是一个 `ref` 或 `reactive` 对象。例如，使用 `provide('my-value', ref(10))` 而不是 `provide('my-value', 10)`。"
  },
  {
    "name": "插槽 (Slots)",
    "summary": "最灵活的组件内容分发机制，允许父组件将自定义模板内容嵌入到子组件的指定位置。",
    "notes": "# 插槽 (Slots)\n\n插槽是 Vue 组件中最强大的功能之一，它允许你创建一个“模板占位符”，父组件可以向这个占位符中填充任何模板内容。\n\n## 解决的问题\n\n插槽解决了**组件内容灵活性**的问题。当你创建一个通用组件（如卡片、模态框、布局）时，这些组件的结构和样式是固定的，但内部的内容需要由使用它的父组件来决定。插槽就是实现这种“内容分发”的机制。\n\n## 核心功能与使用方法\n\n### 1. 默认插槽 (Default Slot)\n\n**子组件 (`Card.vue`)**\n```vue\n<template>\n  <div class=\"card\">\n    <slot>Default content if nothing is provided.</slot>\n  </div>\n</template>\n```\n\n**父组件**\n```vue\n<Card>\n  <p>This content will be placed inside the slot.</p>\n</Card>\n```\n\n### 2. 具名插槽 (Named Slots)\n\n**子组件 (`PageLayout.vue`)**\n```vue\n<template>\n  <header><slot name=\"header\"></slot></header>\n  <main><slot></slot></main> <!-- 默认插槽 -->\n  <footer><slot name=\"footer\"></slot></footer>\n</template>\n```\n\n**父组件**\n```vue\n<PageLayout>\n  <template #header>\n    <h1>My Page Title</h1>\n  </template>\n\n  <template #default>\n    <p>Main content of the page.</p>\n  </template>\n\n  <template #footer>\n    <p>Copyright 2023</p>\n  </template>\n</PageLayout>\n```\n-   使用 `v-slot` 指令，简写为 `#`。`#header` 对应 `name=\"header\"` 的插槽。\n-   `#default` 指向默认插槽。\n\n### 3. 作用域插槽 (Scoped Slots)\n\n作用域插槽允许子组件在渲染插槽时将数据传递给父组件的插槽内容。这是最强大的插槽类型。\n\n**子组件 (`UserList.vue`)**\n```vue\n<script setup>\nconst users = [{ id: 1, name: 'John' }, { id: 2, name: 'Jane' }]\n</script>\n\n<template>\n  <ul>\n    <li v-for=\"user in users\" :key=\"user.id\">\n      <!-- 将 user 对象作为属性绑定到 slot 上 -->\n      <slot :user=\"user\"></slot>\n    </li>\n  </ul>\n</template>\n```\n\n**父组件**\n```vue\n<UserList>\n  <!-- 使用 \"slotProps\" (或任意名称) 接收来自子组件的数据 -->\n  <template #default=\"slotProps\">\n    <strong>{{ slotProps.user.name }}</strong> (ID: {{ slotProps.user.id }})\n  </template>\n</UserList>\n```\n-   在父组件中，`#default=\"slotProps\"` 接收了子组件传递的所有属性，并将其作为一个对象 `slotProps`。\n-   这使得 `UserList` 组件高度可复用，父组件可以完全自定义每个列表项的渲染方式。\n\n## 注意事项\n\n- **渲染作用域**：插槽内容是在父组件的作用域中编译和渲染的，因此它可以访问父组件的数据，但不能直接访问子组件的数据。要访问子组件数据，必须通过作用域插槽。\n\n## 常见问题排查\n\n### 1. 插槽内容未显示\n**原因**：\n-   子组件模板中没有对应的 `<slot>` 标签。\n-   对于具名插槽，父组件中 `#slotName` 的名称与子组件中 `name=\"slotName\"` 不匹配。\n\n**排查**：检查子组件的 `<slot>` 标签和父组件的 `#` 指令，确保名称匹配。\n\n### 2. 无法访问子组件的数据\n**原因**：尝试在非作用域插槽中访问子组件的数据。\n**解决**：\n-   确认子组件是否通过属性绑定 (`:prop=\"data\"`) 的方式将数据暴露给了 `<slot>`。\n-   确认父组件是否通过 `v-slot=\"props\"` 或 `#default=\"props\"` 来接收这些数据。"
  },
  {
    "name": "Fallthrough Attributes (`$attrs`) 和 `defineExpose`",
    "summary": "$attrs 用于访问传递给组件但未被声明为 props 的属性，`defineExpose` 则用于向父组件暴露子组件的内部状态或方法。",
    "examples": [
      {
        "description": "使用 `$attrs` 将原生属性 (如 class, style, id) 透传给子组件的根元素。",
        "code": "<!-- MyButton.vue -->\n<template>\n  <button class=\"base-btn\">My Button</button>\n</template>\n\n<!-- Parent.vue -->\n<!-- class=\"fancy\" and id=\"main-btn\" will be automatically applied to the <button> element -->\n<MyButton class=\"fancy\" id=\"main-btn\" />"
      },
      {
        "description": "禁用属性继承并使用 `v-bind=\"$attrs\"` 将属性应用到特定内部元素。",
        "code": "<!-- CustomInput.vue -->\n<script setup>\n  defineOptions({ inheritAttrs: false })\n</script>\n<template>\n  <label>My Input:</label>\n  <!-- $attrs will contain placeholder, etc. -->\n  <input v-bind=\"$attrs\" />\n</template>\n\n<!-- Parent.vue -->\n<CustomInput placeholder=\"Enter text...\" />"
      },
      {
        "description": "使用 `defineExpose` 暴露一个公共方法，供父组件通过模板 ref 调用。",
        "code": "<!-- Child.vue -->\n<script setup>\nimport { ref } from 'vue'\nconst count = ref(0)\nconst increment = () => count.value++\ndefineExpose({ increment })\n</script>\n\n<!-- Parent.vue -->\n<script setup>\nimport { ref, onMounted } from 'vue'\nconst childRef = ref(null)\nonMounted(() => {\n  childRef.value.increment() // Calls the exposed method\n})\n</script>\n<template>\n  <Child ref=\"childRef\" />\n</template>"
      }
    ],
    "notes": "`$attrs` 对于创建高阶组件或封装第三方库组件非常有用，它可以让你轻松地将原生 HTML 属性传递下去。\n\n`defineExpose` 是 `<script setup>` 中与模板 `ref` 交互的唯一方式。默认情况下，子组件的实例是私有的，`defineExpose` 显式地定义了父组件可以访问的公共 API，这有助于更好的封装。",
    "api_type": "Component API"
  },
  {
    "name": "内置组件：Transition & TransitionGroup",
    "summary": "为元素和组件的插入、移除或顺序改变提供平滑的动画过渡效果。",
    "notes": "# 内置组件：Transition & TransitionGroup\n\n## 示例\n\n### 1. `Transition` (淡入淡出效果)\n```vue\n<script setup>\nimport { ref } from 'vue'\nconst show = ref(true)\n</script>\n\n<template>\n  <button @click=\"show = !show\">Toggle</button>\n  <Transition name=\"fade\">\n    <p v-if=\"show\">Hello Vue!</p>\n  </Transition>\n</template>\n\n<style>\n.fade-enter-active, .fade-leave-active {\n  transition: opacity 0.5s ease;\n}\n.fade-enter-from, .fade-leave-to {\n  opacity: 0;\n}\n</style>\n```\n\n### 2. `TransitionGroup` (列表动画)\n```vue\n<script setup>\nimport { ref } from 'vue'\nlet id = 0\nconst items = ref([ {id: id++, text: 'A'}, {id: id++, text: 'B'} ])\nfunction shuffle() { /* ... */}\n</script>\n\n<template>\n  <button @click=\"shuffle\">Shuffle</button>\n  <TransitionGroup name=\"list\" tag=\"ul\">\n    <li v-for=\"item in items\" :key=\"item.id\">\n      {{ item.text }}\n    </li>\n  </TransitionGroup>\n</template>\n\n<style>\n.list-move, /* 对移动中的元素应用的过渡 */\n.list-enter-active, .list-leave-active {\n  transition: all 0.5s ease;\n}\n.list-enter-from, .list-leave-to {\n  opacity: 0;\n  transform: translateX(30px);\n}\n</style>\n```\n\n## 解决的问题\n\n在 Web 应用中，元素的出现和消失如果过于突兀，会降低用户体验。`Transition` 组件解决了**UI 状态变化的视觉平滑性**问题：\n- **增强用户体验**：通过动画效果，让界面的增、删、改更加自然和直观。\n- **引导用户注意力**：动画可以有效地引导用户的视线，告知他们界面上发生了什么变化。\n- **简化动画实现**：Vue 封装了底层的动画逻辑，开发者只需关注 CSS 类名的定义，而无需手动操作 DOM 来添加或移除动画类。\n\n## 核心功能与使用方法\n\n### 1. `Transition` 组件\n-   它只能包裹**一个**直接子元素或组件。\n-   当内部元素通过 `v-if`, `v-show` 或动态组件 `<component :is=\"...\">` 切换时，`Transition` 会自动应用 CSS 过渡类。\n\n-   **过渡类名**: Vue 会在不同阶段添加/移除以下六个类：\n    -   `v-enter-from`: 进入动画的起始状态。\n    -   `v-enter-active`: 进入动画的激活状态，定义动画持续时间、延迟和缓动曲线。\n    -   `v-enter-to`: 进入动画的结束状态。\n    -   `v-leave-from`: 离开动画的起始状态。\n    -   `v-leave-active`: 离开动画的激活状态。\n    -   `v-leave-to`: 离开动画的结束状态。\n-   如果 `Transition` 组件有 `name` 属性 (如 `name=\"fade\"`)，则类名中的 `v-` 会被替换为 `name-` (如 `fade-enter-from`)。\n\n### 2. `TransitionGroup` 组件\n-   用于 `v-for` 渲染的列表。\n-   它可以包裹**多个**元素或组件。\n-   每个子元素都**必须**有一个唯一的 `key` 属性。\n-   除了支持进入/离开动画，它还支持**移动动画**，通过 `v-move` 类实现。\n-   默认渲染一个 `<span>` 标签，可以通过 `tag` prop 修改，如 `tag=\"ul\"`。\n\n### 3. JavaScript 钩子\n对于需要用 JavaScript 控制的复杂动画（如使用 GreenSock），可以监听 `@before-enter`, `@enter`, `@after-enter` 等事件。\n\n## 注意事项\n\n- **动画模式 `mode`**：当新旧元素同时切换时，可以使用 `mode=\"out-in\"` (旧元素先离开，新元素再进入) 或 `mode=\"in-out\"` 来避免跳动。\n- **性能**：复杂的列表动画可能会影响性能。对于非常大的列表，谨慎使用 `TransitionGroup`。\n\n## 常见问题排查\n\n### 1. 动画不生效\n**原因**：\n-   CSS 类名拼写错误。\n-   CSS 中未定义 `transition` 或 `animation` 属性。\n-   `Transition` 包裹了多个元素（应使用 `TransitionGroup` 或 `v-if`/`v-else`）。\n\n**排查**：使用浏览器开发者工具检查元素在动画期间是否正确添加和移除了 CSS 类。\n\n### 2. 列表动画 (`TransitionGroup`) 混乱或跳动\n**原因**：`v-for` 列表中的项目缺少唯一的 `:key` 属性。\n**解决**：确保每个列表项都有一个稳定且唯一的 `key`。"
  },
  {
    "name": "内置组件：KeepAlive",
    "summary": "缓存动态切换的组件实例，在组件切换时保留其状态或避免重新渲染，以优化性能。",
    "notes": "# 内置组件：KeepAlive\n\n## 示例\n\n### 基础用法 (缓存动态组件)\n```vue\n<script setup>\nimport { ref, shallowRef } from 'vue'\nimport CompA from './CompA.vue'\nimport CompB from './CompB.vue'\n\nconst currentComp = shallowRef(CompA)\n</script>\n\n<template>\n  <button @click=\"currentComp = CompA\">Component A</button>\n  <button @click=\"currentComp = CompB\">Component B</button>\n\n  <KeepAlive>\n    <component :is=\"currentComp\" />\n  </KeepAlive>\n</template>\n```\n当在 A 和 B 之间切换时，它们的实例会被缓存。如果在 A 中输入了一些内容，切换到 B 再切回 A，输入的内容会保留。\n\n## 解决的问题\n\n`KeepAlive` 主要解决两个问题：\n- **性能优化**：对于一些创建成本较高的组件，如果频繁地在它们之间切换，每次都销毁和重建会消耗大量性能。`KeepAlive` 通过缓存组件实例，避免了这种重复的销毁和创建过程。\n- **状态保持**：在某些场景下，用户希望在切换回一个组件时，能看到上次离开时的状态（如表单输入、滚动条位置等）。`KeepAlive` 使得这种状态保持变得非常简单。\n\n## 核心功能与使用方法\n\n### 1. 包裹动态组件\n`KeepAlive` 通常用于包裹使用 `<component :is=\"...\">` 实现的动态组件，或 `<RouterView>` (在 Vue Router 中)。\n\n### 2. 新的生命周期钩子\n当一个组件被 `KeepAlive` 缓存时，它的 `onMounted` 和 `onUnmounted` 钩子将不再被重复调用。取而代之的是两个新的钩子：\n-   `onActivated()`: 在组件被激活（从缓存中取出并显示）时调用。\n-   `onDeactivated()`: 在组件被失活（从视图中移除并存入缓存）时调用。\n\n### 3. 包含与排除 (`include` / `exclude`)\n可以通过 `include` 和 `exclude` props 来精确控制哪些组件应该被缓存。\n-   它们的值可以是字符串、正则表达式或包含这两种类型的数组。\n-   匹配的是组件的 `name` 选项。\n\n```vue\n<!-- 只缓存 A 和 B -->\n<KeepAlive :include=\"['A', 'B']\">\n  <component :is=\"view\"></component>\n</KeepAlive>\n\n<!-- 除了 C，其他都缓存 -->\n<KeepAlive :exclude=\"['C']\">\n  <component :is=\"view\"></component>\n</KeepAlive>\n```\n\n### 4. 缓存实例数量 (`max`)\n`max` prop 可以限制最多缓存多少个组件实例。当缓存的实例数量达到 `max` 时，Vue 会在缓存新实例前，销毁最久没有被访问的那个实例（LRU 算法）。\n\n```vue\n<KeepAlive :max=\"10\">\n  <component :is=\"view\"></component>\n</KeepAlive>\n```\n\n## 注意事项\n\n- **组件名称**：`include` 和 `exclude` 是根据组件的 `name` 选项来匹配的。对于 `<script setup>` 的组件，通常需要额外添加一个普通的 `<script>` 块来定义 `name`。\n  ```vue\n  <script>\n  export default {\n    name: 'MyComponent'\n  }\n  </script>\n  <script setup>\n  // ...\n  </script>\n  ```\n- **RouterView 缓存**：缓存 `<RouterView>` 时，默认会缓存所有路由组件。可以通过 `v-slot` 和 `include`/`exclude` 结合，实现更精细的路由缓存策略。\n\n## 常见问题排查\n\n### 1. 组件没有被缓存\n**原因**：\n-   组件不是 `<KeepAlive>` 的直接子节点。\n-   `include` 或 `exclude` 的匹配规则不正确，或者组件没有定义 `name` 选项。\n\n**排查**：\n-   检查模板结构，确保动态组件是 `<KeepAlive>` 的直接子级。\n-   为需要被匹配的组件添加 `name` 选项，并检查 `include`/`exclude` 的值。\n\n### 2. 组件数据没有在切换回来时刷新\n**原因**：这是 `KeepAlive` 的预期行为，它保持了组件的状态。如果你希望在每次激活时都重新获取数据，应该在 `onActivated` 钩子中执行数据获取逻辑，而不是在 `onMounted` 中。"
  },
  {
    "name": "内置组件：Teleport",
    "summary": "将组件的一部分模板“传送”到 DOM 树中的另一个位置，通常用于处理全局模态框、通知或弹出层。",
    "notes": "# 内置组件：Teleport\n\n## 示例\n\n```vue\n<script setup>\nimport { ref } from 'vue'\nconst open = ref(false)\n</script>\n\n<template>\n  <!-- 这个按钮在组件的原始位置 -->\n  <button @click=\"open = true\">Open Modal</button>\n\n  <!-- Teleport 将其内容渲染到 body 标签下 -->\n  <Teleport to=\"body\">\n    <div v-if=\"open\" class=\"modal\">\n      <p>Hello from the modal!</p>\n      <button @click=\"open = false\">Close</button>\n    </div>\n  </Teleport>\n</template>\n\n<style scoped>\n.modal {\n  position: fixed;\n  z-index: 999;\n  top: 20%;\n  left: 50%;\n  width: 300px;\n  margin-left: -150px;\n  background-color: white;\n  padding: 20px;\n  border-radius: 8px;\n}\n</style>\n```\n\n## 解决的问题\n\n`Teleport` 主要解决了**DOM 结构限制**的问题。在某些情况下，一个组件的某部分模板在逻辑上属于该组件，但在视觉上需要被渲染到 DOM 树的其他地方。常见场景包括：\n- **模态框 (Modal)**：模态框需要覆盖整个页面，如果其 DOM 结构嵌套在某个有 `overflow: hidden` 或特定 `z-index` 的父元素中，就可能被裁剪或覆盖。\n- **通知/提示 (Notifications/Toasts)**：它们通常需要显示在视口的固定位置，与应用的其他部分无关。\n- **下拉菜单/工具提示 (Dropdowns/Tooltips)**：为了避免被父容器裁剪，有时需要将它们渲染到 `<body>` 下。\n\n`Teleport` 允许你将这部分 DOM “传送”出去，同时保持其逻辑上的父子关系。\n\n## 核心功能与使用方法\n\n### 1. `to` prop\n这是 `Teleport` 最关键的 prop，它指定了内容的传送目标。\n-   值可以是一个 CSS 选择器字符串，如 `to=\"#some-id\"` 或 `to=\".some-class\"`。\n-   也可以是一个 DOM 元素对象。\n-   最常用的目标是 `body`。\n\n### 2. 逻辑上的父子关系\n-   尽管 `Teleport` 的内容被移动到了 DOM 的其他位置，但它仍然是其所在 Vue 组件的逻辑子节点。\n-   这意味着它可以正常地接收来自父组件的 `props`，并且可以通过 `emit` 与父组件通信。\n-   `provide` 和 `inject` 也能正常工作。\n\n### 3. `disabled` prop\n可以动态地禁用 `Teleport` 功能。\n-   `<Teleport to=\"body\" :disabled=\"isMobile\">`\n-   当 `disabled` 为 `true` 时，内容将不会被传送，而是渲染在组件的原始位置。\n\n## 注意事项\n\n- **目标元素必须存在**：`Teleport` 挂载时，`to` 指定的目标元素必须已经存在于 DOM 中。否则，内容将不会被渲染，并在控制台给出警告。\n- **多个 `Teleport` 到同个目标**：如果多个 `Teleport` 组件传送到同一个目标元素，它们的内容会按照挂载的顺序追加到目标元素中。\n\n## 常见问题排查\n\n### 1. 内容未被传送，且控制台有警告 \"Failed to locate Teleport target\"\n**原因**：`to` prop 指定的目标在 `Teleport` 组件挂载时还不存在于 DOM 中。\n**解决**：\n-   确保你的 CSS 选择器是正确的。\n-   确保目标元素（如 `<div id=\"modals\"></div>`）在你的主 `index.html` 中是存在的，并且位于 Vue 应用挂载点 (`#app`) 的外部或同级。\n\n### 2. 传送后的内容样式丢失或错乱\n**原因**：如果你的组件使用了 `<style scoped>`，那么这些样式是基于 data-attribute 的。传送后的 DOM 元素仍然会带有这些 attribute，所以 `scoped` 样式通常能正常工作。\n但如果样式依赖于父组件的层级选择器（如 `.parent .child-class`），这些样式就会失效，因为 DOM 结构已经改变。\n**解决**：为传送的内容编写更通用的、不依赖于 DOM 嵌套关系的样式，或者使用全局样式。"
  },
  {
    "name": "内置组件：Suspense (实验性)",
    "summary": "协调组件树中的异步依赖，允许在等待异步组件或 `setup` 钩子完成时，在父级展示一个加载状态。",
    "notes": "# 内置组件：Suspense (实验性)\n\n**重要提示**：`Suspense` 仍然是 Vue 的一个实验性功能，其 API 在未来版本中可能会有变动。在生产环境中请谨慎使用。\n\n## 示例\n\n**异步组件 (`AsyncUserProfile.vue`)**\n```vue\n<script setup>\n// 模拟一个需要 2 秒才能获取的数据\nconst userData = await new Promise(resolve => {\n  setTimeout(() => {\n    resolve({ name: 'John Doe', bio: 'Vue Developer' })\n  }, 2000)\n})\n</script>\n\n<template>\n  <div>\n    <h2>{{ userData.name }}</h2>\n    <p>{{ userData.bio }}</p>\n  </div>\n</template>\n```\n\n**父组件**\n```vue\n<script setup>\nimport { defineAsyncComponent } from 'vue'\n\nconst AsyncUserProfile = defineAsyncComponent(() => \n  import('./AsyncUserProfile.vue')\n)\n</script>\n\n<template>\n  <Suspense>\n    <!-- #default 插槽：当异步操作完成时显示 -->\n    <template #default>\n      <AsyncUserProfile />\n    </template>\n\n    <!-- #fallback 插槽：在等待时显示 -->\n    <template #fallback>\n      <div>Loading profile...</div>\n    </template>\n  </Suspense>\n</template>\n```\n\n## 解决的问题\n\n`Suspense` 旨在简化处理**异步依赖**时的 UI 状态。在没有 `Suspense` 的情况下，你需要手动管理一个 `loading` 状态，并使用 `v-if`/`v-else` 来切换加载中和加载完成的视图。当有多个并行的异步依赖时，这种手动管理会变得非常复杂。\n\n`Suspense` 解决了：\n- **统一的加载状态**：为整个组件树或其一部分提供一个集中的加载状态视图 (`fallback`)。\n- **简化异步逻辑**：让你可以用更直观的 `async/await` 语法在组件的 `setup` 阶段获取数据，而无需关心加载状态的切换。\n\n## 核心功能与使用方法\n\n### 1. 两个插槽\n-   `#default`: 包含一个或多个异步依赖的组件。只有当其内部所有深层嵌套的异步依赖都解析完成后，这个插槽的内容才会被显示。\n-   `#fallback`: 在 `#default` 插槽内容准备就绪前，会显示此插槽的内容。\n\n### 2. 可等待的异步源\n`Suspense` 可以等待两种类型的异步源：\n-   带有一个 `async setup()` 钩子的组件。`Suspense` 会等待这个 `async` 函数 `resolve`。\n-   通过 `defineAsyncComponent` 定义的异步组件。`Suspense` 会等待这个组件被加载完成。\n\n### 3. 事件\n`Suspense` 组件会触发三个事件：\n-   `@pending`: 当进入挂起状态时触发。\n-   `@resolve`: 当 `#default` 插槽中的内容加载完成时触发。\n-   `@fallback`: 当显示 `fallback` 内容时触发。\n\n## 注意事项\n\n- **实验性**：API 可能会变，不建议在关键生产功能中使用。\n- **仅限 `setup` 阶段**：`Suspense` 只能捕获组件 `setup` 期间返回的 Promise。它**不能**处理在 `onMounted` 或其他钩子中，或者在用户交互后触发的异步操作。\n- **错误处理**：目前，`Suspense` 本身不提供错误处理。推荐使用 `onErrorCaptured` 钩子或 `defineAsyncComponent` 的 `errorComponent` 选项来处理异步依赖加载失败的情况。\n\n## 常见问题排查\n\n### 1. `fallback` 状态一直显示，不切换到 `default`\n**原因**：\n-   `async setup()` 中的 Promise 被 reject 了，并且没有被捕获。\n-   `async setup()` 中的 Promise 永远没有 resolve。\n\n**排查**：检查异步操作的逻辑，确保 Promise 最终会 resolve。使用 `onErrorCaptured` 钩子来捕获可能发生的错误。\n\n### 2. 我在 `onMounted` 中获取数据，但 `Suspense` 不工作\n**原因**：这是 `Suspense` 的设计限制。它只关心 `setup` 阶段的异步性。\n**解决**：将数据获取逻辑移入 `async setup()` 中。这是组合式 API 中推荐的数据获取模式之一。"
  },
  {
    "name": "Vue Composables (组合式函数)",
    "summary": "Vue 3 中组织和复用有状态逻辑的核心模式。通过将响应式状态和相关方法封装在普通函数中，实现逻辑的解耦和跨组件共享。",
    "notes": "# Vue Composables (组合式函数)\n\n## 示例\n\n### 创建并使用组合式函数 (Creating and Using a Composable)\n\n**1. 创建 `useMouse.js` 文件:**\n```javascript\n// composables/useMouse.js\nimport { ref, onMounted, onUnmounted } from 'vue';\n\n// 按照约定，组合式函数名以 “use” 开头\nexport function useMouse() {\n  // 被组合式函数封装和管理的状态\n  const x = ref(0);\n  const y = ref(0);\n\n  // 组合式函数可以挂靠在所属组件的生命周期上\n  function update(event) {\n    x.value = event.pageX;\n    y.value = event.pageY;\n  }\n\n  onMounted(() => window.addEventListener('mousemove', update));\n  onUnmounted(() => window.removeEventListener('mousemove', update));\n\n  // 通过返回值暴露所管理的状态\n  return { x, y };\n}\n```\n\n**2. 在组件中使用:**\n```vue\n<script setup>\nimport { useMouse } from './composables/useMouse.js';\n\nconst { x, y } = useMouse();\n</script>\n\n<template>Mouse position is: {{ x }}, {{ y }}</template>\n```\n\n## 解决的问题\n\n组合式函数是 Vue 3 解决逻辑复用问题的主要方式，旨在替代 Vue 2 中 Mixins 的不足：\n\n- **来源不清晰 (Unclear Source)**：使用多个 Mixin 时，不清楚某个属性或方法来自哪个 Mixin，增加了理解和调试的难度。组合式函数返回的值有明确的来源，如 `const { x, y } = useMouse()`，一目了然。\n- **命名空间冲突 (Namespace Collisions)**：不同的 Mixin 可能会定义同名的属性或方法，导致相互覆盖。组合式函数返回的是一个普通对象，可以自由地重命名解构出的变量，如 `const { x: mouseX, y: mouseY } = useMouse()`。\n- **隐式依赖 (Implicit Dependencies)**：Mixin 可能会依赖组件实例的特定属性（如 `this.someData`），这种依赖是隐式的。组合式函数通过函数参数明确地传递依赖。\n- **类型推断不友好**：Mixin 在 TypeScript 中的类型推断支持不佳。组合式函数是普通函数，能享受到完整的类型推断支持。\n\n## 核心功能与使用方法\n\n### 1. 概念\n组合式函数是一个利用 Vue 组合式 API 来封装和复用**有状态逻辑**的函数。它本质上只是一个普通的 JavaScript 函数。\n\n### 2. 约定\n- **命名**: 组合式函数名以 `use` 开头，例如 `useMouse`, `useFetch`。这是一种社区约定，也便于工具和开发者识别。\n- **输入**: 可以接受普通参数，也可以接受 `ref` 作为参数。`unref` 工具函数可以帮助在需要时获取 `ref` 的值。\n- **输出**: 必须返回一个普通对象，其中包含需要暴露给外部的响应式状态 (`ref`, `reactive`) 和方法。\n\n### 3. 生命周期管理\n组合式函数可以在其内部调用生命周期钩子（如 `onMounted`, `onUnmounted`），这些钩子会自动注册到调用它的组件实例上。这使得在组合式函数中管理副作用（如添加/移除事件监听器）变得非常方便。\n\n## 注意事项\n\n- **调用时机**: 组合式函数必须在组件的 `<script setup>` 或 `setup()` 函数的顶层同步调用。不能在异步回调或 `v-if` 块中调用，因为 Vue 需要在组件实例的上下文中注册钩子和响应式 эффекты。\n- **清理副作用**: 如果组合式函数创建了副作用（如定时器、DOM 事件监听），务必在 `onUnmounted` 钩子中进行清理，以防止内存泄漏。\n- **SSR 兼容性**: 在编写可能用于服务端渲染 (SSR) 的组合式函数时，要避免直接访问浏览器特有的 API（如 `window`, `document`）。副作用应放在 `onMounted` 钩子中，因为它只在客户端执行。\n- **不要解构 `reactive`**: 从组合式函数返回 `reactive` 对象时，如果直接解构，会失去其响应性。推荐使用 `toRefs` 转换后再解构，或者直接返回多个 `ref`。\n\n## 常见问题排查\n\n### 1. 响应性丢失 (Reactivity is lost)\n**问题**: 从组合式函数获取的状态在模板中不更新。\n**原因**: 从一个 `reactive` 对象中解构出了原始值，或者返回了非响应式的值。\n**错误示例**:\n```javascript\n// useSomething.js\nfunction useSomething() {\n  const state = reactive({ count: 0 });\n  return state; // 返回 reactive 对象\n}\n// Component.vue\nconst { count } = useSomething(); // 错误！count 是一个普通的数字 0，不是 ref\n```\n**解决**:\n- **方案一 (推荐)**: 组合式函数内部使用 `ref` 并返回。\n- **方案二**: 使用 `toRefs` 转换 `reactive` 对象。\n  ```javascript\n  // useSomething.js\n  function useSomething() {\n    const state = reactive({ count: 0 });\n    return toRefs(state);\n  }\n  // Component.vue\n  const { count } = useSomething(); // 正确！count 现在是一个 ref\n  ```\n\n### 2. 在错误的地方调用组合式函数\n**问题**: 控制台报错 `[Vue warn]: onMounted is called when there is no active component instance`。\n**原因**: 在 `setup` 之外的异步函数、或 `v-if` 等条件块中调用了组合式函数。\n**解决**: 确保所有组合式函数的调用都在 `<script setup>` 或 `setup()` 函数的同步、顶层上下文中。"
  },
  {
    "name": "Vue Custom Directives (自定义指令)",
    "summary": "创建你自己的指令，用于直接操作 DOM，封装可重用的底层 DOM 行为。",
    "examples": [
      {
        "description": "创建一个 v-focus 指令，在元素挂载时自动获取焦点",
        "code": "// 1. 定义指令 (main.js 或 directives.js)\nconst app = createApp(App)\napp.directive('focus', {\n  // 当被绑定的元素挂载到 DOM 中时\n  mounted(el) {\n    el.focus()\n  }\n})\n\n// 2. 在模板中使用\n// <input v-focus />"
      },
      {
        "description": "创建一个带参数的指令，用于动态绑定样式",
        "code": "// 1. 定义指令\napp.directive('color', (el, binding) => {\n  // binding.value 是指令的绑定值\n  el.style.color = binding.value\n})\n\n// 2. 在模板中使用\n/*\n<template>\n  <p v-color=\"'red'\">This text is red.</p>\n  <p v-color=\"dynamicColor\">This text color is bound to a variable.</p>\n</template>\n<script setup>\n  import { ref } from 'vue'\n  const dynamicColor = ref('blue')\n</script>\n*/"
      },
      {
        "description": "指令的完整钩子函数和参数",
        "code": "app.directive('my-directive', {\n  created(el, binding, vnode, prevVnode) {},\n  beforeMount(el, binding, vnode, prevVnode) {},\n  mounted(el, binding, vnode, prevVnode) {},\n  beforeUpdate(el, binding, vnode, prevVnode) {},\n  updated(el, binding, vnode, prevVnode) {},\n  beforeUnmount(el, binding, vnode, prevVnode) {},\n  unmounted(el, binding, vnode, prevVnode) {}\n})\n\n// binding 对象包含: value, oldValue, arg, modifiers"
      },
      {
        "description": "在组件内部局部注册指令",
        "code": "/*\n<script setup>\n// 定义指令\nconst vMyDirective = {\n  mounted: (el) => {\n    // ...\n  }\n}\n</script>\n<template>\n  <div v-my-directive>...</div>\n</template>\n*/"
      }
    ],
    "notes": "自定义指令主要用于需要直接操作底层 DOM 的场景。当需要实现数据驱动的、更复杂的逻辑时，应优先考虑使用组件。一个常见的经验法则是：如果你的逻辑不依赖于组件的任何响应式状态，只是单纯的 DOM 操作，那么指令是一个很好的选择。",
    "api_type": "Vue Core"
  },
  {
    "name": "vue-router",
    "summary": "Vue.js 的官方路由管理器，用于构建单页应用 (SPA)，实现客户端的页面导航和视图切换。",
    "notes": "# vue-router\n\n## 示例\n\n### 安装依赖\n\n```bash\nnpm install vue-router@4\n```\n\n### 创建和配置路由\n\n1.  **创建路由文件 (`src/router/index.js`)**\n\n    ```javascript\n    import { createRouter, createWebHistory } from 'vue-router';\n    import HomeView from '../views/HomeView.vue';\n\n    const routes = [\n      {\n        path: '/',\n        name: 'home',\n        component: HomeView\n      },\n      {\n        path: '/about',\n        name: 'about',\n        // 路由懒加载 (Route-level code-splitting)\n        component: () => import('../views/AboutView.vue')\n      },\n      {\n        path: '/user/:id',\n        name: 'user-profile',\n        component: () => import('../views/UserProfile.vue'),\n        props: true // 将路由参数作为 props 传递给组件\n      }\n    ];\n\n    const router = createRouter({\n      history: createWebHistory(import.meta.env.BASE_URL),\n      routes\n    });\n\n    export default router;\n    ```\n\n2.  **在 `main.js` 中注册**\n\n    ```javascript\n    import { createApp } from 'vue';\n    import App from './App.vue';\n    import router from './router';\n\n    createApp(App).use(router).mount('#app');\n    ```\n\n3.  **在组件中使用**\n\n    ```html\n    <!-- App.vue -->\n    <template>\n      <nav>\n        <router-link to=\"/\">Home</router-link> |\n        <router-link to=\"/about\">About</router-link>\n      </nav>\n      <!-- 路由出口：匹配到的组件将在这里渲染 -->\n      <router-view/>\n    </template>\n    ```\n\n## 解决的问题\n\nVue Router 解决了构建**单页应用 (Single-Page Application, SPA)** 的核心问题：\n\n- **客户端路由**：在不重新加载整个页面的情况下，根据 URL 的变化来切换和渲染不同的视图组件，提供流畅的用户体验。\n- **浏览器历史管理**：与浏览器的历史记录 API 集成，支持前进、后退和直接通过 URL 访问特定页面。\n- **模块化视图组织**：将应用的不同功能页面拆分为独立的组件，并通过路由进行组织和管理。\n- **数据传递和状态同步**：通过路由参数、查询和 props 将数据从 URL 传递到组件中。\n\n## 核心功能与使用方法\n\n### 1. 路由模式\n- **History 模式 (`createWebHistory`)**：使用标准的浏览器历史记录 API，URL 看起来更“干净”（如 `example.com/user/1`）。需要服务器端配置支持，将所有未匹配到静态资源的请求都指向 `index.html`。\n- **Hash 模式 (`createWebHashHistory`)**：URL 中带有 `#` 符号（如 `example.com/#/user/1`）。无需服务器配置，兼容性好。\n\n### 2. 动态路由匹配\n使用 `:paramName` 语法定义动态路径段，如 `/user/:id`。在组件中通过 `useRoute().params.id` 获取。\n\n### 3. 导航守卫 (Navigation Guards)\n用于在路由跳转前后执行逻辑，常用于权限验证、数据获取等。\n- **全局守卫**: `router.beforeEach()`\n- **路由独享守卫**: 在路由配置中使用 `beforeEnter`\n- **组件内守卫**: `onBeforeRouteUpdate`, `onBeforeRouteLeave`\n\n### 4. 路由懒加载\n使用 `() => import('...')` 语法按需加载路由组件，减小初始包体积，加快首页加载速度。\n\n## 常用 API 和组件\n\n- **`createRouter`**: 创建路由实例。\n- **`useRouter`**: 在 `<script setup>` 中获取路由实例，用于编程式导航 (`router.push()`, `router.replace()`).\n- **`useRoute`**: 获取当前激活的路由对象，包含路径、参数、查询等信息。\n- **`<router-link>`**: 声明式的导航链接组件，会被渲染为 `<a>` 标签。\n- **`<router-view>`**: 路由出口，用于渲染匹配到的组件。\n\n## 常见问题排查\n\n### 1. 页面空白或组件未渲染\n**原因**：\n- 忘记在根组件中添加 `<router-view>`。\n- 路由路径配置错误，没有匹配到任何组件。\n- 路由实例未在 `main.js` 中通过 `.use(router)` 注册。\n**解决**：逐一检查上述配置点。\n\n### 2. History 模式下刷新页面报 404\n**原因**：服务器不知道如何处理 `/about` 这样的前端路由，会尝试寻找一个名为 `about` 的文件，从而失败。\n**解决**：配置你的 Web 服务器（如 Nginx, Apache）将所有非静态文件请求重定向到应用的 `index.html`。\n\n### 3. 如何在组件中获取路由参数？\n**解决**：\n- 使用 `const route = useRoute()`，然后访问 `route.params.id`。\n- 在路由配置中设置 `props: true`，然后通过组件的 `props` 直接接收，如 `defineProps(['id'])`。\n\n### 4. `<router-link>` 无法添加自定义样式或行为\n**解决**：使用 `v-slot` API 来自定义 `<router-link>` 的渲染内容，可以完全控制其子元素和事件。\n\n```html\n<router-link to=\"/foo\" v-slot=\"{ href, route, navigate, isActive }\">\n  <a :href=\"href\" @click=\"navigate\" :class=\"{ 'active-link': isActive }\">\n    {{ route.fullPath }}\n  </a>\n</router-link>\n```"
  },
  {
    "name": "pinia",
    "summary": "Vue 官方推荐的状态管理库，以其直观、类型安全和模块化的设计，成为 Vue 3 应用的首选。",
    "notes": "# pinia\n\n## 示例\n\n### 安装依赖\n\n```bash\nnpm install pinia\n```\n\n### 创建和配置 Pinia\n\n1.  **在 `main.js` 中注册**\n\n    ```javascript\n    import { createApp } from 'vue';\n    import { createPinia } from 'pinia';\n    import App from './App.vue';\n\n    const pinia = createPinia();\n    const app = createApp(App);\n\n    app.use(pinia);\n    app.mount('#app');\n    ```\n\n2.  **定义一个 Store (`src/stores/counter.js`)**\n\n    ```javascript\n    import { defineStore } from 'pinia';\n\n    export const useCounterStore = defineStore('counter', {\n      // State: 推荐使用函数返回，避免跨请求状态污染\n      state: () => ({ \n        count: 0,\n        name: 'Eduardo'\n      }),\n\n      // Getters: 类似于组件的 computed\n      getters: {\n        doubleCount: (state) => state.count * 2,\n      },\n\n      // Actions: 类似于组件的 methods，可异步\n      actions: {\n        increment() {\n          this.count++;\n        },\n        async randomizeCounter() {\n          const response = await fetch('https://www.random.org/integers/?num=1&min=1&max=100&col=1&base=10&format=plain');\n          const num = await response.json();\n          this.count = num;\n        },\n      },\n    });\n    ```\n\n3.  **在组件中使用 Store**\n\n    ```vue\n    <script setup>\n    import { useCounterStore } from '@/stores/counter';\n    import { storeToRefs } from 'pinia';\n\n    const counterStore = useCounterStore();\n    \n    // 为保持响应性，使用 storeToRefs 解构 state 和 getters\n    const { count, name, doubleCount } = storeToRefs(counterStore);\n\n    // Actions 可以直接从 store 实例中解构\n    const { increment, randomizeCounter } = counterStore;\n    </script>\n\n    <template>\n      <p>Count: {{ count }}</p>\n      <p>Double Count: {{ doubleCount }}</p>\n      <p>Name: {{ name }}</p>\n      <button @click=\"increment\">Increment</button>\n      <button @click=\"randomizeCounter\">Randomize</button>\n    </template>\n    ```\n\n## 解决的问题\n\nPinia 旨在解决**跨组件、跨页面的全局状态共享**问题，同时改进了 Vuex 的体验：\n\n- **Props 钻孔 (Prop Drilling)**：避免了通过多层嵌套的组件逐层传递 props 的繁琐过程。\n- **状态逻辑分离**：将全局状态及其相关逻辑（如修改、计算）从组件中抽离，使组件更专注于视图，状态逻辑更易于管理和测试。\n- **类型安全**：为 TypeScript 提供了极好的支持，实现了完整的类型推断，减少了运行时错误。\n- **简化 API**：相比 Vuex，Pinia 移除了 `mutations`，API 更简洁直观，学习成本更低。\n\n## 核心功能与使用方法\n\n- **`defineStore`**: 定义一个 Store，第一个参数是 Store 的唯一 ID。\n- **State**: Store 的核心数据，必须是一个返回对象的函数。\n- **Getters**: 派生状态，相当于 Store 的计算属性。\n- **Actions**: 修改 state 的方法，可以是同步或异步的。\n- **插件系统**: 可以通过插件扩展 Pinia 的功能，例如实现本地持久化存储。\n\n## Key APIs\n\n- **`defineStore(id, options)`**: 创建 Store。\n- **`createPinia()`**: 创建 Pinia 实例。\n- **`storeToRefs(store)`**: 将 Store 中的响应式属性（state, getters）转换为 `ref` 对象，以便在解构时保持响应性。\n- **`$patch(partialState)`**: 一次性修改多个 state 属性，性能更好。\n- **`$subscribe(callback)`**: 订阅 state 的变化。\n\n## 注意事项\n\n- **响应性丢失问题**：直接解构 `state` 会使其失去响应性。例如 `const { count } = useCounterStore()` 是错误的。必须使用 `storeToRefs` 来处理。\n- **Store 的 ID 必须唯一**：`defineStore` 的第一个参数是所有 Store 中的唯一标识符。\n- **与 Vue Devtools 集成**：Pinia 与 Vue Devtools 无缝集成，可以方便地在浏览器中调试状态变化。\n\n## 常见问题排查\n\n### 1. Store is not defined / Pinia has not been installed\n**原因**：在 `main.js` 中忘记创建 Pinia 实例并通过 `app.use(pinia)` 进行注册。\n**解决**：确保在应用根实例上正确安装了 Pinia。\n\n### 2. 修改了 State，但视图没有更新\n**原因**：很可能是因为直接解构了 `state` 或 `getters`，导致其失去了响应性。\n**解决**：使用 `storeToRefs` 来包装 store 实例后再进行解构。`const { count } = storeToRefs(useCounterStore())`。\n\n### 3. Action 中如何调用其他 Action？\n**解决**：在 Action 内部，可以通过 `this` 关键字访问同一个 Store 的其他 Action、State 和 Getter。例如 `this.increment()`。\n\n### 4. 如何在 Store 之间互相调用？\n**解决**：在一个 Store 的 Action 中，可以直接导入并调用另一个 Store。例如 `const otherStore = useOtherStore()`。"
  },
  {
    "name": "vuex",
    "summary": "Vue 2 时代的官方状态管理库。虽然现在官方推荐 Pinia，但在维护旧项目或特定场景下仍有使用。",
    "notes": "# vuex\n\n**注意：Pinia 现在是 Vue 官方推荐的状态管理库。Vuex 主要用于维护基于 Vue 2 或已深度使用 Vuex 的 Vue 3 旧项目。**\n\n## 示例\n\n### 安装依赖\n\n```bash\n# 对于 Vue 3\nnpm install vuex@next --save\n```\n\n### 创建和配置 Vuex\n\n1.  **定义一个 Store (`src/store/index.js`)**\n\n    ```javascript\n    import { createStore } from 'vuex';\n\n    export default createStore({\n      // 严格模式，确保 state 只能由 mutations 修改\n      strict: process.env.NODE_ENV !== 'production',\n\n      // State: 单一状态树\n      state: {\n        count: 0\n      },\n\n      // Getters: 派生状态 (类似 computed)\n      getters: {\n        doubleCount: state => state.count * 2\n      },\n\n      // Mutations: 同步修改 state 的唯一方式\n      mutations: {\n        INCREMENT(state, payload = 1) {\n          state.count += payload;\n        }\n      },\n\n      // Actions: 提交 mutations，可包含异步操作\n      actions: {\n        incrementAsync({ commit }) {\n          setTimeout(() => {\n            commit('INCREMENT');\n          }, 1000);\n        }\n      },\n\n      // Modules: 将 store 拆分为模块\n      modules: {\n      }\n    });\n    ```\n\n2.  **在 `main.js` 中注册**\n\n    ```javascript\n    import { createApp } from 'vue';\n    import App from './App.vue';\n    import store from './store';\n\n    createApp(App).use(store).mount('#app');\n    ```\n\n3.  **在组件中使用 Store**\n\n    ```vue\n    <script setup>\n    import { useStore } from 'vuex';\n    import { computed } from 'vue';\n\n    const store = useStore();\n\n    const count = computed(() => store.state.count);\n    const doubleCount = computed(() => store.getters.doubleCount);\n\n    function increment() {\n      store.commit('INCREMENT', 2); // 提交 mutation\n    }\n\n    function incrementAsync() {\n      store.dispatch('incrementAsync'); // 分发 action\n    }\n    </script>\n\n    <template>\n      <p>Count: {{ count }}</p>\n      <p>Double Count: {{ doubleCount }}</p>\n      <button @click=\"increment\">Increment by 2</button>\n      <button @click=\"incrementAsync\">Increment Async</button>\n    </template>\n    ```\n\n## 解决的问题\n\nVuex 与 Pinia 解决的是同样的问题：**集中式的状态管理**。它通过创建一个全局的“仓库”来存储应用的所有组件共享的状态，并规定了一套规则来确保状态以可预测的方式发生变化。\n\n## 核心功能与使用方法\n\n- **State**: 驱动应用的单一数据源。\n- **Getters**: 从 state 中派生出一些状态，类似于计算属性。\n- **Mutations**: **同步**更改 Vuex 的 store 中的状态的唯一方法。每个 mutation 都有一个字符串的 **事件类型 (type)** 和一个 **处理函数 (handler)**。\n- **Actions**: 类似于 mutation，不同在于：\n  - Action 提交的是 mutation，而不是直接变更状态。\n  - Action 可以包含任意异步操作。\n- **Modules**: 允许将 store 分割成模块。每个模块拥有自己的 state、mutation、action、getter。\n\n## 与 Pinia 的主要区别\n\n- **Mutations**: Vuex 强制使用 `mutations` 来同步修改 `state`，而 Pinia 移除了这一概念，可以直接在 `actions` 中修改 `state`，API 更简洁。\n- **类型支持**: Pinia 对 TypeScript 的支持是开箱即用的，类型推断非常完善。Vuex 的类型支持则相对繁琐。\n- **模块化**: Pinia 的模块化设计更自然，每个 store 都是一个独立的模块。Vuex 的模块需要嵌套在主 store 中。\n- **API 设计**: Pinia 的 API 更接近 Vue 3 的组合式 API，更易于理解和使用。\n\n## 常见问题排查\n\n### 1. `[vuex] unknown mutation type: XXX`\n**原因**：`store.commit()` 传入的 mutation 类型字符串与 `mutations` 对象中定义的键名不匹配。\n**解决**：检查字符串拼写是否一致。推荐使用常量来管理 mutation 类型，避免拼写错误。\n\n### 2. 在 mutation 中执行异步操作\n**问题**：在 mutation 中执行异步代码，Devtools 无法正确追踪状态变化。\n**原因**：Vuex 的设计原则是 mutation 必须是同步的。\n**解决**：将异步逻辑移到 `actions` 中，在异步操作完成后再 `commit` 一个 mutation。\n\n### 3. 如何在模块化的 Store 中分发 Action 或提交 Mutation？\n**解决**：\n- 默认情况下，模块内的 action 和 mutation 是注册在全局命名空间的。\n- 如果模块开启了命名空间 (`namespaced: true`)，则需要使用带路径的名称，如 `store.commit('moduleA/INCREMENT')`。"
  },
  {
    "name": "vite",
    "summary": "新一代前端构建工具，以其极速的开发服务器和基于 Rollup 的优化构建，成为 Vue 3 项目的默认选择。",
    "notes": "# vite\n\n## 示例\n\n### 创建一个 Vue + Vite 项目\n\n```bash\nnpm create vite@latest my-vue-app -- --template vue\n```\n\n### 配置文件 `vite.config.js`\n在项目根目录下创建或修改 `vite.config.js` 来配置 Vite 的行为。\n\n```javascript\nimport { defineConfig } from 'vite';\nimport vue from '@vitejs/plugin-vue';\nimport path from 'path';\n\n// https://vitejs.dev/config/\nexport default defineConfig({\n  plugins: [vue()],\n\n  // 配置开发服务器\n  server: {\n    port: 3000,\n    // 配置代理，解决开发环境跨域问题\n    proxy: {\n      '/api': {\n        target: 'http://jsonplaceholder.typicode.com',\n        changeOrigin: true,\n        rewrite: (path) => path.replace(/^\\/api/, '')\n      }\n    }\n  },\n\n  // 配置路径别名\n  resolve: {\n    alias: {\n      '@': path.resolve(__dirname, './src')\n    }\n  }\n});\n```\n\n## 解决的问题\n\nVite 旨在解决传统基于打包器的构建工具（如 Webpack）在大型项目中所面临的性能瓶颈问题：\n\n- **缓慢的开发服务器启动**：传统工具在启动时需要遍历并构建整个应用的依赖图，大型项目可能需要数分钟。\n- **缓慢的热更新 (HMR)**：修改一个文件后，即使是热更新，也可能需要重新计算和构建相当一部分代码，导致更新延迟。\n\nVite 通过两种方式解决了这些问题：\n1.  **开发时**: 利用浏览器原生的 ES 模块支持，按需提供源码，无需打包。这使得服务器启动几乎是瞬时的。\n2.  **构建时**: 使用高度优化的 Rollup 进行打包，生成用于生产环境的高效静态资源。\n\n## 核心功能与使用方法\n\n- **极速的开发服务器**: 通过 `npm run dev` 启动，支持 TypeScript, JSX, CSS 等开箱即用的支持。\n- **高效的热模块替换 (HMR)**: HMR API 精细化，更新速度与项目大小无关。\n- **优化的构建**: `npm run build` 命令使用 Rollup 打包，并提供代码分割、CSS 优化等功能。\n- **丰富的插件系统**: Vite 的功能可以通过插件进行扩展，与 Rollup 的插件生态兼容。\n- **配置文件**: 所有配置都在 `vite.config.js`（或 `.ts`）中完成。\n\n## 常用配置项\n\n- **`plugins`**: 配置要使用的 Vite 插件，如 `@vitejs/plugin-vue`。\n- **`server.proxy`**: 配置开发服务器的请求代理，用于解决跨域问题。\n- **`resolve.alias`**: 设置路径别名，简化模块导入路径。\n- **`build.outDir`**: 指定生产构建的输出目录（默认为 `dist`）。\n- **`envPrefix`**: 配置暴露给客户端代码的环境变量前缀。\n\n## 环境变量\n\nVite 通过 `import.meta.env` 对象暴露环境变量。\n- 在项目根目录创建 `.env` 文件（如 `.env.development`, `.env.production`）。\n- 只有以 `VITE_` 为前缀的变量才会被暴露给客户端代码，以防意外泄漏。\n\n```bash\n# .env.local\nVITE_API_BASE_URL=http://localhost:8080/api\n```\n\n在代码中访问：`const baseUrl = import.meta.env.VITE_API_BASE_URL;`\n\n## 常见问题排查\n\n### 1. 开发服务器代理不生效\n**原因**：\n- 代理配置的 `target` 或 `rewrite` 规则不正确。\n- 请求的 URL 路径没有匹配到代理的 key（如 `/api`）。\n**解决**：\n- 检查 `vite.config.js` 中的 `server.proxy` 配置。\n- 打开浏览器开发者工具，确认网络请求的路径是否正确。\n\n### 2. 生产构建失败或运行不正常\n**原因**：开发环境和生产环境的机制不同，某些代码可能在开发时正常，但在 Rollup 打包后出现问题。\n**排查**：\n- 检查代码中是否使用了 CommonJS 语法，而 Rollup 期望 ES 模块。\n- 某些依赖可能需要特定的构建配置。\n- 运行 `npm run preview` 在本地预览生产构建的结果，方便调试。\n\n### 3. 图片或静态资源无法加载\n**原因**：资源路径问题。\n**解决**：\n- 将静态资源放在 `public` 目录下，它们会被直接复制到构建输出的根目录，可以通过绝对路径 `/` 访问。\n- 在 `<script>` 或 CSS 中通过相对路径导入资源，Vite 会在构建时处理路径并进行哈希化。"
  }
]